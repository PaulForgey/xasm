1000:01 08        .dw $801
1002:             .or $801
0801:         
0801:             ; 10 SYS 2062
0801:0c 08 0a 00 
                 .dw zero, 10
0805:9e 20 32 30 36 32 00 
                 .db $9e,' 2062',0
080c:         zero:
080c:00 00        .dw 0
080e:         
080e:             *=2062
080e:         
080e:             .in 'zp.asm'
080e:             .fi ; zpAsm
080e:         
080e:             .in 'kernal.asm'
080e:             .fi ; kernalAsm
080e:         
080e:         
080e:         options=$bf00
080e:         
080e:ba           tsx
080f:8e ed 1c     stx asmSP
0812:20 fd 12     jsr ioInit
0815:20 f1 09     jsr symInit
0818:64 40        stz pass
081a:9c f6 1c     stz listOpt
081d:9c f9 1c     stz outOpt
0820:64 44        stz lineIfs
0822:64 45        stz lineIfd
0824:a9 ff        lda #$ff
0826:85 43        sta ePtr
0828:80 0a        bra begin
082a:         
082a:         usage:
082a:a2 92        ldx #<usageStr
082c:a0 09        ldy #>usageStr
082e:20 bc 16     jsr ioPrint
0831:4c 7b 09     jmp exit
0834:         
0834:         begin:
0834:64 00        stz $00             ; select system bank for params
0836:a9 04        lda #4
0838:85 01        sta $01             ; select rom bank 4
083a:20 d2 09     jsr getOpt
083d:c9 00        cmp #0
083f:d0 07        bne :got
0841:20 2f 09     jsr askArgs         ; get interactively
0844:c9 00        cmp #0
0846:f0 e2        beq usage
0848:         :got
0848:20 ab 13     jsr ioCopySourceName
084b:8d f3 1c     sta inputOpt        ; source filename length
084e:8e f4 1c     stx inputName
0851:8c f5 1c     sty inputName+1
0854:         
0854:20 d2 09     jsr getOpt          ; output
0857:c9 00        cmp #0
0859:f0 0c        beq :nooutOpt
085b:20 75 13     jsr ioCopyDestName
085e:8d f9 1c     sta outOpt          ; dest filename length
0861:8e fa 1c     stx outName
0864:8c fb 1c     sty outName+1
0867:         :nooutOpt
0867:         
0867:20 d2 09     jsr getOpt          ; listing
086a:c9 00        cmp #0
086c:f0 0c        beq :nolistOpt
086e:20 90 13     jsr ioCopyListName
0871:8d f6 1c     sta listOpt
0874:8e f7 1c     stx listName
0877:8c f8 1c     sty listName+1
087a:         :nolistOpt
087a:         
087a:         asmPass:
087a:64 2d        stz symScope
087c:64 2e        stz symScope+1
087e:         
087e:ae f4 1c     ldx inputName
0881:ac f5 1c     ldy inputName+1
0884:ad f3 1c     lda inputOpt
0887:20 20 14     jsr ioPush
088a:         
088a:9c f1 1c     stz pc
088d:a9 10        lda #$10
088f:8d f2 1c     sta pc+1            ; default pc=$1000
0892:         
0892:a2 bb        ldx #<passStr       ; "pass:n"
0894:a0 09        ldy #>passStr
0896:20 bc 16     jsr ioPrint
0899:a5 40        lda pass            ; pass #
089b:29 07        and #$07
089d:1a           inc
089e:20 8c 16     jsr ioPrintHex
08a1:a9 0d        lda #13             ; cr
08a3:20 d2 ff     jsr CHROUT
08a6:         
08a6:         :line
08a6:20 42 16     jsr ioListing       ; possibly show pc for listing
08a9:20 1f 15     jsr ioReadLine      ; read next line
08ac:20 88 09     jsr asmError        ; poll for error
08af:ad eb 1c     lda ioLFN           ; check for EOF
08b2:f0 29        beq :next
08b4:         
08b4:20 d1 0e     jsr lineAsm         ; assemble line
08b7:20 88 09     jsr asmError        ; poll for error
08ba:         
08ba:a5 40        lda pass
08bc:10 e8        bpl :line           ; listing output in second pass, if enabled
08be:a5 44        lda lineIfs
08c0:30 e4        bmi :line           ; do not list if'd out 
08c2:         
08c2:20 5f 16     jsr ioPadListing
08c5:         
08c5:a2 00        ldx #0
08c7:         :listLine
08c7:bd 00 20     lda lineBuf,x
08ca:f0 0a        beq :listed         ; eof
08cc:c9 0d        cmp #13
08ce:f0 06        beq :listed         ; cr
08d0:20 75 15     jsr ioEmit
08d3:e8           inx
08d4:d0 f1        bne :listLine
08d6:         :listed
08d6:a9 0d        lda #13
08d8:20 75 15     jsr ioEmit
08db:80 c9        bra :line
08dd:         
08dd:         :next
08dd:a5 40        lda pass            ; maybe done if non-z pass
08df:d0 21        bne :listing
08e1:1a           inc                 ; pass++
08e2:85 40        sta pass
08e4:         
08e4:ad f9 1c     lda outOpt          ; do we have output?
08e7:f0 19        beq :listing        ; no, skip to listing (if enabled)
08e9:         
08e9:ae fa 1c     ldx outName         ; set up output filename
08ec:ac fb 1c     ldy outName+1
08ef:20 06 14     jsr ioOpenDest      ; open
08f2:20 88 09     jsr asmError        ; poll for error
08f5:         
08f5:a9 75        lda #<ioEmit        ; connect the output hose
08f7:8d e5 1c     sta emit
08fa:a9 15        lda #>ioEmit
08fc:8d e6 1c     sta emit+1
08ff:4c 7a 08     jmp asmPass         ; go around again
0902:         
0902:         :listing
0902:20 f6 15     jsr ioClose         ; flush and close output or listing
0905:20 88 09     jsr asmError
0908:         
0908:a5 40        lda pass
090a:30 46        bmi asmDone         ; listed, we are done
090c:1a           inc
090d:09 80        ora #$80
090f:85 40        sta pass
0911:         
0911:ad f6 1c     lda listOpt
0914:f0 3c        beq asmDone         ; no listing, we are done
0916:         
0916:ae f7 1c     ldx listName        ; open the listing file  
0919:ac f8 1c     ldy listName+1
091c:         
091c:20 06 14     jsr ioOpenDest      ; open
091f:20 88 09     jsr asmError        ; poll for error
0922:         
0922:a9 8c        lda #<ioEmitListing
0924:8d e5 1c     sta emit
0927:a9 15        lda #>ioEmitListing
0929:8d e6 1c     sta emit+1
092c:4c 7a 08     jmp asmPass
092f:         
092f:         askArgs:
092f:a9 3f        lda #'?
0931:20 d2 ff     jsr CHROUT
0934:a2 00        ldx #0
0936:86 25        stx optPtr
0938:         :loop
0938:20 cf ff     jsr CHRIN
093b:c9 0d        cmp #13
093d:f0 06        beq :done
093f:9d 00 bf     sta options,x
0942:e8           inx
0943:d0 f3        bne :loop
0945:         :done
0945:9e 00 bf     stz options,x
0948:a9 0d        lda #13             ; cr
094a:20 d2 ff     jsr CHROUT
094d:64 25        stz optPtr
094f:4c d2 09     jmp getOpt
0952:         
0952:         asmDone:
0952:a2 c2        ldx #<symendStr     ; "symend="
0954:a0 09        ldy #>symendStr
0956:20 bc 16     jsr ioPrint
0959:a5 42        lda symEnd+1
095b:20 8c 16     jsr ioPrintHex
095e:a5 41        lda symEnd
0960:20 8c 16     jsr ioPrintHex
0963:a2 cc        ldx #<pcStr         ; "pc="
0965:a0 09        ldy #>pcStr
0967:20 bc 16     jsr ioPrint
096a:ad f2 1c     lda pc+1
096d:20 8c 16     jsr ioPrintHex
0970:ad f1 1c     lda pc
0973:20 8c 16     jsr ioPrintHex
0976:a9 0d        lda #13
0978:20 d2 ff     jsr CHROUT
097b:         
097b:         exit:
097b:a2 00        ldx #0              ; zero out options buf on our way out
097d:         :fill
097d:9e 00 bf     stz options,x
0980:e8           inx
0981:d0 fa        bne :fill
0983:ae ed 1c     ldx asmSP           ; get top level stack pointer
0986:9a           txs
0987:60           rts                 ; exit out completely    
0988:         
0988:         asmError:
0988:a5 46        lda error           ; error non-z?
098a:f0 05        beq :fine
098c:20 2a 13     jsr ioError         ; print error
098f:80 ea        bra exit            ; abort
0991:         :fine
0991:60           rts
0992:         
0992:         usageStr:
0992:55 53 41 47 45 3a 20 58 
099a:41 53 4d 20 49 4e 50 55 
09a2:54 2e 41 53 4d 5b 3b 4f 
09aa:55 54 50 55 54 5d 5b 3b 
09b2:4c 49 53 54 49 4e 47 5d 
09ba:00           .db 'usage: xasm input.asm[;output][;listing]',0
09bb:         passStr:
09bb:0d 50 41 53 53 3a 00 
                 .db 13,'pass:',0
09c2:         symendStr:
09c2:0d 53 59 4d c5 4e 44 3d 
09ca:24 00        .db 13,'symEnd=$',0
09cc:         pcStr:
09cc:0d 50 43 3d 24 00 
                 .db 13,'pc=$',0
09d2:         
09d2:         ;
09d2:         ; returns next option in a/x/y
09d2:         getOpt:
09d2:a6 25        ldx optPtr
09d4:86 22        stx scratch
09d6:a0 00        ldy #0
09d8:         :loop
09d8:bd 00 bf     lda options,x
09db:f0 0c        beq :got
09dd:c9 0d        cmp #13         ; cr (shouldn't see this, but be defensive)
09df:f0 08        beq :got
09e1:e8           inx
09e2:c9 3b        cmp #';
09e4:f0 03        beq :got
09e6:c8           iny
09e7:d0 ef        bne :loop
09e9:         :got
09e9:98           tya
09ea:86 25        stx optPtr
09ec:a6 22        ldx scratch
09ee:a0 bf        ldy #>options
09f0:60           rts
09f1:          
09f1:             .in 'symtab.asm'
09f1:             .in 'zp.asm'
09f1:             .fi ; zpAsm
09f1:         
09f1:         
09f1:         ;
09f1:         ; initialize hash table
09f1:         symInit:
09f1:a9 00        lda #<symbols
09f3:85 41        sta symEnd
09f5:a9 22        lda #>symbols
09f7:85 42        sta symEnd+1
09f9:a2 00        ldx #0
09fb:         
09fb:         :fill
09fb:9e 00 21     stz hashTable,x
09fe:e8           inx
09ff:d0 fa        bne :fill
0a01:         
0a01:60           rts
0a02:         
0a02:         ; layout of a symbol entry:
0a02:         ; 00-01:    next (0 if end)
0a02:         ; 02-03:    scope (parent entry, or 0)
0a02:         ; 04:       caller status
0a02:         ; 05-06:    value
0a02:         
0a02:         ;
0a02:         ; enter or return existing symbol entry
0a02:         ; result in ptr
0a02:         symGet:
0a02:             ; string = strGet
0a02:             ; nptr = (string).symbols
0a02:20 63 0a     jsr strGet
0a05:a0 02        ldy #2
0a07:b1 27        lda (ptr),y
0a09:85 25        sta nptr
0a0b:a5 27        lda ptr
0a0d:85 23        sta string
0a0f:c8           iny
0a10:b1 27        lda (ptr),y
0a12:85 26        sta nptr+1
0a14:a5 28        lda ptr+1
0a16:85 24        sta string+1
0a18:         
0a18:         :next
0a18:20 07 0b     jsr ptrNext
0a1b:f0 0e        beq :notFound
0a1d:         
0a1d:             ; compare scope
0a1d:b1 27        lda (ptr),y
0a1f:c5 2d        cmp symScope
0a21:d0 f5        bne :next
0a23:c8           iny
0a24:b1 27        lda (ptr),y
0a26:c5 2e        cmp symScope+1
0a28:d0 ee        bne :next
0a2a:         
0a2a:             ; found!
0a2a:60           rts
0a2b:         
0a2b:         :notFound
0a2b:             ; push our scoped entry
0a2b:             ; ptr = symEnd
0a2b:             ; symEnd += 7
0a2b:a9 07        lda #7
0a2d:20 f3 0a     jsr symPush
0a30:         
0a30:         
0a30:             ; nptr = (string).symbols
0a30:             ; (string).symbols = ptr
0a30:a0 02        ldy #2
0a32:b1 23        lda (string),y
0a34:85 25        sta nptr
0a36:a5 27        lda ptr
0a38:91 23        sta (string),y
0a3a:c8           iny
0a3b:         
0a3b:b1 23        lda (string),y
0a3d:85 26        sta nptr+1
0a3f:a5 28        lda ptr+1
0a41:91 23        sta (string),y
0a43:         
0a43:             ; (ptr++)=nptr
0a43:             ; next linkage
0a43:a0 00        ldy #0
0a45:a5 25        lda nptr
0a47:91 27        sta (ptr),y
0a49:c8           iny
0a4a:         
0a4a:a5 26        lda nptr+1
0a4c:91 27        sta (ptr),y
0a4e:c8           iny
0a4f:         
0a4f:             ; (ptr++)=scope
0a4f:a5 2d        lda symScope
0a51:91 27        sta (ptr),y
0a53:c8           iny
0a54:         
0a54:a5 2e        lda symScope+1
0a56:91 27        sta (ptr),y
0a58:c8           iny
0a59:         
0a59:             ; (ptr++)=0
0a59:             ; zero out flags when creating
0a59:a9 00        lda #0
0a5b:91 27        sta (ptr),y
0a5d:c8           iny
0a5e:         
0a5e:             ; (++ptr)=non-zero
0a5e:             ; default value (forward decl) not presumed to be zero page
0a5e:c8           iny
0a5f:98           tya
0a60:91 27        sta (ptr),y
0a62:         
0a62:60           rts
0a63:         
0a63:         
0a63:         ; layout of a string entry:
0a63:         ; 00-01:    next (0 if end)
0a63:         ; 02-03:    symbols having this label
0a63:         ; 04-??:    counted string
0a63:         
0a63:         ;
0a63:         ; enter or return existing counted string
0a63:         ; result in ptr
0a63:         strGet:
0a63:             ; nptr = hash(symLabel)
0a63:20 e2 0a     jsr strHash
0a66:bd 00 21     lda hashTable,x
0a69:85 25        sta nptr
0a6b:bd 01 21     lda hashTable+1,x
0a6e:85 26        sta nptr+1
0a70:         
0a70:         :next
0a70:20 07 0b     jsr ptrNext
0a73:f0 13        beq :notFound
0a75:         
0a75:             ; compare string
0a75:             ; string = ptr+4
0a75:a5 27        lda ptr
0a77:18           clc
0a78:69 04        adc #4
0a7a:85 23        sta string
0a7c:a5 28        lda ptr+1
0a7e:69 00        adc #0
0a80:85 24        sta string+1
0a82:20 1e 0b     jsr strEqual
0a85:d0 e9        bne :next
0a87:         
0a87:             ; found/created, result in ptr
0a87:         :done
0a87:60           rts
0a88:         
0a88:         :notFound
0a88:             ; write new entry to head of list
0a88:             ; nptr = hashEntry
0a88:bd 00 21     lda hashTable,x
0a8b:85 25        sta nptr
0a8d:bd 01 21     lda hashTable+1,x
0a90:85 26        sta nptr+1
0a92:         
0a92:             ; hash = symEnd
0a92:             ; ptr = symEnd
0a92:             ; symEnd += 5 + symLength
0a92:a9 05        lda #5
0a94:20 f3 0a     jsr symPush
0a97:         
0a97:a5 27        lda ptr
0a99:9d 00 21     sta hashTable,x
0a9c:a5 28        lda ptr+1
0a9e:9d 01 21     sta hashTable+1,x
0aa1:         
0aa1:a5 2f        lda symLength
0aa3:20 f3 0a     jsr symPush
0aa6:         
0aa6:             ; (ptr++) = nptr
0aa6:bd 00 21     lda hashTable,x
0aa9:85 27        sta ptr
0aab:bd 01 21     lda hashTable+1,x
0aae:85 28        sta ptr+1
0ab0:             
0ab0:a0 00        ldy #0
0ab2:a5 25        lda nptr
0ab4:91 27        sta (ptr),y
0ab6:c8           iny
0ab7:a5 26        lda nptr+1
0ab9:91 27        sta (ptr),y
0abb:c8           iny
0abc:         
0abc:             ; (ptr++) = $0000
0abc:             ; (symbol entries pointer)
0abc:a9 00        lda #0
0abe:91 27        sta (ptr),y
0ac0:c8           iny
0ac1:91 27        sta (ptr),y
0ac3:c8           iny
0ac4:         
0ac4:             ; (ptr) = symLength
0ac4:a5 2f        lda symLength
0ac6:91 27        sta (ptr),y
0ac8:         
0ac8:             ; string = ptr+5
0ac8:a5 27        lda ptr
0aca:18           clc
0acb:69 05        adc #5
0acd:85 23        sta string
0acf:a5 28        lda ptr+1
0ad1:69 00        adc #0
0ad3:85 24        sta string+1
0ad5:         
0ad5:a0 00        ldy #0
0ad7:         :copy
0ad7:c4 2f        cpy symLength
0ad9:f0 ac        beq :done
0adb:b1 31        lda (symLabel),y
0add:91 23        sta (string),y
0adf:c8           iny
0ae0:d0 f5        bne :copy
0ae2:         
0ae2:         ;
0ae2:         ; compute hash value for counted string
0ae2:         strHash:
0ae2:a5 2f        lda symLength
0ae4:a8           tay
0ae5:18           clc
0ae6:         :loop
0ae6:f0 08        beq :done
0ae8:88           dey
0ae9:2a           rol                 ; c << output << c
0aea:51 31        eor (symLabel),y    ; output = output xor byte
0aec:c8           iny
0aed:88           dey
0aee:d0 f6        bne :loop
0af0:         
0af0:             ; truncate to 7 bit
0af0:         :done
0af0:0a           asl
0af1:aa           tax                 ; result in index form
0af2:60           rts
0af3:         
0af3:         ;
0af3:         ; push symEnd by A bytes
0af3:         ; ptr=symEnd before increment
0af3:         symPush:
0af3:85 22        sta scratch
0af5:a5 41        lda symEnd
0af7:85 27        sta ptr
0af9:18           clc
0afa:65 22        adc scratch
0afc:85 41        sta symEnd
0afe:a5 42        lda symEnd+1
0b00:85 28        sta ptr+1
0b02:69 00        adc #0
0b04:85 42        sta symEnd+1
0b06:60           rts
0b07:         
0b07:         ;
0b07:         ; ptr=nptr, nptr=(ptr)
0b07:         ; Z if nptrH=0
0b07:         ; Y=2 otherwise
0b07:         ptrNext:
0b07:a5 26        lda nptr+1
0b09:f0 12        beq :out            ; nptrH=0
0b0b:85 28        sta ptr+1
0b0d:a5 25        lda nptr
0b0f:85 27        sta ptr
0b11:a0 00        ldy #0
0b13:b1 27        lda (ptr),y
0b15:85 25        sta nptr
0b17:c8           iny
0b18:b1 27        lda (ptr),y         ; Z=0
0b1a:85 26        sta nptr+1
0b1c:c8           iny
0b1d:         :out
0b1d:60           rts
0b1e:         
0b1e:         ;
0b1e:         ; compare counted string at (string) against symLength/symLabel
0b1e:         ; for equality, Z=1 if so
0b1e:         strEqual:
0b1e:a0 00        ldy #0
0b20:b1 23        lda (string),y
0b22:c5 2f        cmp symLength
0b24:d0 0d        bne :out
0b26:         :loop
0b26:c4 2f        cpy symLength
0b28:f0 09        beq :out
0b2a:b1 31        lda (symLabel),y
0b2c:c8           iny
0b2d:d1 23        cmp (string),y
0b2f:d0 02        bne :out
0b31:f0 f3        beq :loop
0b33:         :out
0b33:60           rts
0b34:         
0b34:             .in 'eval.asm'
0b34:             .in 'zp.asm'
0b34:             .fi ; zpAsm
0b34:         
0b34:         
0b34:         esInit  = 0
0b34:         esOp    = 1
0b34:         
0b34:         
0b34:         eDone:
0b34:             ; err if not in esOp state
0b34:18           clc
0b35:a5 3c        lda eState
0b37:f0 01        beq :error
0b39:60           rts
0b3a:         :error
0b3a:38           sec
0b3b:60           rts
0b3c:         
0b3c:         ;
0b3c:         ; normalize petscii in A into lineBuf,x
0b3c:         ePet:
0b3c:85 22        sta scratch
0b3e:29 e0        and #$e0
0b40:c9 60        cmp #$60        ; %011xxxxx -> %110xxxxx
0b42:d0 08        bne :nopet
0b44:a5 22        lda scratch
0b46:49 a0        eor #$a0
0b48:9d 00 20     sta lineBuf,x
0b4b:60           rts
0b4c:         :nopet
0b4c:a5 22        lda scratch
0b4e:60           rts
0b4f:         
0b4f:         ;
0b4f:         ; evaluate expression at lineBuf,x
0b4f:         eEval:
0b4f:64 3c        stz eState
0b51:64 3b        stz eOp
0b53:64 35        stz arg
0b55:64 36        stz arg+1
0b57:20 d5 0d     jsr ePush
0b5a:         
0b5a:         :loop
0b5a:bd 00 20     lda lineBuf,x
0b5d:f0 d5        beq eDone       ; eof
0b5f:c9 2c        cmp #',
0b61:f0 d1        beq eDone
0b63:c9 3b        cmp #';
0b65:f0 cd        beq eDone
0b67:c9 29        cmp #')
0b69:f0 c9        beq eDone
0b6b:         
0b6b:a4 3c        ldy eState
0b6d:d0 26        bne :op
0b6f:         
0b6f:         :init
0b6f:20 09 0e     jsr eIsDec
0b72:b0 4f        bcs :dec
0b74:20 3a 0e     jsr eIsAlpha
0b77:b0 6b        bcs :tosym
0b79:c9 3a        cmp #':
0b7b:f0 67        beq :tosym
0b7d:c9 25        cmp #'%
0b7f:f0 58        beq :bin
0b81:c9 24        cmp #'$
0b83:f0 49        beq :hex
0b85:c9 28        cmp #'(
0b87:f0 65        beq :sub
0b89:c9 2a        cmp #'*
0b8b:f0 71        beq :pc
0b8d:c9 27        cmp #''
0b8f:f0 7a        beq :char
0b91:             
0b91:a0 80        ldy #$80        ; indicate unary
0b93:84 3b        sty eOp
0b95:             ; fall thru
0b95:         
0b95:         :op
0b95:e8           inx
0b96:         
0b96:29 7f        and #$7f        ; normalize petscii whitespace (shift+space)
0b98:c9 21        cmp #33         ; whitespace?
0b9a:90 be        bcc :loop
0b9c:         
0b9c:05 3b        ora eOp         ; push unary or binary op
0b9e:85 3b        sta eOp
0ba0:         
0ba0:c9 3e        cmp #'>
0ba2:f0 0a        beq :optwo
0ba4:             
0ba4:c9 3c        cmp #'<
0ba6:f0 06        beq :optwo
0ba8:         
0ba8:c9 21        cmp #'!
0baa:f0 02        beq :optwo
0bac:             
0bac:80 0e        bra :opone
0bae:         
0bae:         :optwo
0bae:bd 00 20     lda lineBuf,x
0bb1:c9 3d        cmp #'=
0bb3:d0 07        bne :opone 
0bb5:         
0bb5:e8           inx             ; this is >=, <=, or !=
0bb6:a9 40        lda #$40        ; add 64 to indicate = suffix
0bb8:05 3b        ora eOp
0bba:85 3b        sta eOp
0bbc:         
0bbc:         :opone
0bbc:20 d5 0d     jsr ePush
0bbf:64 3c        stz eState
0bc1:80 97        bra :loop
0bc3:         
0bc3:         :dec
0bc3:20 09 0e     jsr eIsDec
0bc6:90 57        bcc :term       ; not a decimal digit?
0bc8:20 74 0d     jsr eDec
0bcb:e8           inx
0bcc:d0 f5        bne :dec
0bce:         
0bce:         :hex
0bce:e8           inx
0bcf:20 1f 0e     jsr eIsHex
0bd2:90 4b        bcc :term       ; not a hex digit?
0bd4:20 a7 0d     jsr eHex
0bd7:80 f5        bra :hex
0bd9:             
0bd9:         :bin
0bd9:e8           inx
0bda:20 30 0e     jsr eIsBin
0bdd:d0 40        bne :term       ; not a binary digit?
0bdf:20 c9 0d     jsr eBin
0be2:80 f5        bra :bin
0be4:         
0be4:         :tosym
0be4:86 3d        stx labelPtr    ; note where it starts
0be6:             
0be6:         :sym
0be6:20 52 0e     jsr eIsSym
0be9:d0 2b        bne :termsym
0beb:e8           inx
0bec:80 f8        bra :sym
0bee:         
0bee:         :sub
0bee:e8           inx             ; skip '('
0bef:20 4f 0b     jsr eEval       ; evaluate subexpression
0bf2:b0 39        bcs :out
0bf4:bd 00 20     lda lineBuf,x
0bf7:c9 29        cmp #')
0bf9:d0 24        bne :term
0bfb:e8           inx             ; consume ')'
0bfc:80 21        bra :term
0bfe:         
0bfe:         :pc
0bfe:e8           inx             ; skip '*'
0bff:ad f1 1c     lda pc          ; arg=pc
0c02:85 35        sta arg
0c04:ad f2 1c     lda pc+1
0c07:85 36        sta arg+1
0c09:80 14        bra :term
0c0b:         
0c0b:         :char
0c0b:e8           inx             ; skip '
0c0c:bd 00 20     lda lineBuf,x   ; arg=literal character
0c0f:e8           inx             ; consume
0c10:85 35        sta arg
0c12:64 36        stz arg+1
0c14:80 09        bra :term
0c16:         
0c16:         :termsym
0c16:86 29        stx labelEnd
0c18:20 62 0e     jsr eResolveSym ; resolve label value into arg
0c1b:b0 10        bcs :out
0c1d:a6 29        ldx labelEnd
0c1f:             ; fall thru
0c1f:         
0c1f:         :term
0c1f:20 2e 0c     jsr eExec       ; pop and execute what we have so far
0c22:b0 09        bcs :out
0c24:a9 01        lda #esOp       ; now in op state
0c26:85 3c        sta eState
0c28:64 3b        stz eOp         ; clear op, and not unary
0c2a:4c 5a 0b     jmp :loop
0c2d:         
0c2d:         :out    
0c2d:60           rts
0c2e:         
0c2e:         ;
0c2e:         ; exec term
0c2e:         eExec:
0c2e:20 38 0c     jsr eExecOne
0c31:b0 04        bcs :out
0c33:24 3b        bit eOp
0c35:30 f7        bmi eExec
0c37:         :out
0c37:60           rts
0c38:         
0c38:         eExecOne:
0c38:20 f2 0d     jsr ePop
0c3b:a5 3b        lda eOp
0c3d:f0 63        beq :assign
0c3f:c9 2b        cmp #'+
0c41:f0 61        beq :add
0c43:c9 2d        cmp #'-
0c45:f0 6c        beq :sub
0c47:c9 ad        cmp #$80+'- ; unary -
0c49:f0 68        beq :sub
0c4b:c9 26        cmp #'&
0c4d:f0 73        beq :and
0c4f:c9 5e        cmp #'^
0c51:f0 2e        beq :xorb
0c53:c9 2e        cmp #'.
0c55:f0 79        beq :or
0c57:c9 a1        cmp #$80+'! ; unary '!'
0c59:f0 29        beq :notb
0c5b:c9 bc        cmp #$80+'< ; unary '<'
0c5d:f0 28        beq :lob
0c5f:c9 be        cmp #$80+'> ; unary '>'
0c61:f0 27        beq :hib
0c63:c9 3d        cmp #'=
0c65:f0 26        beq :eqb
0c67:c9 3e        cmp #'>
0c69:f0 25        beq :gtb
0c6b:c9 3c        cmp #'<
0c6d:f0 24        beq :ltb
0c6f:c9 7e        cmp #$40+'> ; >=
0c71:f0 23        beq :geb
0c73:c9 7c        cmp #$40+'< ; <=
0c75:f0 22        beq :leb
0c77:c9 61        cmp #$40+'! ; !=
0c79:f0 21        beq :neb
0c7b:c9 25        cmp #'%
0c7d:f0 20        beq :alignb
0c7f:38           sec
0c80:60           rts
0c81:         
0c81:         :xorb
0c81:4c de 0c     jmp :xor
0c84:         
0c84:         :notb
0c84:4c ec 0c     jmp :not
0c87:         
0c87:         :lob
0c87:4c fe 0c     jmp :lo
0c8a:         
0c8a:         :hib
0c8a:4c fa 0c     jmp :hi
0c8d:         
0c8d:         :eqb
0c8d:4c 02 0d     jmp :eq
0c90:         
0c90:         :gtb
0c90:4c 10 0d     jmp :gt
0c93:         
0c93:         :ltb
0c93:4c 1e 0d     jmp :lt
0c96:         
0c96:         :geb
0c96:4c 2c 0d     jmp :ge
0c99:         
0c99:         :leb
0c99:4c 3a 0d     jmp :le
0c9c:         
0c9c:         :neb
0c9c:4c 48 0d     jmp :ne
0c9f:         
0c9f:         :alignb
0c9f:4c 62 0d     jmp :align
0ca2:         
0ca2:         ;
0ca2:         ; arg=arg
0ca2:         :assign
0ca2:18           clc
0ca3:60           rts
0ca4:         
0ca4:         ;
0ca4:         ; arg+=term
0ca4:         :add
0ca4:a5 35        lda arg
0ca6:18           clc
0ca7:65 37        adc term
0ca9:85 35        sta arg
0cab:a5 36        lda arg+1
0cad:65 38        adc term+1
0caf:85 36        sta arg+1
0cb1:18           clc
0cb2:60           rts
0cb3:         
0cb3:         ;
0cb3:         ; arg=term-arg
0cb3:         :sub
0cb3:a5 37        lda term
0cb5:38           sec
0cb6:e5 35        sbc arg
0cb8:85 35        sta arg
0cba:a5 38        lda term+1
0cbc:e5 36        sbc arg+1
0cbe:85 36        sta arg+1
0cc0:18           clc
0cc1:60           rts
0cc2:         
0cc2:         ;
0cc2:         ; arg&=term
0cc2:         :and
0cc2:a5 35        lda arg
0cc4:25 37        and term
0cc6:85 35        sta arg
0cc8:a5 36        lda arg+1
0cca:25 38        and term+1
0ccc:85 36        sta arg+1
0cce:18           clc
0ccf:60           rts
0cd0:         
0cd0:         ;
0cd0:         ; arg.=term
0cd0:         :or
0cd0:a5 35        lda arg
0cd2:05 37        ora term
0cd4:85 35        sta arg
0cd6:a5 36        lda arg+1
0cd8:05 38        ora term+1
0cda:85 36        sta arg+1
0cdc:18           clc
0cdd:60           rts
0cde:         
0cde:         ;
0cde:         ; arg^=term
0cde:         :xor
0cde:a5 35        lda arg
0ce0:45 37        eor term
0ce2:85 35        sta arg
0ce4:a5 36        lda arg+1
0ce6:45 38        eor term+1
0ce8:85 36        sta arg+1
0cea:18           clc
0ceb:60           rts
0cec:         
0cec:         ;
0cec:         ; arg=!arg
0cec:         :not
0cec:a5 35        lda arg
0cee:49 ff        eor #$ff
0cf0:85 35        sta arg
0cf2:a5 36        lda arg+1
0cf4:49 ff        eor #$ff
0cf6:85 36        sta arg+1
0cf8:18           clc
0cf9:60           rts
0cfa:         
0cfa:         ;
0cfa:         ; arg=>arg
0cfa:         :hi
0cfa:a5 36        lda arg+1
0cfc:85 35        sta arg
0cfe:             ; fall thru
0cfe:         
0cfe:         ;
0cfe:         ; arg=<arg
0cfe:         :lo
0cfe:64 36        stz arg+1
0d00:18           clc
0d01:60           rts
0d02:         
0d02:         ;
0d02:         ; arg=term?
0d02:         :eq
0d02:a5 35        lda arg
0d04:c5 37        cmp term
0d06:d0 54        bne :false
0d08:a5 36        lda arg+1
0d0a:c5 38        cmp term+1
0d0c:d0 4e        bne :false
0d0e:80 44        bra :true
0d10:         
0d10:         ;
0d10:         ; term>arg?
0d10:         :gt
0d10:a5 36        lda arg+1
0d12:c5 38        cmp term+1
0d14:90 3e        bcc :true
0d16:a5 35        lda arg
0d18:c5 37        cmp term
0d1a:90 38        bcc :true
0d1c:80 3e        bra :false
0d1e:         
0d1e:         ;
0d1e:         ; term<arg?
0d1e:         :lt
0d1e:a5 38        lda term+1
0d20:c5 36        cmp arg+1
0d22:90 30        bcc :true
0d24:a5 37        lda term
0d26:c5 35        cmp arg
0d28:90 2a        bcc :true
0d2a:80 30        bra :false
0d2c:         
0d2c:         ;
0d2c:         ; term>=arg?
0d2c:         :ge
0d2c:a5 38        lda term+1
0d2e:c5 36        cmp arg+1
0d30:90 2a        bcc :false
0d32:a5 37        lda term
0d34:c5 35        cmp arg
0d36:90 24        bcc :false
0d38:80 1a        bra :true
0d3a:         
0d3a:         ; term<=arg?
0d3a:         :le
0d3a:a5 36        lda arg+1
0d3c:c5 38        cmp term+1
0d3e:90 1c        bcc :false
0d40:a5 35        lda arg
0d42:c5 37        cmp term
0d44:90 16        bcc :false
0d46:80 0c        bra :true
0d48:         
0d48:         ; term!=arg?
0d48:         :ne
0d48:a5 36        lda arg+1
0d4a:c5 38        cmp term+1
0d4c:d0 06        bne :true
0d4e:a5 35        lda arg
0d50:c5 37        cmp term
0d52:f0 08        beq :false
0d54:         
0d54:         :true
0d54:a9 ff        lda #$ff
0d56:85 35        sta arg
0d58:85 36        sta arg+1
0d5a:18           clc
0d5b:60           rts
0d5c:         
0d5c:         :false
0d5c:64 35        stz arg
0d5e:64 36        stz arg+1
0d60:18           clc
0d61:60           rts
0d62:         
0d62:         ; arg=term%arg
0d62:         :align              ; limited to $100 max
0d62:c6 35        dec arg
0d64:a5 35        lda arg
0d66:25 37        and term
0d68:45 35        eor arg
0d6a:1a           inc
0d6b:25 35        and arg
0d6d:85 35        sta arg
0d6f:64 36        stz arg+1
0d71:4c a4 0c     jmp :add
0d74:         
0d74:         ;
0d74:         ; add decimal digit in lineBuf,x to arg
0d74:         eDec:
0d74:a5 35        lda arg         ; scratch=arg*8
0d76:0a           asl
0d77:85 22        sta scratch
0d79:a5 36        lda arg+1
0d7b:2a           rol
0d7c:85 23        sta scratch+1
0d7e:         
0d7e:06 22        asl scratch
0d80:26 23        rol scratch+1
0d82:06 22        asl scratch
0d84:26 23        rol scratch+1
0d86:         
0d86:06 35        asl arg         ; arg=arg*2
0d88:26 36        rol arg+1
0d8a:         
0d8a:a5 35        lda arg         ; arg=arg+scratch
0d8c:18           clc
0d8d:65 22        adc scratch
0d8f:85 35        sta arg
0d91:a5 36        lda arg+1
0d93:65 23        adc scratch+1
0d95:85 36        sta arg+1
0d97:         
0d97:bd 00 20     lda lineBuf,x
0d9a:38           sec
0d9b:e9 30        sbc #'0
0d9d:18           clc
0d9e:65 35        adc arg
0da0:85 35        sta arg
0da2:90 02        bcc :out
0da4:e6 36        inc arg+1
0da6:         :out
0da6:60           rts
0da7:         
0da7:         ;
0da7:         ; add hex digit in lineBuf,x to arg
0da7:         eHex:
0da7:06 35        asl arg
0da9:26 36        rol arg+1
0dab:06 35        asl arg
0dad:26 36        rol arg+1
0daf:06 35        asl arg
0db1:26 36        rol arg+1
0db3:06 35        asl arg
0db5:26 36        rol arg+1
0db7:         
0db7:bd 00 20     lda lineBuf,x
0dba:38           sec
0dbb:e9 3a        sbc #'9+1
0dbd:90 03        bcc :digit
0dbf:e9 07        sbc #7
0dc1:18           clc
0dc2:         :digit
0dc2:69 0a        adc #10
0dc4:         
0dc4:05 35        ora arg
0dc6:85 35        sta arg
0dc8:60           rts
0dc9:         
0dc9:         ;
0dc9:         ; add binary digit in lineBuf,x to arg
0dc9:         eBin:
0dc9:06 35        asl arg
0dcb:26 36        rol arg+1
0dcd:38           sec
0dce:e9 30        sbc #'0
0dd0:05 35        ora arg
0dd2:85 35        sta arg
0dd4:60           rts
0dd5:         
0dd5:         ;
0dd5:         ; push arg,op,state
0dd5:         ePush:
0dd5:a4 43        ldy ePtr
0dd7:         
0dd7:a5 3b        lda eOp
0dd9:99 00 1f     sta eStack,y
0ddc:88           dey
0ddd:         
0ddd:a5 36        lda arg+1
0ddf:99 00 1f     sta eStack,y
0de2:88           dey
0de3:         
0de3:a5 35        lda arg
0de5:99 00 1f     sta eStack,y
0de8:88           dey
0de9:         
0de9:84 43        sty ePtr
0deb:         
0deb:64 3b        stz eOp
0ded:64 35        stz arg
0def:64 36        stz arg+1
0df1:60           rts
0df2:         
0df2:         ;
0df2:         ; pop term,op,state
0df2:         ePop:
0df2:a4 43        ldy ePtr
0df4:         
0df4:c8           iny
0df5:b9 00 1f     lda eStack,y
0df8:85 37        sta term
0dfa:         
0dfa:c8           iny
0dfb:b9 00 1f     lda eStack,y
0dfe:85 38        sta term+1
0e00:         
0e00:c8           iny
0e01:b9 00 1f     lda eStack,y
0e04:85 3b        sta eOp
0e06:         
0e06:84 43        sty ePtr
0e08:60           rts
0e09:         
0e09:         ;
0e09:         ; test if lineBuf,x is decimal digit
0e09:         ; C=1 if so
0e09:         eIsDec:
0e09:bd 00 20     lda lineBuf,x
0e0c:c9 3a        cmp #'9+1
0e0e:b0 03        bcs eIsNot
0e10:         
0e10:c9 30        cmp #'0
0e12:60           rts
0e13:         
0e13:         eIsNot:
0e13:18           clc
0e14:60           rts
0e15:         
0e15:         ;
0e15:         ; test if lineBuf,x is octal digit
0e15:         ; C=1 if so, also returns char in A
0e15:         eIsOct:
0e15:bd 00 20     lda lineBuf,x
0e18:c9 38        cmp #'7+1
0e1a:b0 f7        bcs eIsNot
0e1c:         
0e1c:c9 30        cmp #'0
0e1e:60           rts
0e1f:         
0e1f:         ;
0e1f:         ; test if lineBuf,x is hex digit
0e1f:         ; C=1 if so
0e1f:         ; side effect: uppercase normalized
0e1f:         eIsHex:
0e1f:20 09 0e     jsr eIsDec
0e22:b0 0b        bcs :out
0e24:20 3c 0b     jsr ePet
0e27:29 7f        and #$7f
0e29:         
0e29:c9 47        cmp #'f+1
0e2b:b0 e6        bcs eIsNot
0e2d:         
0e2d:c9 41        cmp #'a
0e2f:         :out
0e2f:60           rts
0e30:         
0e30:         ;
0e30:         ; test if lineBuf,x is binary digit
0e30:         ; Z=1 if so
0e30:         eIsBin:
0e30:bd 00 20     lda lineBuf,x
0e33:c9 31        cmp #'1
0e35:f0 02        beq :out
0e37:c9 30        cmp #'0
0e39:         :out
0e39:60           rts
0e3a:         
0e3a:         ;
0e3a:         ; test if lineBuf,X is alpha
0e3a:         ; C=1 if so
0e3a:         eIsAlpha:
0e3a:bd 00 20     lda lineBuf,x
0e3d:20 3c 0b     jsr ePet
0e40:         
0e40:c9 db        cmp #'z+128+1   ; 'Z'
0e42:b0 cf        bcs eIsNot      ; > 'Z'
0e44:         
0e44:c9 41        cmp #'a
0e46:90 09        bcc :out        ; < 'a'
0e48:         
0e48:c9 c1        cmp #'a+128     ; 'A'
0e4a:b0 05        bcs :out        ; >= 'A' and <= 'Z'
0e4c:         
0e4c:c9 5b        cmp #'z+1
0e4e:b0 c3        bcs eIsNot      ; > 'z'
0e50:         
0e50:38           sec
0e51:         :out
0e51:60           rts
0e52:         
0e52:         ;
0e52:         ; test if lineBuf,x is a valid symbol character
0e52:         ; Z=1 if so
0e52:         eIsSym:
0e52:20 3a 0e     jsr eIsAlpha
0e55:b0 08        bcs :yes
0e57:20 09 0e     jsr eIsDec
0e5a:b0 03        bcs :yes
0e5c:c9 3a        cmp #':
0e5e:60           rts
0e5f:         :yes
0e5f:89 00        bit #0          ; set zero
0e61:60           rts
0e62:         
0e62:         ;
0e62:         ; resolve label from lineBuf into arg
0e62:         eResolveSym:
0e62:a5 2d        lda symScope    ; note our current scope
0e64:8d fc 1c     sta tScope
0e67:a5 2e        lda symScope+1
0e69:8d fd 1c     sta tScope+1
0e6c:         
0e6c:a4 3d        ldy labelPtr    ; start of label sequence
0e6e:b9 00 20     lda lineBuf,y
0e71:c9 3a        cmp #':
0e73:f0 04        beq :loop
0e75:         
0e75:64 2d        stz symScope    ; global scope
0e77:64 2e        stz symScope+1
0e79:         
0e79:         :loop
0e79:20 b4 0e     jsr :next
0e7c:a5 2f        lda symLength
0e7e:f0 0f        beq :skip       ; empty label in sequence means do not adjust scope
0e80:         
0e80:84 2b        sty emitY
0e82:20 02 0a     jsr symGet
0e85:a4 2b        ldy emitY
0e87:         
0e87:a5 27        lda ptr
0e89:85 2d        sta symScope
0e8b:a5 28        lda ptr+1
0e8d:85 2e        sta symScope+1
0e8f:         
0e8f:         :skip
0e8f:c4 29        cpy labelEnd
0e91:d0 e6        bne :loop
0e93:         
0e93:         :done
0e93:18           clc
0e94:a0 04        ldy #4
0e96:b1 27        lda (ptr),y     ; no forward reference in pass >0
0e98:d0 05        bne :fine
0e9a:a5 40        lda pass
0e9c:f0 01        beq :fine
0e9e:38           sec             ; set error
0e9f:         
0e9f:         :fine
0e9f:c8           iny             ; symbol value in arg
0ea0:b1 27        lda (ptr),y
0ea2:85 35        sta arg
0ea4:c8           iny
0ea5:b1 27        lda (ptr),y
0ea7:85 36        sta arg+1
0ea9:         
0ea9:ad fc 1c     lda tScope      ; put scope back
0eac:85 2d        sta symScope
0eae:ad fd 1c     lda tScope+1
0eb1:85 2e        sta symScope+1
0eb3:         
0eb3:60           rts
0eb4:         
0eb4:         :next
0eb4:98           tya             ; point symLabel at lineBuf+y
0eb5:18           clc
0eb6:69 00        adc #<lineBuf
0eb8:85 31        sta symLabel
0eba:a9 00        lda #0
0ebc:69 20        adc #>lineBuf
0ebe:85 32        sta symLabel+1
0ec0:64 2f        stz symLength   ; reset length=0
0ec2:         
0ec2:         :search
0ec2:b9 00 20     lda lineBuf,y
0ec5:c8           iny
0ec6:c9 3a        cmp #':
0ec8:f0 06        beq :out        ; colon terminate at scope seperator
0eca:e6 2f        inc symLength
0ecc:c4 29        cpy labelEnd
0ece:d0 f2        bne :search
0ed0:         :out
0ed0:60           rts
0ed1:         
0ed1:             .in 'line.asm'
0ed1:             .in 'zp.asm'
0ed1:             .fi ; zpAsm
0ed1:         
0ed1:             .in 'mode.asm'
0ed1:             .fi ; modeAsm
0ed1:         
0ed1:         
0ed1:         
0ed1:         ;
0ed1:         ; assembles lineBuf
0ed1:         lineAsm:
0ed1:ba           tsx
0ed2:8e ee 1c     stx lineSP
0ed5:64 35        stz arg
0ed7:64 36        stz arg+1
0ed9:a2 00        ldx #0
0edb:         
0edb:         :start
0edb:bd 00 20     lda lineBuf,x
0ede:20 3c 0b     jsr ePet
0ee1:20 52 0e     jsr eIsSym
0ee4:d0 03        bne :label
0ee6:e8           inx
0ee7:d0 f2        bne :start
0ee9:         :label
0ee9:64 27        stz ptr         ; assume no label yet
0eeb:64 28        stz ptr+1
0eed:         
0eed:86 29        stx labelEnd
0eef:e0 00        cpx #0          ; no label
0ef1:f0 07        beq :post
0ef3:         
0ef3:24 44        bit lineIfs     ; test if we are if'd out
0ef5:30 03        bmi :post
0ef7:         
0ef7:20 d5 10     jsr linePinLabel
0efa:         
0efa:         :post
0efa:20 c7 12     jsr lineNextTokenExit
0efd:         
0efd:c9 3d        cmp #'=
0eff:d0 1e        bne :op
0f01:         
0f01:24 44        bit lineIfs
0f03:30 5f        bmi :opdone
0f05:         
0f05:e8           inx             ; skip '='
0f06:a5 27        lda ptr
0f08:85 39        sta assign      ; assign=ptr
0f0a:a5 28        lda ptr+1
0f0c:f0 23        beq :assignError
0f0e:85 3a        sta assign+1
0f10:         
0f10:20 f1 12     jsr lineEval    ; eval rhs
0f13:         
0f13:a0 05        ldy #5          ; store evaluated result
0f15:a5 35        lda arg
0f17:91 39        sta (assign),y
0f19:c8           iny
0f1a:a5 36        lda arg+1
0f1c:91 39        sta (assign),y
0f1e:60           rts
0f1f:         
0f1f:         :op
0f1f:bd 00 20     lda lineBuf,x
0f22:c9 2a        cmp #'*
0f24:f0 15        beq :star
0f26:c9 2e        cmp #'.
0f28:f0 3b        beq :dot
0f2a:         
0f2a:24 44        bit lineIfs
0f2c:30 36        bmi :opdone     ; if'd out
0f2e:         
0f2e:4c 3b 11     jmp lineIsn
0f31:         
0f31:         :assignError
0f31:a9 0a        lda #errors:assign
0f33:85 46        sta error
0f35:60           rts
0f36:         
0f36:         :backwardError
0f36:a9 06        lda #errors:backward
0f38:85 46        sta error
0f3a:60           rts
0f3b:         
0f3b:         :star
0f3b:e8           inx             ; skip '*'
0f3c:20 c7 12     jsr lineNextTokenExit
0f3f:c9 3d        cmp #'=
0f41:d0 21        bne :opdone
0f43:e8           inx             ; consume '='
0f44:e6 40        inc pass        ; cannot be forward reference
0f46:20 f1 12     jsr lineEval
0f49:c6 40        dec pass
0f4b:         
0f4b:         :starloop
0f4b:a5 36        lda arg+1
0f4d:cd f2 1c     cmp pc+1
0f50:90 e4        bcc :backwardError
0f52:d0 09        bne :stardo
0f54:a5 35        lda arg
0f56:cd f1 1c     cmp pc
0f59:90 db        bcc :backwardError
0f5b:f0 07        beq :stardone
0f5d:         :stardo
0f5d:a9 00        lda #0
0f5f:20 25 11     jsr lineEmit    ; emit zeros until desired pc
0f62:80 e7        bra :starloop
0f64:         
0f64:         :stardone
0f64:         :opdone
0f64:60           rts
0f65:         
0f65:         :dot
0f65:e8           inx             ; skip '.'
0f66:bd 01 20     lda lineBuf+1,x
0f69:a8           tay             ; second char in Y
0f6a:bd 00 20     lda lineBuf,x   ; first char in A
0f6d:e8           inx
0f6e:e8           inx             ; skip the two (if not present, we will err anyway)
0f6f:         
0f6f:c9 45        cmp #'e
0f71:f0 19        beq :E
0f73:c9 46        cmp #'f
0f75:f0 1f        beq :F
0f77:c9 49        cmp #'i
0f79:f0 27        beq :I
0f7b:         
0f7b:24 44        bit lineIfs
0f7d:30 e5        bmi :opdone     ; if'd out
0f7f:         
0f7f:c9 4f        cmp #'o
0f81:f0 19        beq :O
0f83:c9 44        cmp #'d
0f85:f0 2d        beq :D
0f87:             ; fall thru
0f87:         
0f87:         :dotOpError
0f87:a9 0c        lda #errors:dotOp
0f89:85 46        sta error
0f8b:60           rts
0f8c:         
0f8c:         :E
0f8c:c0 49        cpy #'i
0f8e:f0 5b        beq :EI
0f90:c0 4c        cpy #'l
0f92:f0 43        beq :EL
0f94:80 f1        bra :dotOpError
0f96:         
0f96:         :F
0f96:c0 49        cpy #'i
0f98:f0 73        beq :FI
0f9a:80 eb        bra :dotOpError
0f9c:         
0f9c:         :O
0f9c:c0 52        cpy #'r
0f9e:f0 22        beq :ORb
0fa0:80 e5        bra :dotOpError
0fa2:         
0fa2:         :I
0fa2:c0 46        cpy #'f
0fa4:f0 1f        beq :IFb
0fa6:             
0fa6:24 44        bit lineIfs
0fa8:30 ba        bmi :opdone     ; if'd out
0faa:             
0faa:c0 4e        cpy #'n
0fac:f0 1a        beq :INb
0fae:c0 42        cpy #'b
0fb0:f0 19        beq :IBb
0fb2:80 d3        bra :dotOpError
0fb4:           
0fb4:         :D
0fb4:c0 42        cpy #'b
0fb6:f0 16        beq :DBb
0fb8:c0 57        cpy #'w
0fba:f0 15        beq :DWb
0fbc:c0 46        cpy #'f
0fbe:f0 14        beq :DFb
0fc0:80 c5        bra :dotOpError
0fc2:         
0fc2:         :ORb
0fc2:4c 95 10     jmp :OR
0fc5:         
0fc5:         :IFb
0fc5:4c b0 10     jmp :IF
0fc8:         
0fc8:         :INb
0fc8:4c a6 10     jmp :IN
0fcb:             
0fcb:         :IBb
0fcb:4c ac 10     jmp :IB
0fce:             
0fce:         :DBb
0fce:4c 14 10     jmp :DB
0fd1:             
0fd1:         :DWb
0fd1:4c 3e 10     jmp :DW
0fd4:         
0fd4:         :DFb
0fd4:4c 57 10     jmp :DF
0fd7:         
0fd7:         :EL
0fd7:24 45        bit lineIfd     ; have we chosen our destiny
0fd9:10 07        bpl :else
0fdb:a9 80        lda #$80        ; prior destiny has already been set
0fdd:04 44        tsb lineIfs
0fdf:4c d9 12     jmp lineAssertEnd
0fe2:         
0fe2:         :else
0fe2:a5 44        lda lineIfs     ; flip top if bit
0fe4:49 80        eor #$80
0fe6:85 44        sta lineIfs
0fe8:4c d9 12     jmp lineAssertEnd
0feb:         
0feb:         :EI
0feb:20 e5 12     jsr lineAssertToken
0fee:         
0fee:24 45        bit lineIfd     ; have we chosen our destiny
0ff0:10 05        bpl :elseif
0ff2:a9 80        lda #$80        ; stay false
0ff4:04 44        tsb lineIfs     ; prior destiny has already been set
0ff6:60           rts
0ff7:         
0ff7:         :elseif
0ff7:20 f1 12     jsr lineEval
0ffa:20 18 11     jsr lineTruth
0ffd:06 44        asl lineIfs
0fff:a5 36        lda arg+1       ; top of ifs stack becomes condition
1001:29 80        and #$80
1003:04 45        tsb lineIfd     ; destiny set
1005:49 80        eor #$80
1007:0a           asl
1008:66 44        ror lineIfs
100a:4c d9 12     jmp lineAssertEnd
100d:         
100d:         :FI
100d:06 44        asl lineIfs     ; pop if stack
100f:06 45        asl lineIfd     ; pop destiny stack
1011:4c d9 12     jmp lineAssertEnd
1014:         
1014:         :DB
1014:64 35        stz arg
1016:20 c7 12     jsr lineNextTokenExit
1019:c9 27        cmp #''
101b:f0 11        beq :string
101d:c9 2c        cmp #',
101f:f0 0a        beq :DBcomma
1021:         
1021:20 f1 12     jsr lineEval
1024:a5 35        lda arg         ; send it
1026:20 25 11     jsr lineEmit
1029:         
1029:80 e9        bra :DB
102b:         
102b:         :DBcomma
102b:e8           inx             ; consume ',' ready for next
102c:80 e6        bra :DB
102e:         
102e:         :string
102e:e8           inx
102f:bd 00 20     lda lineBuf,x
1032:f0 09        beq :stringEOF
1034:c9 27        cmp #''
1036:f0 f3        beq :DBcomma
1038:         
1038:20 25 11     jsr lineEmit    ; send it
103b:80 f1        bra :string
103d:         :stringEOF
103d:60           rts
103e:         
103e:         :DW
103e:20 c7 12     jsr lineNextTokenExit
1041:c9 2c        cmp #',
1043:f0 0f        beq :DWcomma
1045:         
1045:20 f1 12     jsr lineEval
1048:         
1048:a5 35        lda arg         ; send it
104a:20 25 11     jsr lineEmit
104d:a5 36        lda arg+1
104f:20 25 11     jsr lineEmit
1052:         
1052:80 ea        bra :DW
1054:         
1054:         :DWcomma
1054:e8           inx             ; consume ',' ready for next word
1055:80 e7        bra :DW
1057:         
1057:         :DF
1057:20 c7 12     jsr lineNextTokenExit
105a:         
105a:86 2a        stx emitX
105c:         :DFscan
105c:20 aa 12     jsr lineEnd
105f:f0 07        beq :DFscanned
1061:c9 2c        cmp #',
1063:f0 03        beq :DFscanned
1065:e8           inx
1066:d0 f4        bne :DFscan
1068:         
1068:         :DFscanned
1068:86 22        stx scratch
106a:8a           txa
106b:38           sec
106c:e5 2a        sbc emitX       ; A: length
106e:a6 2a        ldx emitX       ; X/Y: string
1070:a0 20        ldy #>lineBuf
1072:20 09 fe     jsr VAL1
1075:a2 e0        ldx #<fpack
1077:a0 1c        ldy #>fpack
1079:20 66 fe     jsr MOVMF       ; pack FACC->constant
107c:         
107c:a6 22        ldx scratch     ; get X back
107e:a0 00        ldy #0
1080:         
1080:         :DFemit
1080:b9 e0 1c     lda fpack,y     ; write 5 byte packed output
1083:20 25 11     jsr lineEmit
1086:c8           iny
1087:c0 05        cpy #5
1089:d0 f5        bne :DFemit
108b:         
108b:         :DFnext
108b:bd 00 20     lda lineBuf,x
108e:c9 2c        cmp #',
1090:d0 c5        bne :DF
1092:e8           inx             ; consume ,
1093:80 c2        bra :DF
1095:         
1095:         :OR
1095:20 e5 12     jsr lineAssertToken
1098:         
1098:20 f1 12     jsr lineEval
109b:         
109b:a5 35        lda arg
109d:8d f1 1c     sta pc
10a0:a5 36        lda arg+1
10a2:8d f2 1c     sta pc+1
10a5:60           rts
10a6:         
10a6:         :IN
10a6:20 85 12     jsr lineGetName
10a9:4c 20 14     jmp ioPush
10ac:         
10ac:         :IB
10ac:20 85 12     jsr lineGetName
10af:60           rts             ; XXX write binary file
10b0:         
10b0:         :IF
10b0:20 e5 12     jsr lineAssertToken
10b3:         
10b3:24 44        bit lineIfs
10b5:30 17        bmi :falseIf
10b7:         
10b7:20 f1 12     jsr lineEval
10ba:20 18 11     jsr lineTruth
10bd:a5 36        lda arg+1
10bf:29 80        and #$80
10c1:0a           asl
10c2:66 45        ror lineIfd     ; desinty set
10c4:a5 36        lda arg+1
10c6:49 80        eor #$80
10c8:0a           asl             ; truth->C
10c9:66 44        ror lineIfs     ; push if stack
10cb:4c d9 12     jmp lineAssertEnd
10ce:         
10ce:         :falseIf
10ce:38           sec
10cf:66 44        ror lineIfs     ; stay in false state
10d1:38           sec
10d2:66 45        ror lineIfd     ; and this is our destiny at this level
10d4:60           rts
10d5:         
10d5:         ;
10d5:         ; resolve label field into ptr, adjusting symScope if necessary
10d5:         linePinLabel:
10d5:64 3d        stz labelPtr
10d7:20 62 0e     jsr eResolveSym
10da:ad 00 20     lda lineBuf
10dd:c9 3a        cmp #58         ; ':'
10df:f0 08        beq :local
10e1:a5 27        lda ptr
10e3:85 2d        sta symScope    ; this becomes our new scope
10e5:a5 28        lda ptr+1
10e7:85 2e        sta symScope+1
10e9:         :local
10e9:a5 40        lda pass
10eb:d0 1a        bne :out        ; if pass >0, just return it
10ed:24 44        bit lineIfs
10ef:30 16        bmi :out        ; if'd out, just return it
10f1:a0 04        ldy #4
10f3:b1 27        lda (ptr),y
10f5:d0 13        bne :dupLabel
10f7:a9 01        lda #1
10f9:91 27        sta (ptr),y
10fb:c8           iny
10fc:ad f1 1c     lda pc
10ff:91 27        sta (ptr),y     ; initially store pc
1101:c8           iny
1102:ad f2 1c     lda pc+1
1105:91 27        sta (ptr),y     ; may be set later with =expr
1107:         :out
1107:a6 29        ldx labelEnd    ; restore x
1109:60           rts
110a:         
110a:         :dupLabel
110a:a9 02        lda #errors:dupLabel
110c:85 46        sta error
110e:4c cc 12     jmp lineExit
1111:         
1111:         lineEmitError:
1111:a9 18        lda #errors:emit
1113:85 46        sta error
1115:4c cc 12     jmp lineExit
1118:         
1118:         ;
1118:         ; normalize non-0 to $8xxx for if checking
1118:         lineTruth:
1118:a9 ff        lda #$ff
111a:24 35        bit arg
111c:d0 04        bne :true
111e:24 36        bit arg+1
1120:f0 02        beq :false
1122:         :true
1122:85 36        sta arg+1
1124:         :false
1124:60           rts
1125:         
1125:         ;
1125:         ; emit byte
1125:         ; pc incremented, (emit) called
1125:         lineEmit:
1125:ee f1 1c     inc pc          ; pc++
1128:d0 03        bne :lo
112a:ee f2 1c     inc pc+1
112d:         :lo
112d:20 33 11     jsr :doEmit
1130:b0 df        bcs lineEmitError
1132:60           rts
1133:         
1133:         :doEmit
1133:6c e5 1c     jmp (emit)
1136:         
1136:         lineOpError:
1136:a9 0e        lda #errors:op
1138:85 46        sta error
113a:60           rts
113b:         
113b:         ;
113b:         ; isn (arg) part
113b:         lineIsn:
113b:20 d7 17     jsr isnGet
113e:b0 f6        bcs lineOpError
1140:a9 07        lda #modeImp
1142:85 34        sta isnMode     ; assume implied
1144:64 2c        stz isnBit      ; start not assuming bit instruction
1146:e8           inx             ; skip isn
1147:e8           inx
1148:e8           inx
1149:20 15 0e     jsr eIsOct      ; test for bit number
114c:90 03        bcc :notbitn
114e:85 2c        sta isnBit      ; '0'-'7' if this is a bitn
1150:e8           inx
1151:         
1151:         :notbitn
1151:20 b2 12     jsr lineNextToken
1154:f0 47        beq :gob        ; implied
1156:c9 23        cmp #'#
1158:f0 46        beq :imm
115a:c9 28        cmp #'(
115c:f0 4c        beq :ind
115e:         
115e:20 f1 12     jsr lineEval
1161:         
1161:a9 00        lda #modeAbs    ; abs (so far)
1163:85 34        sta isnMode
1165:         
1165:bd 00 20     lda lineBuf,x
1168:c9 2c        cmp #',
116a:d0 31        bne :gob
116c:e8           inx             ; consume ,
116d:bd 00 20     lda lineBuf,x
1170:20 3c 0b     jsr ePet
1173:29 7f        and #$7f        ; normalize case
1175:c9 58        cmp #'x
1177:f0 18        beq :absx
1179:c9 59        cmp #'y
117b:f0 1b        beq :absy
117d:         
117d:a5 35        lda arg
117f:8d ef 1c     sta argZ        ; zp,rel
1182:20 f1 12     jsr lineEval
1185:         
1185:a9 09        lda #modeBitRel
1187:85 34        sta isnMode
1189:4c f5 11     jmp :go
118c:         
118c:         :modeError:
118c:a9 10        lda #errors:mode
118e:85 46        sta error
1190:60           rts
1191:         
1191:         :absx
1191:e8           inx             ; consume 'x'
1192:a9 02        lda #modeAbsX   ; abs,x
1194:85 34        sta isnMode
1196:80 05        bra :gob
1198:         
1198:         :absy
1198:e8           inx             ; consume 'y'
1199:a9 03        lda #modeAbsY   ; abs,y
119b:85 34        sta isnMode
119d:             ; fall thru
119d:         
119d:         :gob
119d:4c f5 11     jmp :go
11a0:         
11a0:         :imm
11a0:e8           inx             ; skip #
11a1:20 f1 12     jsr lineEval
11a4:         
11a4:a9 06        lda #modeImm    ; imm
11a6:85 34        sta isnMode
11a8:80 4b        bra :go
11aa:         
11aa:         :ind
11aa:e8           inx             ; skip (
11ab:20 f1 12     jsr lineEval
11ae:             
11ae:a9 04        lda #modeAbsInd ; indirect
11b0:85 34        sta isnMode
11b2:             
11b2:bd 00 20     lda lineBuf,x
11b5:c9 2c        cmp #',
11b7:f0 06        beq :indx
11b9:c9 29        cmp #')
11bb:f0 1e        beq :indy
11bd:             
11bd:80 cd        bra :modeError
11bf:             
11bf:         :indx
11bf:e8           inx             ; skip ,
11c0:bd 00 20     lda lineBuf,x
11c3:20 3c 0b     jsr ePet
11c6:29 7f        and #$7f
11c8:c9 58        cmp #'x
11ca:d0 c0        bne :modeError
11cc:e8           inx
11cd:bd 00 20     lda lineBuf,x
11d0:c9 29        cmp #')
11d2:d0 b8        bne :modeError
11d4:e8           inx
11d5:         
11d5:a9 01        lda #modeAbsIndX ; (ind,x)
11d7:85 34        sta isnMode
11d9:80 1a        bra :go
11db:         
11db:         :indy
11db:e8           inx             ; skip )
11dc:bd 00 20     lda lineBuf,x
11df:c9 2c        cmp #',
11e1:d0 12        bne :go         ; presume (ind)
11e3:e8           inx
11e4:bd 00 20     lda lineBuf,x
11e7:20 3c 0b     jsr ePet
11ea:29 7f        and #$7f
11ec:c9 59        cmp #'y
11ee:d0 9c        bne :modeError
11f0:e8           inx
11f1:         
11f1:a9 0f        lda #modeZeroIndY
11f3:85 34        sta isnMode     ; (ind),y
11f5:             ; fall thru
11f5:         
11f5:             ; resolved address mode
11f5:         :go
11f5:20 d9 12     jsr lineAssertEnd
11f8:a5 2c        lda isnBit      ; check for bitn
11fa:f0 13        beq :notbit
11fc:38           sec
11fd:e9 30        sbc #'0
11ff:0a           asl
1200:0a           asl
1201:0a           asl
1202:0a           asl
1203:85 2c        sta isnBit
1205:a5 34        lda isnMode
1207:c9 00        cmp #modeAbs
1209:d0 04        bne :notbit
120b:a9 05        lda #modeBitZero
120d:85 34        sta isnMode
120f:         
120f:         :notbit
120f:a5 33        lda isnOp
1211:c9 54        cmp #$54        ; BRK is special
1213:f0 49        beq :brk
1215:         
1215:20 2c 18     jsr opResolve   ; opcode in a
1218:b0 4f        bcs :modeErrorb
121a:         
121a:65 2c        adc isnBit      ; if bitn, adjust
121c:20 25 11     jsr lineEmit    ; opcode
121f:         
121f:a5 34        lda isnMode
1221:c9 08        cmp #modeRel
1223:f0 0a        beq :rel
1225:c9 09        cmp #modeBitRel
1227:d0 43        bne :notrel
1229:         
1229:ad ef 1c     lda argZ
122c:20 25 11     jsr lineEmit    ; zp arg of bitRel
122f:         
122f:         :rel
122f:a5 40        lda pass
1231:f0 28        beq :pass0      ; no check in first pass    
1233:         
1233:ad f1 1c     lda pc          ; relative
1236:18           clc
1237:69 01        adc #1          ; scratch=pc+1
1239:85 22        sta scratch
123b:ad f2 1c     lda pc+1
123e:69 00        adc #0
1240:85 23        sta scratch+1
1242:         
1242:a5 35        lda arg         ; arg-=scratch
1244:38           sec
1245:e5 22        sbc scratch
1247:85 35        sta arg
1249:a5 36        lda arg+1
124b:e5 23        sbc scratch+1
124d:85 36        sta arg+1
124f:         
124f:a2 ff        ldx #$ff
1251:a5 35        lda arg         ; test for valid range
1253:30 02        bmi :checkBack
1255:a2 00        ldx #$00
1257:         :checkBack
1257:e4 36        cpx arg+1
1259:d0 25        bne :relError
125b:         
125b:         :pass0
125b:4c 25 11     jmp lineEmit    ; send it
125e:         
125e:         :brk
125e:a5 34        lda isnMode
1260:c9 07        cmp #modeImp
1262:d0 05        bne :modeErrorb
1264:a9 00        lda #0
1266:4c 25 11     jmp lineEmit    ; emit the single $00
1269:         
1269:         :modeErrorb
1269:4c 8c 11     jmp :modeError
126c:         
126c:         :notrel
126c:c9 07        cmp #modeImp
126e:f0 14        beq :done
1270:         
1270:a5 35        lda arg         ; low byte or zp
1272:20 25 11     jsr lineEmit
1275:         
1275:a5 34        lda isnMode
1277:c9 05        cmp #5
1279:b0 09        bcs :done
127b:         
127b:a5 36        lda arg+1       ; high byte
127d:4c 25 11     jmp lineEmit
1280:         
1280:         :relError
1280:a9 12        lda #errors:rel
1282:85 46        sta error
1284:         :done
1284:60           rts
1285:         
1285:         ;
1285:         ; expect 'quoted string' and return in a/x/y
1285:         lineGetName:
1285:20 e5 12     jsr lineAssertToken
1288:e8           inx
1289:c9 27        cmp #''
128b:d0 17        bne lineErrorDotArg
128d:86 22        stx scratch
128f:a0 00        ldy #0
1291:         :count
1291:20 d1 12     jsr lineEndExit
1294:c9 27        cmp #''
1296:f0 04        beq :got
1298:c8           iny
1299:e8           inx
129a:d0 f5        bne :count
129c:         :got
129c:98           tya             ; length -> A
129d:a6 22        ldx scratch
129f:a0 20        ldy #>lineBuf
12a1:4c ab 13     jmp ioCopySourceName
12a4:         
12a4:         lineErrorDotArg:
12a4:a9 1a        lda #errors:dotArg
12a6:85 46        sta error
12a8:80 22        bra lineExit
12aa:         
12aa:         ;
12aa:         ; Z=1 if at end
12aa:         lineEnd:
12aa:bd 00 20     lda lineBuf,x
12ad:f0 02        beq :out        ; eof
12af:c9 3b        cmp #';
12b1:         :out
12b1:60           rts
12b2:         
12b2:         ;
12b2:         ; Z=1 if at end (; or eof)
12b2:         lineNextToken:
12b2:20 aa 12     jsr lineEnd
12b5:f0 0c        beq :out
12b7:c9 21        cmp #33
12b9:90 09        bcc :white
12bb:c9 a0        cmp #160
12bd:f0 05        beq :white
12bf:c9 e0        cmp #224
12c1:f0 01        beq :white
12c3:         :out
12c3:60           rts
12c4:         :white
12c4:e8           inx
12c5:80 eb        bra lineNextToken
12c7:         
12c7:         ;
12c7:         ; lineNextToken with a fast exit at end
12c7:         lineNextTokenExit:
12c7:20 b2 12     jsr lineNextToken
12ca:d0 04        bne lineExit:out
12cc:         lineExit:
12cc:ae ee 1c     ldx lineSP      ; rewind stack for fast exit
12cf:9a           txs
12d0:         :out
12d0:60           rts
12d1:         
12d1:         ;
12d1:         ; lineEnd with fast exit
12d1:         lineEndExit:
12d1:20 aa 12     jsr lineEnd
12d4:d0 02        bne :out
12d6:80 f4        bra lineExit
12d8:         :out
12d8:60           rts
12d9:         
12d9:         ;
12d9:         ; lineNextToken with an error and fast exit if not at end
12d9:         lineAssertEnd:
12d9:20 b2 12     jsr lineNextToken
12dc:f0 06        beq :out
12de:a9 14        lda #errors:parse
12e0:85 46        sta error
12e2:80 e8        bra lineExit
12e4:         :out
12e4:60           rts
12e5:         
12e5:         ;
12e5:         ; lineNextToken with an error and fast exit if at end
12e5:         lineAssertToken:
12e5:20 b2 12     jsr lineNextToken
12e8:d0 06        bne :out
12ea:a9 16        lda #errors:noArg
12ec:85 46        sta error
12ee:80 dc        bra lineExit
12f0:         :out
12f0:60           rts
12f1:         
12f1:         ;
12f1:         ; call eEval and fast exit on error
12f1:         lineEval
12f1:20 4f 0b     jsr eEval
12f4:90 06        bcc :out
12f6:a9 08        lda #errors:eval
12f8:85 46        sta error
12fa:80 d0        bra lineExit
12fc:         :out
12fc:60           rts
12fd:         
12fd:             .in 'io.asm'
12fd:             .in 'zp.asm'
12fd:             .fi ; zpAsm
12fd:         
12fd:             .in 'kernal.asm'
12fd:             .fi ; kernalAsm
12fd:         
12fd:         
12fd:         ;
12fd:         ; initialize
12fd:         ioInit:
12fd:20 e7 ff     jsr CLALL
1300:9c eb 1c     stz ioLFN
1303:64 49        stz ioNameL
1305:9c ec 1c     stz ioStatus
1308:64 46        stz error
130a:9c e8 1c     stz ioLine
130d:9c e9 1c     stz ioLine+1
1310:64 4a        stz ioOutPtr
1312:9c ea 1c     stz ioFDS
1315:a9 ff        lda #$ff
1317:85 3f        sta ioPtr
1319:a9 08        lda #8          ; default to device 8
131b:8d e7 1c     sta ioDev
131e:a9 28        lda #<:null
1320:8d e5 1c     sta emit
1323:a9 13        lda #>:null
1325:8d e6 1c     sta emit+1
1328:         :null
1328:18           clc
1329:60           rts
132a:         
132a:         ;
132a:         ; close all files and display error
132a:         ioError:
132a:20 fe 15     jsr ioCloseAll
132d:a9 0d        lda #13         ; cr
132f:20 d2 ff     jsr CHROUT
1332:a0 00        ldy #0
1334:         :print
1334:c4 49        cpy ioNameL
1336:f0 08        beq :printed
1338:b1 47        lda (ioName),y  ; print "filename:"
133a:20 d2 ff     jsr CHROUT
133d:c8           iny
133e:d0 f4        bne :print
1340:         :printed
1340:a9 3a        lda #':
1342:20 d2 ff     jsr CHROUT
1345:ad e9 1c     lda ioLine+1
1348:20 8c 16     jsr ioPrintHex
134b:ad e8 1c     lda ioLine
134e:20 8c 16     jsr ioPrintHex
1351:a9 20        lda #32
1353:20 d2 ff     jsr CHROUT
1356:20 cd 16     jsr ioPrintErr
1359:a2 6b        ldx #<:status
135b:a0 13        ldy #>:status
135d:20 bc 16     jsr ioPrint
1360:ad ec 1c     lda ioStatus
1363:20 8c 16     jsr ioPrintHex
1366:a9 0a        lda #10         ; cr
1368:4c d2 ff     jmp CHROUT
136b:         
136b:         :status
136b:2c 53 54 41 54 55 53 3d 
1373:24 00        .db ',status=$',0
1375:         
1375:         ;
1375:         ; make a copy of a/x/y with ,p,w appended
1375:         ; result in a/x/y
1375:         ioCopyDestName:
1375:20 c9 13     jsr ioCopyName
1378:a9 2c        lda #',
137a:91 27        sta (ptr),y
137c:c8           iny
137d:a9 50        lda #'p
137f:91 27        sta (ptr),y
1381:c8           iny
1382:a9 2c        lda #',
1384:91 27        sta (ptr),y
1386:c8           iny
1387:a9 57        lda #'w
1389:91 27        sta (ptr),y
138b:c8           iny
138c:         
138c:98           tya
138d:a4 28        ldy ptr+1
138f:60           rts
1390:         
1390:         ;
1390:         ; make a copy of a/x/y with ,s,w appended
1390:         ioCopyListName:
1390:20 c9 13     jsr ioCopyName
1393:a9 2c        lda #',
1395:91 27        sta (ptr),y
1397:c8           iny
1398:a9 53        lda #'s
139a:91 27        sta (ptr),y
139c:c8           iny
139d:a9 2c        lda #',
139f:91 27        sta (ptr),y
13a1:c8           iny
13a2:a9 57        lda #'w
13a4:91 27        sta (ptr),y
13a6:c8           iny
13a7:         
13a7:98           tya
13a8:a4 28        ldy ptr+1
13aa:60           rts
13ab:         
13ab:         ;
13ab:         ; make a copy of a/x/y with ,s,r appended
13ab:         ; result in a/(ptr)
13ab:         ioCopySourceName:
13ab:20 e6 13     jsr ioStringOut
13ae:20 c9 13     jsr ioCopyName
13b1:a9 2c        lda #',
13b3:91 27        sta (ptr),y
13b5:c8           iny
13b6:a9 53        lda #'s
13b8:91 27        sta (ptr),y
13ba:c8           iny
13bb:a9 2c        lda #',
13bd:91 27        sta (ptr),y
13bf:c8           iny
13c0:a9 52        lda #'r
13c2:91 27        sta (ptr),y
13c4:c8           iny
13c5:         
13c5:98           tya
13c6:a4 28        ldy ptr+1
13c8:60           rts    
13c9:         
13c9:         ioCopyName:
13c9:86 23        stx string
13cb:84 24        sty string+1
13cd:a8           tay
13ce:18           clc
13cf:69 04        adc #4
13d1:20 f3 0a     jsr symPush
13d4:84 22        sty scratch
13d6:a0 00        ldy #0
13d8:         :loop
13d8:c4 22        cpy scratch
13da:f0 07        beq :done
13dc:b1 23        lda (string),y
13de:91 27        sta (ptr),y
13e0:c8           iny
13e1:d0 f5        bne :loop
13e3:         :done
13e3:a6 27        ldx ptr
13e5:60           rts
13e6:         
13e6:         ;
13e6:         ; print string a/x/y with CR
13e6:         ; all preserved
13e6:         ioStringOut:
13e6:85 22        sta scratch
13e8:86 23        stx string
13ea:84 24        sty string+1
13ec:a0 00        ldy #0
13ee:         :loop
13ee:c4 22        cpy scratch
13f0:f0 08        beq :done
13f2:b1 23        lda (string),y
13f4:20 d2 ff     jsr CHROUT
13f7:c8           iny
13f8:d0 f4        bne :loop
13fa:         :done
13fa:a9 0d        lda #13
13fc:20 d2 ff     jsr CHROUT
13ff:a5 22        lda scratch
1401:a6 23        ldx string
1403:a4 24        ldy string+1
1405:60           rts
1406:         
1406:         ;
1406:         ; open output file named in a/x/y with LFN 2
1406:         ioOpenDest:
1406:20 bd ff     jsr SETNAM
1409:a9 02        lda #2
140b:ae e7 1c     ldx ioDev
140e:a0 02        ldy #2
1410:20 ba ff     jsr SETLFS
1413:20 c0 ff     jsr OPEN
1416:90 07        bcc :opened
1418:8d ec 1c     sta ioStatus
141b:a9 1c        lda #errors:io
141d:85 46        sta error
141f:         :opened
141f:60           rts
1420:         
1420:         ;
1420:         ; push input file a/x/y
1420:         ioPush:
1420:85 22        sta scratch
1422:86 27        stx ptr
1424:84 28        sty ptr+1
1426:20 cc ff     jsr CLRCHN
1429:         
1429:a4 3f        ldy ioPtr       ; push current state
142b:         
142b:ad eb 1c     lda ioLFN       ; push current LFN (zero is done)
142e:99 00 1e     sta ioStack,y
1431:88           dey
1432:         
1432:ad e7 1c     lda ioDev       ; device
1435:99 00 1e     sta ioStack,y
1438:88           dey
1439:         
1439:ad ec 1c     lda ioStatus    ; status
143c:99 00 1e     sta ioStack,y
143f:88           dey
1440:         
1440:a5 48        lda ioName+1    ; filename
1442:99 00 1e     sta ioStack,y
1445:88           dey
1446:a5 47        lda ioName
1448:99 00 1e     sta ioStack,y
144b:88           dey
144c:         
144c:a5 49        lda ioNameL     ; filename length
144e:99 00 1e     sta ioStack,y
1451:88           dey
1452:         
1452:ad e9 1c     lda ioLine+1    ; line
1455:99 00 1e     sta ioStack,y
1458:88           dey
1459:ad e8 1c     lda ioLine
145c:99 00 1e     sta ioStack,y
145f:88           dey
1460:         
1460:84 3f        sty ioPtr       ; current state all pushed
1462:         
1462:             ; TODO: parse for @device:
1462:         
1462:a5 22        lda scratch     ; scratch/ptr -> nameL/name
1464:85 49        sta ioNameL
1466:a6 27        ldx ptr
1468:86 47        stx ioName
146a:a4 28        ldy ptr+1
146c:84 48        sty ioName+1
146e:20 bd ff     jsr SETNAM      ; filename
1471:         
1471:20 f7 14     jsr ioAlloc     ; device secondary in Y
1474:b0 2b        bcs :toomany
1476:c8           iny
1477:c8           iny
1478:c8           iny             ; ..and add 3 to it (we use 2 for the output)
1479:ae e7 1c     ldx ioDev
147c:98           tya             ; use LFN=device secondary
147d:8d eb 1c     sta ioLFN
1480:20 ba ff     jsr SETLFS
1483:         
1483:20 c0 ff     jsr OPEN        ; open the file
1486:b0 11        bcs :error
1488:ae eb 1c     ldx ioLFN
148b:20 c6 ff     jsr CHKIN
148e:b0 09        bcs :error      ; now current file for reading
1490:9c e8 1c     stz ioLine
1493:9c e9 1c     stz ioLine+1
1496:4c 64 15     jmp ioReadStatus
1499:         
1499:         :error
1499:8d ec 1c     sta ioStatus
149c:a9 1c        lda #errors:io
149e:85 46        sta error
14a0:60           rts
14a1:         
14a1:         :toomany
14a1:a9 1e        lda #errors:tooMany
14a3:85 46        sta error
14a5:60           rts
14a6:         
14a6:         ;
14a6:         ; pop current file state
14a6:         ioPop:
14a6:20 cc ff     jsr CLRCHN      ; disconnect existing
14a9:ad eb 1c     lda ioLFN
14ac:20 c3 ff     jsr CLOSE       ; close current logical file
14af:ac eb 1c     ldy ioLFN
14b2:88           dey
14b3:88           dey
14b4:88           dey
14b5:20 0c 15     jsr ioDealloc   ; deallocate device secondary
14b8:         
14b8:a4 3f        ldy ioPtr
14ba:         
14ba:c8           iny             ; line number
14bb:b9 00 1e     lda ioStack,y
14be:8d e8 1c     sta ioLine
14c1:c8           iny
14c2:b9 00 1e     lda ioStack,y
14c5:8d e9 1c     sta ioLine+1
14c8:         
14c8:c8           iny             ; filename length
14c9:b9 00 1e     lda ioStack,y
14cc:85 49        sta ioNameL
14ce:         
14ce:c8           iny             ; filename
14cf:b9 00 1e     lda ioStack,y
14d2:85 47        sta ioName
14d4:c8           iny
14d5:b9 00 1e     lda ioStack,y
14d8:85 48        sta ioName+1
14da:         
14da:c8           iny             ; status
14db:b9 00 1e     lda ioStack,y
14de:8d ec 1c     sta ioStatus
14e1:         
14e1:c8           iny
14e2:b9 00 1e     lda ioStack,y   ; device
14e5:8d e7 1c     sta ioDev
14e8:         
14e8:c8           iny             ; LFN
14e9:be 00 1e     ldx ioStack,y
14ec:8e eb 1c     stx ioLFN
14ef:             
14ef:84 3f        sty ioPtr
14f1:         
14f1:f0 03        beq :zero       ; do not redirect from 0
14f3:4c c6 ff     jmp CHKIN       ; this also becomes our current input
14f6:         :zero
14f6:60           rts
14f7:         
14f7:         ;
14f7:         ; allocate device secondary
14f7:         ; result in Y
14f7:         ioAlloc:
14f7:a9 01        lda #$01
14f9:a0 00        ldy #0
14fb:18           clc
14fc:         :scan
14fc:2c ea 1c     bit ioFDS
14ff:f0 04        beq :done
1501:c8           iny
1502:0a           asl
1503:90 f7        bcc :scan
1505:         :done
1505:0d ea 1c     ora ioFDS
1508:8d ea 1c     sta ioFDS
150b:60           rts
150c:         
150c:         ;
150c:         ; deallocate device secondary in Y
150c:         ioDealloc:
150c:a9 01        lda #$01
150e:         :shift
150e:c0 00        cpy #0
1510:f0 04        beq :done
1512:0a           asl
1513:88           dey
1514:d0 f8        bne :shift
1516:         :done
1516:49 ff        eor #$ff        ; clear the bit
1518:2d ea 1c     and ioFDS
151b:8d ea 1c     sta ioFDS
151e:60           rts
151f:         
151f:         ;
151f:         ; read a line of input from current file
151f:         ; if ioLFN is 0 on return, at end of all files and nothing read
151f:         ioReadLine:
151f:ad ec 1c     lda ioStatus    ; check last eof
1522:f0 0b        beq :next       ; no eof, continue
1524:         
1524:20 a6 14     jsr ioPop
1527:ad eb 1c     lda ioLFN
152a:f0 02        beq :done
152c:80 f1        bra ioReadLine
152e:         
152e:         :done
152e:60           rts             ; end of all files
152f:         
152f:         :next
152f:f8           sed             ; increment bcd line number
1530:18           clc
1531:ad e8 1c     lda ioLine
1534:69 01        adc #$01
1536:8d e8 1c     sta ioLine
1539:ad e9 1c     lda ioLine+1
153c:69 00        adc #0
153e:8d e9 1c     sta ioLine+1
1541:d8           cld
1542:         
1542:a0 00        ldy #0
1544:20 cf ff     jsr CHRIN       ; read first, check error
1547:8d 00 20     sta lineBuf
154a:20 64 15     jsr ioReadStatus
154d:d0 10        bne :eol
154f:ad 00 20     lda lineBuf
1552:         :loop               ; this means if line does not end in CR, we can fail
1552:c9 0d        cmp #13         ; cr
1554:f0 09        beq :eol
1556:20 cf ff     jsr CHRIN
1559:c8           iny
155a:99 00 20     sta lineBuf,y        
155d:d0 f3        bne :loop
155f:         
155f:         :eol
155f:a9 00        lda #0
1561:99 00 20     sta lineBuf,y
1564:         
1564:         ioReadStatus:
1564:20 b7 ff     jsr READST
1567:8d ec 1c     sta ioStatus
156a:89 bf        bit #$bf        ; everything except eof
156c:f0 04        beq :done
156e:a9 1c        lda #errors:io
1570:85 46        sta error
1572:         :done
1572:89 ff        bit #$ff        ; leave Z=0 if EOF
1574:60           rts
1575:         
1575:         ;
1575:         ; emit binary output
1575:         ioEmit:
1575:86 2a        stx emitX
1577:84 2b        sty emitY
1579:a4 4a        ldy ioOutPtr
157b:99 00 1d     sta ioBuf,y
157e:c8           iny
157f:84 4a        sty ioOutPtr
1581:18           clc             ; no error
1582:d0 03        bne :out
1584:20 af 15     jsr ioFlushAlways
1587:         :out
1587:a6 2a        ldx emitX
1589:a4 2b        ldy emitY
158b:60           rts
158c:         
158c:         ;
158c:         ; emit listing output
158c:         ioEmitListing:
158c:20 a4 16     jsr ioHex
158f:a9 20        lda #32
1591:20 75 15     jsr ioEmit
1594:b0 14        bcs :out
1596:ee f0 1c     inc ioColumn
1599:ad f0 1c     lda ioColumn
159c:c9 08        cmp #8
159e:90 0a        bcc :out
15a0:a9 0d        lda #13
15a2:20 75 15     jsr ioEmit
15a5:b0 03        bcs :out
15a7:20 42 16     jsr ioListing
15aa:         :out
15aa:60           rts
15ab:         
15ab:         
15ab:         ;
15ab:         ; flush any unwritten output
15ab:         ioFlush:
15ab:a5 4a        lda ioOutPtr
15ad:f0 45        beq ioSuccess
15af:         ioFlushAlways:
15af:20 cc ff     jsr CLRCHN
15b2:a2 02        ldx #2
15b4:20 c9 ff     jsr CHKOUT
15b7:b0 1e        bcs :done
15b9:         
15b9:a5 4a        lda ioOutPtr    ; try to write entire buffer
15bb:a2 00        ldx #<ioBuf     ; invariant: 0; this is page aligned
15bd:a0 1d        ldy #>ioBuf
15bf:20 b1 fe     jsr MCIOUT
15c2:b0 06        bcs :slow       ; not supported
15c4:         
15c4:e4 4a        cpx ioOutPtr    ; did we write everything?
15c6:f0 0f        beq :done
15c8:80 02        bra :loop       ; byte bang the rest
15ca:         
15ca:         :slow
15ca:a2 00        ldx #0          ; byte bang
15cc:         :loop
15cc:bd 00 1d     lda ioBuf,x
15cf:20 d2 ff     jsr CHROUT
15d2:e8           inx
15d3:e4 4a        cpx ioOutPtr
15d5:d0 f5        bne :loop
15d7:         :done
15d7:64 4a        stz ioOutPtr
15d9:20 cc ff     jsr CLRCHN
15dc:ae eb 1c     ldx ioLFN
15df:f0 03        beq :noread
15e1:20 c6 ff     jsr CHKIN
15e4:         :noread
15e4:20 b7 ff     jsr READST
15e7:c9 00        cmp #0
15e9:f0 09        beq ioSuccess
15eb:8d ec 1c     sta ioStatus
15ee:a9 1c        lda #errors:io
15f0:85 46        sta error
15f2:38           sec
15f3:60           rts
15f4:         ioSuccess:
15f4:18           clc
15f5:60           rts
15f6:         
15f6:         ;
15f6:         ; flush output buffer and close
15f6:         ioClose:
15f6:20 ab 15     jsr ioFlush
15f9:a9 02        lda #2
15fb:4c c3 ff     jmp CLOSE
15fe:         
15fe:         ;
15fe:         ; close all disk before exiting abnormally
15fe:         ioCloseAll:
15fe:             ; preserve filename and line number for error
15fe:ad e8 1c     lda ioLine
1601:8d 00 20     sta lineBuf
1604:ad e9 1c     lda ioLine+1
1607:8d 01 20     sta lineBuf+1
160a:a5 49        lda ioNameL
160c:8d 02 20     sta lineBuf+2
160f:a5 47        lda ioName
1611:8d 03 20     sta lineBuf+3
1614:a5 48        lda ioName+1
1616:8d 04 20     sta lineBuf+4
1619:         
1619:20 f6 15     jsr ioClose
161c:         :loop
161c:ad eb 1c     lda ioLFN
161f:f0 05        beq :done
1621:20 a6 14     jsr ioPop
1624:80 f6        bra :loop
1626:         :done
1626:ad 00 20     lda lineBuf
1629:8d e8 1c     sta ioLine
162c:ad 01 20     lda lineBuf+1
162f:8d e9 1c     sta ioLine+1
1632:ad 02 20     lda lineBuf+2
1635:85 49        sta ioNameL
1637:ad 03 20     lda lineBuf+3
163a:85 47        sta ioName
163c:ad 04 20     lda lineBuf+4
163f:85 48        sta ioName+1
1641:         
1641:60           rts
1642:         
1642:         ;
1642:         ; emit listing address, reset column count
1642:         ioListing:
1642:a5 40        lda pass
1644:10 18        bpl :silent     ; $80 must be set in pass for this output
1646:a5 44        lda lineIfs
1648:30 14        bmi :silent     ; do not list if'd out
164a:ad f2 1c     lda pc+1        ; PC:
164d:20 a4 16     jsr ioHex
1650:ad f1 1c     lda pc
1653:20 a4 16     jsr ioHex
1656:a9 3a        lda #':
1658:20 75 15     jsr ioEmit
165b:9c f0 1c     stz ioColumn
165e:         :silent
165e:60           rts
165f:         
165f:         ;
165f:         ; pad trailing spaced per ioColumn
165f:         ioPadListing:
165f:a9 03        lda #3
1661:38           sec
1662:ed f0 1c     sbc ioColumn
1665:90 0c        bcc :nextLine
1667:aa           tax
1668:18           clc
1669:         :loop
1669:ca           dex
166a:30 1f        bmi :done
166c:a0 03        ldy #3
166e:20 81 16     jsr :spaces
1671:80 f6        bra :loop
1673:         :nextLine
1673:a9 0d        lda #13         ; cr
1675:20 75 15     jsr ioEmit
1678:b0 11        bcs :done
167a:a0 0d        ldy #13         ; xxxx:aa bb cc
167c:20 81 16     jsr :spaces
167f:80 e8        bra :loop
1681:         :spaces
1681:a9 20        lda #32         ; space
1683:20 75 15     jsr ioEmit
1686:b0 03        bcs :done
1688:88           dey
1689:d0 f6        bne :spaces
168b:         :done
168b:60           rts
168c:         
168c:         ;
168c:         ; print hex byte in A
168c:         ioPrintHex:
168c:85 22        sta scratch
168e:4a           lsr
168f:4a           lsr
1690:4a           lsr
1691:4a           lsr
1692:20 99 16     jsr :digit
1695:a5 22        lda scratch
1697:29 0f        and #$0f
1699:         :digit
1699:c9 0a        cmp #10
169b:90 02        bcc :num
169d:69 06        adc #6          ; add 7 (C=1)
169f:         :num
169f:69 30        adc #'0
16a1:4c d2 ff     jmp CHROUT
16a4:         
16a4:         ;
16a4:         ; emit hex byte in A
16a4:         ioHex:
16a4:85 22        sta scratch
16a6:4a           lsr
16a7:4a           lsr
16a8:4a           lsr
16a9:4a           lsr
16aa:20 b1 16     jsr :digit
16ad:a5 22        lda scratch
16af:29 0f        and #$0f
16b1:         :digit
16b1:c9 0a        cmp #10
16b3:90 02        bcc :num
16b5:69 06        adc #6
16b7:         :num
16b7:69 30        adc #'0
16b9:4c 75 15     jmp ioEmit
16bc:         
16bc:         ;
16bc:         ; print 0 terminated string in X/Y
16bc:         ; uses ptr
16bc:         ioPrint:
16bc:86 27        stx ptr
16be:84 28        sty ptr+1
16c0:a0 00        ldy #0
16c2:         :loop
16c2:b1 27        lda (ptr),y
16c4:f0 06        beq :done
16c6:20 d2 ff     jsr CHROUT
16c9:c8           iny
16ca:d0 f6        bne :loop
16cc:         :done
16cc:60           rts
16cd:         
16cd:         ;
16cd:         ; print errror message
16cd:         ioPrintErr:
16cd:a6 46        ldx error
16cf:bd d9 16     lda :table,x
16d2:bc da 16     ldy :table+1,x
16d5:aa           tax
16d6:4c bc 16     jmp ioPrint
16d9:         :table
16d9:         errors:
16d9:         :fine	=*-errors
16d9:f9 16        .dw :strings:fine
16db:         :dupLabel=*-errors
16db:fe 16        .dw :strings:dupLabel
16dd:         :star	=*-errors
16dd:08 17        .dw :strings:star
16df:         :backward=*-errors
16df:12 17        .dw :strings:backward
16e1:         :eval	=*-errors
16e1:20 17        .dw :strings:eval
16e3:         :assign	=*-errors
16e3:2f 17        .dw :strings:assign
16e5:         :dotOp	=*-errors
16e5:3d 17        .dw :strings:dotOp
16e7:         :op	=*-errors
16e7:4f 17        .dw :strings:op
16e9:         :mode	=*-errors
16e9:5a 17        .dw :strings:mode
16eb:         :rel	=*-errors
16eb:6b 17        .dw :strings:rel
16ed:         :parse	=*-errors
16ed:7f 17        .dw :strings:parse
16ef:         :noArg	=*-errors
16ef:8c 17        .dw :strings:noArg
16f1:         :emit	=*-errors
16f1:99 17        .dw :strings:emit
16f3:         :dotArg	=*-errors
16f3:a8 17        .dw :strings:dotArg
16f5:         :io	=*-errors
16f5:ba 17        .dw :strings:io
16f7:         :tooMany=*-errors
16f7:c3 17        .dw :strings:tooMany
16f9:         
16f9:         errors:strings:
16f9:         :fine
16f9:46 49 4e 45 00 
                 .db 'fine',0
16fe:         :dupLabel
16fe:44 55 50 20 4c 41 42 45 
1706:4c 00        .db 'dup label',0
1708:         :star
1708:53 54 41 52 20 45 58 50 
1710:52 00        .db 'star expr',0
1712:         :backward
1712:50 43 20 4d 4f 56 45 44 
171a:20 42 41 43 4b 00 
                 .db 'pc moved back',0
1720:         :eval
1720:42 41 44 20 45 58 50 52 
1728:45 53 53 49 4f 4e 00 
                 .db 'bad expression',0
172f:         :assign
172f:42 41 44 20 41 53 53 49 
1737:47 4d 45 4e 54 00 
                 .db 'bad assigment',0
173d:         :dotOp
173d:55 4e 4b 4e 4f 57 4e 20 
1745:50 53 45 55 44 4f 20 4f 
174d:50 00        .db 'unknown pseudo op',0
174f:         :op
174f:55 4e 4b 4e 4f 57 4e 20 
1757:4f 50 00     .db 'unknown op',0
175a:         :mode
175a:42 41 44 20 41 44 44 52 
1762:45 53 53 20 4d 4f 44 45 
176a:00           .db 'bad address mode',0
176b:         :rel
176b:42 52 41 4e 43 48 20 4f 
1773:55 54 20 4f 46 20 52 41 
177b:4e 47 45 00 
                 .db 'branch out of range',0
177f:         :parse
177f:53 59 4e 54 41 58 20 45 
1787:52 52 4f 52 00 
                 .db 'syntax error',0
178c:         :noArg
178c:41 52 47 20 45 58 50 45 
1794:43 54 45 44 00 
                 .db 'arg expected',0
1799:         :emit
1799:49 4f 20 57 52 49 54 45 
17a1:20 45 52 52 4f 52 00 
                 .db 'io write error',0
17a8:         :dotArg
17a8:42 41 44 20 50 53 45 55 
17b0:44 4f 20 4f 50 20 41 52 
17b8:47 00        .db 'bad pseudo op arg',0
17ba:         :io
17ba:49 4f 20 45 52 52 4f 52 
17c2:00           .db 'io error',0
17c3:         :tooMany
17c3:54 4f 4f 20 4d 41 4e 59 
17cb:20 4f 50 45 4e 20 46 49 
17d3:4c 45 53 00 
                 .db 'too many open files',0
17d7:         
17d7:             .in 'isns.asm'
17d7:             .in 'zp.asm'
17d7:             .fi ; zpAsm
17d7:         
17d7:             .in 'mode.asm'
17d7:             .fi ; modeAsm
17d7:         
17d7:         
17d7:         
17d7:         ;
17d7:         ; return isn token at lineBuf,x
17d7:         ; isnOp: result
17d7:         ; C: not found
17d7:         isnGet:
17d7:             ; A,B,C = a-'A', b-'A', c-'A'
17d7:             ; 
17d7:             ; bit fedcba9876543210
17d7:             ;     0AAAAABBBBBCCCCC
17d7:             ; ex "LDA" is $2c60
17d7:             ;
17d7:bd 00 20     lda lineBuf,x
17da:38           sec
17db:e9 41        sbc #'a
17dd:0a           asl
17de:0a           asl
17df:85 23        sta isn2
17e1:bd 01 20     lda lineBuf+1,x
17e4:38           sec
17e5:e9 41        sbc #'a
17e7:85 22        sta isn1
17e9:4a           lsr
17ea:4a           lsr
17eb:4a           lsr
17ec:04 23        tsb isn2
17ee:a5 22        lda isn1
17f0:0a           asl
17f1:0a           asl
17f2:0a           asl
17f3:0a           asl
17f4:0a           asl
17f5:85 22        sta isn1
17f7:bd 02 20     lda lineBuf+2,x
17fa:38           sec
17fb:e9 41        sbc #'a
17fd:04 22        tsb isn1
17ff:         
17ff:             ; incr=1 element (2 bytes per entry)
17ff:a0 02        ldy #2
1801:84 24        sty incr
1803:         
1803:         :loop
1803:a5 23        lda isn2        ; hi cmp
1805:d9 71 18     cmp isns+1,y
1808:d0 07        bne :cmp        ; if =, continue with lo cmp
180a:         
180a:a5 22        lda isn1        ; lo cmp
180c:d9 70 18     cmp isns,y
180f:f0 11        beq :found      ; if =, found
1811:         
1811:         :cmp
1811:90 05        bcc :lo         ; needle < haystack location?
1813:20 26 18     jsr :next       ; no: extra advance to do it twice
1816:b0 09        bcs :not
1818:         
1818:         :lo
1818:20 26 18     jsr :next       ; advance
181b:b0 04        bcs :not
181d:         
181d:06 24        asl incr        ; double incr for next advance
181f:90 e2        bcc :loop
1821:         :not
1821:60           rts             ; invariant: C=1
1822:         
1822:         :found
1822:18           clc             ; C=0 to indicate found
1823:84 33        sty isnOp
1825:60           rts
1826:         
1826:         :next
1826:98           tya             ; y += incr
1827:18           clc
1828:65 24        adc incr        ; C=1 if over
182a:a8           tay
182b:60           rts
182c:         
182c:         ;
182c:         ; resolve deduced address mode and instruction
182c:         opResolve:
182c:a6 33        ldx isnOp
182e:bd 71 19     lda ops+1,x
1831:f0 2e        beq :imp
1833:85 28        sta ptr+1
1835:bd 70 19     lda ops,x
1838:85 27        sta ptr
183a:         
183a:             ; can we zp this?
183a:a5 36        lda arg+1       ; no, it is a 16 bit arg
183c:d0 15        bne :try
183e:         
183e:a5 34        lda isnMode     ; does this have a potential zp version?
1840:c9 05        cmp #5
1842:b0 0f        bcs :try        ; no
1844:         
1844:69 0a        adc #10         ; try the zp form
1846:85 34        sta isnMode
1848:20 53 18     jsr :try
184b:90 20        bcc :out        ; we win (or it was relative)
184d:         
184d:a5 34        lda isnMode
184f:e9 0a        sbc #10
1851:85 34        sta isnMode     ; continue with original absolute
1853:         
1853:         :try
1853:a4 34        ldy isnMode
1855:b1 27        lda (ptr),y
1857:d0 11        bne :found      ; found it
1859:         
1859:a0 08        ldy #modeRel
185b:b1 27        lda (ptr),y
185d:d0 0b        bne :found
185f:         
185f:80 0d        bra :err
1861:             
1861:         :imp
1861:a4 34        ldy isnMode     ; has to be modeImp
1863:c0 07        cpy #modeImp
1865:d0 07        bne :err
1867:bd 70 19     lda ops,x
186a:             ; fall thru
186a:         
186a:         :found
186a:84 34        sty isnMode
186c:18           clc
186d:         :out
186d:60           rts
186e:         
186e:         :err
186e:38           sec
186f:60           rts
1870:         
1870:             .in 'isns-table.asm'
1870:         *=*%100
1870:         isns:
1870:00 00        .dw $0000
1872:51 2e        .dw $2e51 ; 02 lsr
1874:32 04        .dw $0432 ; 04 bbs
1876:f2 4e        .dw $4ef2 ; 06 txs
1878:00 00        .dw $0000
187a:22 48        .dw $4822 ; 0a sbc
187c:75 09        .dw $0975 ; 0c clv
187e:ff 7f        .dw $7fff
1880:00 00        .dw $0000
1882:6f 3d        .dw $3d6f ; 12 plp
1884:eb 05        .dw $05eb ; 14 bpl
1886:ff 7f        .dw $7fff
1888:00 00        .dw $0000
188a:78 4a        .dw $4a78 ; 1a sty
188c:a2 21        .dw $21a2 ; 1c inc
188e:ff 7f        .dw $7fff
1890:00 00        .dw $0000
1892:ef 3c        .dw $3cef ; 22 php
1894:90 04        .dw $0490 ; 24 beq
1896:ff 7f        .dw $7fff
1898:00 00        .dw $0000
189a:81 49        .dw $4981 ; 2a smb
189c:82 0c        .dw $0c82 ; 2c dec
189e:ff 7f        .dw $7fff
18a0:00 00        .dw $0000
18a2:cb 45        .dw $45cb ; 32 rol
18a4:b2 06        .dw $06b2 ; 34 bvs
18a6:ff 7f        .dw $7fff
18a8:62 00        .dw $0062 ; 38 adc
18aa:21 4e        .dw $4e21 ; 3a trb
18ac:51 26        .dw $2651 ; 3c jsr
18ae:ff 7f        .dw $7fff
18b0:00 00        .dw $0000
18b2:20 3a        .dw $3a20 ; 42 ora
18b4:42 04        .dw $0442 ; 44 bcc
18b6:08 58        .dw $5808 ; 46 wai
18b8:00 00        .dw $0000
18ba:83 48        .dw $4883 ; 4a sed
18bc:f7 09        .dw $09f7 ; 4c cpx
18be:ff 7f        .dw $7fff
18c0:00 00        .dw $0000
18c2:78 3d        .dw $3d78 ; 52 ply
18c4:2a 06        .dw $062a ; 54 brk
18c6:ff 7f        .dw $7fff
18c8:00 00        .dw $0000
18ca:17 4c        .dw $4c17 ; 5a tax
18cc:b8 21        .dw $21b8 ; 5c iny
18ce:ff 7f        .dw $7fff
18d0:00 00        .dw $0000
18d2:f8 3c        .dw $3cf8 ; 62 phy
18d4:88 05        .dw $0588 ; 64 bmi
18d6:ff 7f        .dw $7fff
18d8:00 00        .dw $0000
18da:6f 4a        .dw $4a6f ; 6a stp
18dc:98 0c        .dw $0c98 ; 6c dey
18de:ff 7f        .dw $7fff
18e0:00 00        .dw $0000
18e2:68 46        .dw $4668 ; 72 rti
18e4:63 09        .dw $0963 ; 74 cld
18e6:ff 7f        .dw $7fff
18e8:4b 02        .dw $024b ; 78 asl
18ea:57 4e        .dw $4e57 ; 7a tsx
18ec:77 2c        .dw $2c77 ; 7c ldx
18ee:ff 7f        .dw $7fff
18f0:00 00        .dw $0000
18f2:cf 35        .dw $35cf ; 82 nop
18f4:42 04        .dw $0442 ; 84 bcc
18f6:00 4f        .dw $4f00 ; 86 tya
18f8:00 00        .dw $0000
18fa:82 48        .dw $4882 ; 8a sec
18fc:8f 09        .dw $098f ; 8c cmp
18fe:ff 7f        .dw $7fff
1900:00 00        .dw $0000
1902:77 3d        .dw $3d77 ; 92 plx
1904:20 06        .dw $0620 ; 94 bra
1906:ff 7f        .dw $7fff
1908:00 00        .dw $0000
190a:79 4a        .dw $4a79 ; 9a stz
190c:b7 21        .dw $21b7 ; 9c inx
190e:ff 7f        .dw $7fff
1910:00 00        .dw $0000
1912:f7 3c        .dw $3cf7 ; a2 phx
1914:13 05        .dw $0513 ; a4 bit
1916:ff 7f        .dw $7fff
1918:00 00        .dw $0000
191a:60 4a        .dw $4a60 ; aa sta
191c:97 0c        .dw $0c97 ; ac dex
191e:ff 7f        .dw $7fff
1920:00 00        .dw $0000
1922:d1 45        .dw $45d1 ; b2 ror
1924:62 09        .dw $0962 ; b4 clc
1926:ff 7f        .dw $7fff
1928:a3 01        .dw $01a3 ; b8 and
192a:41 4e        .dw $4e41 ; ba tsb
192c:60 2c        .dw $2c60 ; bc lda
192e:ff 7f        .dw $7fff
1930:00 00        .dw $0000
1932:e0 3c        .dw $3ce0 ; c2 pha
1934:52 04        .dw $0452 ; c4 bcs
1936:ff 7f        .dw $7fff
1938:00 00        .dw $0000
193a:88 48        .dw $4888 ; ca sei
193c:f8 09        .dw $09f8 ; cc cpy
193e:ff 7f        .dw $7fff
1940:00 00        .dw $0000
1942:81 45        .dw $4581 ; d2 rmb
1944:a2 06        .dw $06a2 ; d4 bvc
1946:ff 7f        .dw $7fff
1948:00 00        .dw $0000
194a:18 4c        .dw $4c18 ; da tay
194c:8f 25        .dw $258f ; dc jmp
194e:ff 7f        .dw $7fff
1950:00 00        .dw $0000
1952:60 3d        .dw $3d60 ; e2 pla
1954:a4 05        .dw $05a4 ; e4 bne
1956:ff 7f        .dw $7fff
1958:00 00        .dw $0000
195a:77 4a        .dw $4a77 ; ea stx
195c:d1 11        .dw $11d1 ; ec eor
195e:ff 7f        .dw $7fff
1960:00 00        .dw $0000
1962:72 46        .dw $4672 ; f2 rts
1964:68 09        .dw $0968 ; f4 cli
1966:ff 7f        .dw $7fff
1968:31 04        .dw $0431 ; f8 bbr
196a:e0 4e        .dw $4ee0 ; fa txa
196c:78 2c        .dw $2c78 ; fc ldy
196e:ff 7f        .dw $7fff
1970:         
1970:         ops:
1970:00 00     .dw 0
1972:10 1c     .dw :lsr
1974:b0 1a     .dw :bbs
1976:9a 00     .dw $9a ; txs
1978:00 00     .dw 0
197a:60 1c     .dw :sbc
197c:b8 00     .dw $b8 ; clv
197e:00 00     .dw 0
1980:00 00     .dw 0
1982:28 00     .dw $28 ; plp
1984:20 1b     .dw :bpl
1986:00 00     .dw 0
1988:00 00     .dw 0
198a:a0 1c     .dw :sty
198c:b0 1b     .dw :inc
198e:00 00     .dw 0
1990:00 00     .dw 0
1992:08 00     .dw $08 ; php
1994:e0 1a     .dw :beq
1996:00 00     .dw 0
1998:00 00     .dw 0
199a:70 1c     .dw :smb
199c:90 1b     .dw :dec
199e:00 00     .dw 0
19a0:00 00     .dw 0
19a2:40 1c     .dw :rol
19a4:50 1b     .dw :bvs
19a6:00 00     .dw 0
19a8:70 1a     .dw :adc
19aa:c0 1c     .dw :trb
19ac:d0 1b     .dw :jsr
19ae:00 00     .dw 0
19b0:00 00     .dw 0
19b2:20 1c     .dw :ora
19b4:c0 1a     .dw :bcc
19b6:cb 00     .dw $cb ; wai
19b8:00 00     .dw 0
19ba:f8 00     .dw $f8 ; sed
19bc:70 1b     .dw :cpx
19be:00 00     .dw 0
19c0:00 00     .dw 0
19c2:7a 00     .dw $7a ; ply
19c4:00 00     .dw $00 ; brk
19c6:00 00     .dw 0
19c8:00 00     .dw 0
19ca:aa 00     .dw $aa ; tax
19cc:c8 00     .dw $c8 ; iny
19ce:00 00     .dw 0
19d0:00 00     .dw 0
19d2:5a 00     .dw $5a ; phy
19d4:00 1b     .dw :bmi
19d6:00 00     .dw 0
19d8:00 00     .dw 0
19da:db 00     .dw $db ; stp
19dc:88 00     .dw $88 ; dey
19de:00 00     .dw 0
19e0:00 00     .dw 0
19e2:40 00     .dw $40 ; rti
19e4:d8 00     .dw $d8 ; cld
19e6:00 00     .dw 0
19e8:90 1a     .dw :asl
19ea:ba 00     .dw $ba ; tsx
19ec:f0 1b     .dw :ldx
19ee:00 00     .dw 0
19f0:00 00     .dw 0
19f2:ea 00     .dw $ea ; nop
19f4:c0 1a     .dw :bcc
19f6:98 00     .dw $98 ; tya
19f8:00 00     .dw 0
19fa:38 00     .dw $38 ; sec
19fc:60 1b     .dw :cmp
19fe:00 00     .dw 0
1a00:00 00     .dw 0
1a02:fa 00     .dw $fa ; plx
1a04:30 1b     .dw :bra
1a06:00 00     .dw 0
1a08:00 00     .dw 0
1a0a:b0 1c     .dw :stz
1a0c:e8 00     .dw $e8 ; inx
1a0e:00 00     .dw 0
1a10:00 00     .dw 0
1a12:da 00     .dw $da ; phx
1a14:f0 1a     .dw :bit
1a16:00 00     .dw 0
1a18:00 00     .dw 0
1a1a:80 1c     .dw :sta
1a1c:ca 00     .dw $ca ; dex
1a1e:00 00     .dw 0
1a20:00 00     .dw 0
1a22:50 1c     .dw :ror
1a24:18 00     .dw $18 ; clc
1a26:00 00     .dw 0
1a28:80 1a     .dw :and
1a2a:d0 1c     .dw :tsb
1a2c:e0 1b     .dw :lda
1a2e:00 00     .dw 0
1a30:00 00     .dw 0
1a32:48 00     .dw $48 ; pha
1a34:d0 1a     .dw :bcs
1a36:00 00     .dw 0
1a38:00 00     .dw 0
1a3a:78 00     .dw $78 ; sei
1a3c:80 1b     .dw :cpy
1a3e:00 00     .dw 0
1a40:00 00     .dw 0
1a42:30 1c     .dw :rmb
1a44:40 1b     .dw :bvc
1a46:00 00     .dw 0
1a48:00 00     .dw 0
1a4a:a8 00     .dw $a8 ; tay
1a4c:c0 1b     .dw :jmp
1a4e:00 00     .dw 0
1a50:00 00     .dw 0
1a52:68 00     .dw $68 ; pla
1a54:10 1b     .dw :bne
1a56:00 00     .dw 0
1a58:00 00     .dw 0
1a5a:90 1c     .dw :stx
1a5c:a0 1b     .dw :eor
1a5e:00 00     .dw 0
1a60:00 00     .dw 0
1a62:60 00     .dw $60 ; rts
1a64:58 00     .dw $58 ; cli
1a66:00 00     .dw 0
1a68:a0 1a     .dw :bbr
1a6a:8a 00     .dw $8a ; txa
1a6c:00 1c     .dw :ldy
1a6e:00 00     .dw 0
1a70:         :adc
1a70:6d 00 7d 79 00 00 69 00 
1a78:00 00 65 61 75 00 72 71 
1a80:          .db $6d,$00,$7d,$79,$00,$00,$69,$00,$00,$00,$65,$61,$75,$00,$72,$71
1a80:         :and
1a80:2d 00 3d 39 00 00 29 00 
1a88:00 00 25 21 35 00 32 31 
1a90:          .db $2d,$00,$3d,$39,$00,$00,$29,$00,$00,$00,$25,$21,$35,$00,$32,$31
1a90:         :asl
1a90:0e 00 1e 00 00 00 00 0a 
1a98:00 00 06 00 16 00 00 00 
1aa0:          .db $0e,$00,$1e,$00,$00,$00,$00,$0a,$00,$00,$06,$00,$16,$00,$00,$00
1aa0:         :bbr
1aa0:00 00 00 00 00 00 00 00 
1aa8:00 0f 00 00 00 00 00 00 
1ab0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$0f,$00,$00,$00,$00,$00,$00
1ab0:         :bbs
1ab0:00 00 00 00 00 00 00 00 
1ab8:00 8f 00 00 00 00 00 00 
1ac0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$8f,$00,$00,$00,$00,$00,$00
1ac0:         :bcc
1ac0:00 00 00 00 00 00 00 00 
1ac8:90 00 00 00 00 00 00 00 
1ad0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$90,$00,$00,$00,$00,$00,$00,$00
1ad0:         :bcs
1ad0:00 00 00 00 00 00 00 00 
1ad8:b0 00 00 00 00 00 00 00 
1ae0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$b0,$00,$00,$00,$00,$00,$00,$00
1ae0:         :beq
1ae0:00 00 00 00 00 00 00 00 
1ae8:f0 00 00 00 00 00 00 00 
1af0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$f0,$00,$00,$00,$00,$00,$00,$00
1af0:         :bit
1af0:2c 00 3c 00 00 00 89 00 
1af8:00 00 24 00 34 00 00 00 
1b00:          .db $2c,$00,$3c,$00,$00,$00,$89,$00,$00,$00,$24,$00,$34,$00,$00,$00
1b00:         :bmi
1b00:00 00 00 00 00 00 00 00 
1b08:30 00 00 00 00 00 00 00 
1b10:          .db $00,$00,$00,$00,$00,$00,$00,$00,$30,$00,$00,$00,$00,$00,$00,$00
1b10:         :bne
1b10:00 00 00 00 00 00 00 00 
1b18:d0 00 00 00 00 00 00 00 
1b20:          .db $00,$00,$00,$00,$00,$00,$00,$00,$d0,$00,$00,$00,$00,$00,$00,$00
1b20:         :bpl
1b20:00 00 00 00 00 00 00 00 
1b28:10 00 00 00 00 00 00 00 
1b30:          .db $00,$00,$00,$00,$00,$00,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00
1b30:         :bra
1b30:00 00 00 00 00 00 00 00 
1b38:80 00 00 00 00 00 00 00 
1b40:          .db $00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00
1b40:         :bvc
1b40:00 00 00 00 00 00 00 00 
1b48:50 00 00 00 00 00 00 00 
1b50:          .db $00,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00,$00,$00,$00,$00,$00
1b50:         :bvs
1b50:00 00 00 00 00 00 00 00 
1b58:70 00 00 00 00 00 00 00 
1b60:          .db $00,$00,$00,$00,$00,$00,$00,$00,$70,$00,$00,$00,$00,$00,$00,$00
1b60:         :cmp
1b60:cd 00 dd d9 00 00 c9 00 
1b68:00 00 c5 c1 d5 00 d2 d1 
1b70:          .db $cd,$00,$dd,$d9,$00,$00,$c9,$00,$00,$00,$c5,$c1,$d5,$00,$d2,$d1
1b70:         :cpx
1b70:ec 00 00 00 00 00 e0 00 
1b78:00 00 e4 00 00 00 00 00 
1b80:          .db $ec,$00,$00,$00,$00,$00,$e0,$00,$00,$00,$e4,$00,$00,$00,$00,$00
1b80:         :cpy
1b80:cc 00 00 00 00 00 c0 00 
1b88:00 00 c4 00 00 00 00 00 
1b90:          .db $cc,$00,$00,$00,$00,$00,$c0,$00,$00,$00,$c4,$00,$00,$00,$00,$00
1b90:         :dec
1b90:ce 00 de 00 00 00 00 3a 
1b98:00 00 c6 00 d6 00 00 00 
1ba0:          .db $ce,$00,$de,$00,$00,$00,$00,$3a,$00,$00,$c6,$00,$d6,$00,$00,$00
1ba0:         :eor
1ba0:4d 00 5d 59 00 00 49 00 
1ba8:00 00 45 41 55 00 52 51 
1bb0:          .db $4d,$00,$5d,$59,$00,$00,$49,$00,$00,$00,$45,$41,$55,$00,$52,$51
1bb0:         :inc
1bb0:ee 00 fe 00 00 00 00 1a 
1bb8:00 00 e6 00 f6 00 00 00 
1bc0:          .db $ee,$00,$fe,$00,$00,$00,$00,$1a,$00,$00,$e6,$00,$f6,$00,$00,$00
1bc0:         :jmp
1bc0:4c 7c 00 00 6c 00 00 00 
1bc8:00 00 00 00 00 00 00 00 
1bd0:          .db $4c,$7c,$00,$00,$6c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1bd0:         :jsr
1bd0:20 00 00 00 00 00 00 00 
1bd8:00 00 00 00 00 00 00 00 
1be0:          .db $20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1be0:         :lda
1be0:ad 00 bd b9 00 00 a9 00 
1be8:00 00 a5 a1 b5 00 b2 b1 
1bf0:          .db $ad,$00,$bd,$b9,$00,$00,$a9,$00,$00,$00,$a5,$a1,$b5,$00,$b2,$b1
1bf0:         :ldx
1bf0:ae 00 00 be 00 00 a2 00 
1bf8:00 00 a6 00 00 b6 00 00 
1c00:          .db $ae,$00,$00,$be,$00,$00,$a2,$00,$00,$00,$a6,$00,$00,$b6,$00,$00
1c00:         :ldy
1c00:ac 00 bc 00 00 00 a0 00 
1c08:00 00 a4 00 b4 00 00 00 
1c10:          .db $ac,$00,$bc,$00,$00,$00,$a0,$00,$00,$00,$a4,$00,$b4,$00,$00,$00
1c10:         :lsr
1c10:4e 00 5e 00 00 00 00 4a 
1c18:00 00 46 00 56 00 00 00 
1c20:          .db $4e,$00,$5e,$00,$00,$00,$00,$4a,$00,$00,$46,$00,$56,$00,$00,$00
1c20:         :ora
1c20:0d 00 1d 19 00 00 09 00 
1c28:00 00 05 01 15 00 12 11 
1c30:          .db $0d,$00,$1d,$19,$00,$00,$09,$00,$00,$00,$05,$01,$15,$00,$12,$11
1c30:         :rmb
1c30:00 00 00 00 00 07 00 00 
1c38:00 00 00 00 00 00 00 00 
1c40:          .db $00,$00,$00,$00,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1c40:         :rol
1c40:2e 00 3e 00 00 00 00 2a 
1c48:00 00 26 00 36 00 00 00 
1c50:          .db $2e,$00,$3e,$00,$00,$00,$00,$2a,$00,$00,$26,$00,$36,$00,$00,$00
1c50:         :ror
1c50:6e 00 7e 00 00 00 00 6a 
1c58:00 00 66 00 76 00 00 00 
1c60:          .db $6e,$00,$7e,$00,$00,$00,$00,$6a,$00,$00,$66,$00,$76,$00,$00,$00
1c60:         :sbc
1c60:ed 00 fd f9 00 00 e9 00 
1c68:00 00 e5 e1 f5 00 f2 f1 
1c70:          .db $ed,$00,$fd,$f9,$00,$00,$e9,$00,$00,$00,$e5,$e1,$f5,$00,$f2,$f1
1c70:         :smb
1c70:00 00 00 00 00 87 00 00 
1c78:00 00 00 00 00 00 00 00 
1c80:          .db $00,$00,$00,$00,$00,$87,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1c80:         :sta
1c80:8d 00 9d 99 00 00 00 00 
1c88:00 00 85 81 95 00 92 91 
1c90:          .db $8d,$00,$9d,$99,$00,$00,$00,$00,$00,$00,$85,$81,$95,$00,$92,$91
1c90:         :stx
1c90:8e 00 00 00 00 00 00 00 
1c98:00 00 86 00 00 96 00 00 
1ca0:          .db $8e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$86,$00,$00,$96,$00,$00
1ca0:         :sty
1ca0:8c 00 00 00 00 00 00 00 
1ca8:00 00 84 00 94 00 00 00 
1cb0:          .db $8c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$84,$00,$94,$00,$00,$00
1cb0:         :stz
1cb0:9c 00 9e 00 00 00 00 00 
1cb8:00 00 64 00 74 00 00 00 
1cc0:          .db $9c,$00,$9e,$00,$00,$00,$00,$00,$00,$00,$64,$00,$74,$00,$00,$00
1cc0:         :trb
1cc0:1c 00 00 00 00 00 00 00 
1cc8:00 00 14 00 00 00 00 00 
1cd0:          .db $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$14,$00,$00,$00,$00,$00
1cd0:         :tsb
1cd0:0c 00 00 00 00 00 00 00 
1cd8:00 00 04 00 00 00 00 00 
1ce0:          .db $0c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$00,$00,$00,$00,$00
1ce0:         ; size=$0470
1ce0:         
1ce0:         
1ce0:             .in 'memory.asm'
1ce0:         ;
1ce0:         ; runtime data
1ce0:         ; include LAST
1ce0:         
1ce0:         fpack:          ; 5 bytes of space for packed floating point number
1ce0:             .or *+5
1ce5:         emit:           ; emit vector
1ce5:             .or *+2
1ce7:         ioDev:          ; current disk device
1ce7:             .or *+1
1ce8:         ioLine:         ; current line
1ce8:             .or *+2
1cea:         ioFDS:          ; allocation bitmap of channels
1cea:             .or *+1
1ceb:         ioLFN:          ; current logical file number
1ceb:             .or *+1
1cec:         ioStatus:       ; input status
1cec:             .or *+1
1ced:         asmSP:          ; stack frame we started with
1ced:             .or *+1
1cee:         lineSP:         ; stack frame for calls into per line assembly for error return
1cee:             .or *+1
1cef:         argZ:           ; first zp of zp,arg
1cef:             .or *+1
1cf0:         ioColumn:       ; listing output column
1cf0:             .or *+1
1cf1:         pc:             ; pc
1cf1:             .or *+2
1cf3:         inputOpt:       ; input filename length
1cf3:             .or *+1
1cf4:         inputName:      ; input filename
1cf4:         	.or *+2
1cf6:         listOpt:        ; listing filename length
1cf6:             .or *+1
1cf7:         listName:       ; listing filename
1cf7:         	.or *+2
1cf9:         outOpt:         ; output filename length
1cf9:             .or *+1
1cfa:         outName:        ; output filename
1cfa:         	.or *+2
1cfc:         tScope:         ; save scope
1cfc:             .or *+2
1cfe:             .or *%$100	; page align
1d00:         ioBuf:          ; binary output buffer
1d00:             .or *+$100
1e00:         ioStack:        ; source file stack
1e00:             .or *+$100
1f00:         eStack:         ; numeric evaluation stack
1f00:             .or *+$100
2000:         lineBuf:        ; line to parse
2000:             .or *+$100
2100:         hashTable:      ; symbol hash table page
2100:             .or *+$100
2200:         symbols:        ; start of symbol table
2200:         
2200:         
2200: