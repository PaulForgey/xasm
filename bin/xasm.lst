1000:01 08        .dw $801
1002:             .or $801
0801:         
0801:             ; 10 SYS 2062
0801:0c 08 0a 00 
                 .dw zero, 10
0805:9e 20 32 30 36 32 00 
                 .db $9e,' 2062',0
080c:         zero:
080c:00 00        .dw 0
080e:         
080e:             *=2062
080e:         
080e:             .in 'zp.asm'
080e:             .fi ; zpAsm
080e:         
080e:             .in 'kernal.asm'
080e:             .fi ; kernalAsm
080e:         
080e:         
080e:         options=$bf00
080e:         
080e:ba           tsx
080f:8e e1 1d     stx asmSP
0812:20 ff 12     jsr ioInit
0815:20 f1 09     jsr symInit
0818:64 40        stz pass
081a:9c ea 1d     stz listOpt
081d:9c ed 1d     stz outOpt
0820:64 44        stz lineIfs
0822:64 45        stz lineIfd
0824:a9 ff        lda #$ff
0826:85 43        sta ePtr
0828:80 0a        bra begin
082a:         
082a:         usage:
082a:a2 92        ldx #<usageStr
082c:a0 09        ldy #>usageStr
082e:20 50 17     jsr ioPrint
0831:4c 7b 09     jmp exit
0834:         
0834:         begin:
0834:64 00        stz $00             ; select system bank for params
0836:a9 04        lda #4
0838:85 01        sta $01             ; select rom bank 4
083a:20 d2 09     jsr getOpt
083d:c9 00        cmp #0
083f:d0 07        bne :got
0841:20 2f 09     jsr askArgs         ; get interactively
0844:c9 00        cmp #0
0846:f0 e2        beq usage
0848:         :got
0848:20 af 13     jsr ioCopySourceName
084b:8d e7 1d     sta inputOpt        ; source filename length
084e:8e e8 1d     stx inputName
0851:8c e9 1d     sty inputName+1
0854:         
0854:20 d2 09     jsr getOpt          ; output
0857:c9 00        cmp #0
0859:f0 0c        beq :nooutOpt
085b:20 97 13     jsr ioCopyDestName
085e:8d ed 1d     sta outOpt          ; dest filename length
0861:8e ee 1d     stx outName
0864:8c ef 1d     sty outName+1
0867:         :nooutOpt
0867:         
0867:20 d2 09     jsr getOpt          ; listing
086a:c9 00        cmp #0
086c:f0 0c        beq :nolistOpt
086e:20 a4 13     jsr ioCopyListName
0871:8d ea 1d     sta listOpt
0874:8e eb 1d     stx listName
0877:8c ec 1d     sty listName+1
087a:         :nolistOpt
087a:         
087a:         asmPass:
087a:64 2d        stz symScope
087c:64 2e        stz symScope+1
087e:         
087e:ae e8 1d     ldx inputName
0881:ac e9 1d     ldy inputName+1
0884:ad e7 1d     lda inputOpt
0887:20 11 14     jsr ioPush
088a:         
088a:9c e5 1d     stz pc
088d:a9 10        lda #$10
088f:8d e6 1d     sta pc+1            ; default pc=$1000
0892:         
0892:a2 bb        ldx #<passStr       ; "pass:n"
0894:a0 09        ldy #>passStr
0896:20 50 17     jsr ioPrint
0899:a5 40        lda pass            ; pass #
089b:29 07        and #$07
089d:1a           inc
089e:20 20 17     jsr ioPrintHex
08a1:a9 0d        lda #13             ; cr
08a3:20 d2 ff     jsr CHROUT
08a6:         
08a6:         :line
08a6:20 d6 16     jsr ioListing       ; possibly show pc for listing
08a9:20 5b 15     jsr ioReadLine      ; read next line
08ac:20 88 09     jsr asmError        ; poll for error
08af:ad e0 1d     lda ioLFN           ; check for EOF
08b2:f0 29        beq :next
08b4:         
08b4:20 d9 0e     jsr lineAsm         ; assemble line
08b7:20 88 09     jsr asmError        ; poll for error
08ba:         
08ba:a5 40        lda pass
08bc:10 e8        bpl :line           ; listing output in second pass, if enabled
08be:a5 44        lda lineIfs
08c0:30 e4        bmi :line           ; do not list if'd out 
08c2:         
08c2:20 f3 16     jsr ioPadListing
08c5:         
08c5:a2 00        ldx #0
08c7:         :listLine
08c7:bd 00 22     lda lineBuf,x
08ca:f0 0a        beq :listed         ; eof
08cc:c9 0d        cmp #13
08ce:f0 06        beq :listed         ; cr
08d0:20 0c 16     jsr ioEmitBin
08d3:e8           inx
08d4:d0 f1        bne :listLine
08d6:         :listed
08d6:a9 0d        lda #13
08d8:20 0c 16     jsr ioEmitBin
08db:80 c9        bra :line
08dd:         
08dd:         :next
08dd:a5 40        lda pass            ; maybe done if non-z pass
08df:d0 21        bne :listing
08e1:1a           inc                 ; pass++
08e2:85 40        sta pass
08e4:         
08e4:ad ed 1d     lda outOpt          ; do we have output?
08e7:f0 19        beq :listing        ; no, skip to listing (if enabled)
08e9:         
08e9:ae ee 1d     ldx outName         ; set up output filename
08ec:ac ef 1d     ldy outName+1
08ef:20 fa 13     jsr ioOpenDest      ; open
08f2:20 88 09     jsr asmError        ; poll for error
08f5:         
08f5:a9 0c        lda #<ioEmitBin     ; connect the output hose
08f7:8d d9 1d     sta emit
08fa:a9 16        lda #>ioEmitBin
08fc:8d da 1d     sta emit+1
08ff:4c 7a 08     jmp asmPass         ; go around again
0902:         
0902:         :listing
0902:20 8a 16     jsr ioClose         ; flush and close output or listing
0905:20 88 09     jsr asmError
0908:         
0908:a5 40        lda pass
090a:30 46        bmi asmDone         ; listed, we are done
090c:1a           inc
090d:09 80        ora #$80
090f:85 40        sta pass
0911:         
0911:ad ea 1d     lda listOpt
0914:f0 3c        beq asmDone         ; no listing, we are done
0916:         
0916:ae eb 1d     ldx listName        ; open the listing file  
0919:ac ec 1d     ldy listName+1
091c:         
091c:20 fa 13     jsr ioOpenDest      ; open
091f:20 88 09     jsr asmError        ; poll for error
0922:         
0922:a9 23        lda #<ioEmitListing
0924:8d d9 1d     sta emit
0927:a9 16        lda #>ioEmitListing
0929:8d da 1d     sta emit+1
092c:4c 7a 08     jmp asmPass
092f:         
092f:         askArgs:
092f:a9 3f        lda #'?
0931:20 d2 ff     jsr CHROUT
0934:a2 00        ldx #0
0936:86 25        stx optPtr
0938:         :loop
0938:20 cf ff     jsr CHRIN
093b:c9 0d        cmp #13
093d:f0 06        beq :done
093f:9d 00 bf     sta options,x
0942:e8           inx
0943:d0 f3        bne :loop
0945:         :done
0945:9e 00 bf     stz options,x
0948:a9 0d        lda #13             ; cr
094a:20 d2 ff     jsr CHROUT
094d:64 25        stz optPtr
094f:4c d2 09     jmp getOpt
0952:         
0952:         asmDone:
0952:a2 c2        ldx #<symendStr     ; "symend="
0954:a0 09        ldy #>symendStr
0956:20 50 17     jsr ioPrint
0959:a5 42        lda symEnd+1
095b:20 20 17     jsr ioPrintHex
095e:a5 41        lda symEnd
0960:20 20 17     jsr ioPrintHex
0963:a2 cc        ldx #<pcStr         ; "pc="
0965:a0 09        ldy #>pcStr
0967:20 50 17     jsr ioPrint
096a:ad e6 1d     lda pc+1
096d:20 20 17     jsr ioPrintHex
0970:ad e5 1d     lda pc
0973:20 20 17     jsr ioPrintHex
0976:a9 0d        lda #13
0978:20 d2 ff     jsr CHROUT
097b:         
097b:         exit:
097b:a2 00        ldx #0              ; zero out options buf on our way out
097d:         :fill
097d:9e 00 bf     stz options,x
0980:e8           inx
0981:d0 fa        bne :fill
0983:ae e1 1d     ldx asmSP           ; get top level stack pointer
0986:9a           txs
0987:60           rts                 ; exit out completely    
0988:         
0988:         asmError:
0988:a5 46        lda error           ; error non-z?
098a:f0 05        beq :fine
098c:20 3f 13     jsr ioError         ; print error
098f:80 ea        bra exit            ; abort
0991:         :fine
0991:60           rts
0992:         
0992:         usageStr:
0992:55 53 41 47 45 3a 20 58 
099a:41 53 4d 20 49 4e 50 55 
09a2:54 2e 41 53 4d 5b 3b 4f 
09aa:55 54 50 55 54 5d 5b 3b 
09b2:4c 49 53 54 49 4e 47 5d 
09ba:00           .db 'usage: xasm input.asm[;output][;listing]',0
09bb:         passStr:
09bb:0d 50 41 53 53 3a 00 
                 .db 13,'pass:',0
09c2:         symendStr:
09c2:0d 53 59 4d c5 4e 44 3d 
09ca:24 00        .db 13,'symEnd=$',0
09cc:         pcStr:
09cc:0d 50 43 3d 24 00 
                 .db 13,'pc=$',0
09d2:         
09d2:         ;
09d2:         ; returns next option in a/x/y
09d2:         getOpt:
09d2:a6 25        ldx optPtr
09d4:86 22        stx scratch
09d6:a0 00        ldy #0
09d8:         :loop
09d8:bd 00 bf     lda options,x
09db:f0 0c        beq :got
09dd:c9 0d        cmp #13         ; cr (shouldn't see this, but be defensive)
09df:f0 08        beq :got
09e1:e8           inx
09e2:c9 3b        cmp #';
09e4:f0 03        beq :got
09e6:c8           iny
09e7:d0 ef        bne :loop
09e9:         :got
09e9:98           tya
09ea:86 25        stx optPtr
09ec:a6 22        ldx scratch
09ee:a0 bf        ldy #>options
09f0:60           rts
09f1:          
09f1:             .in 'symtab.asm'
09f1:             .in 'zp.asm'
09f1:             .fi ; zpAsm
09f1:         
09f1:         
09f1:         ;
09f1:         ; initialize hash table
09f1:         symInit:
09f1:a9 00        lda #<symbols
09f3:85 41        sta symEnd
09f5:a9 24        lda #>symbols
09f7:85 42        sta symEnd+1
09f9:a2 00        ldx #0
09fb:         
09fb:         :fill
09fb:9e 00 23     stz hashTable,x
09fe:e8           inx
09ff:d0 fa        bne :fill
0a01:         
0a01:60           rts
0a02:         
0a02:         ; layout of a symbol entry:
0a02:         ; 00-01:    next (0 if end)
0a02:         ; 02-03:    scope (parent entry, or 0)
0a02:         ; 04:       caller status
0a02:         ; 05-06:    value
0a02:         
0a02:         ;
0a02:         ; enter or return existing symbol entry
0a02:         ; result in ptr
0a02:         symGet:
0a02:             ; string = strGet
0a02:             ; nptr = (string).symbols
0a02:20 63 0a     jsr strGet
0a05:a0 02        ldy #2
0a07:b1 27        lda (ptr),y
0a09:85 25        sta nptr
0a0b:a5 27        lda ptr
0a0d:85 23        sta string
0a0f:c8           iny
0a10:b1 27        lda (ptr),y
0a12:85 26        sta nptr+1
0a14:a5 28        lda ptr+1
0a16:85 24        sta string+1
0a18:         
0a18:         :next
0a18:20 07 0b     jsr ptrNext
0a1b:f0 0e        beq :notFound
0a1d:         
0a1d:             ; compare scope
0a1d:b1 27        lda (ptr),y
0a1f:c5 2d        cmp symScope
0a21:d0 f5        bne :next
0a23:c8           iny
0a24:b1 27        lda (ptr),y
0a26:c5 2e        cmp symScope+1
0a28:d0 ee        bne :next
0a2a:         
0a2a:             ; found!
0a2a:60           rts
0a2b:         
0a2b:         :notFound
0a2b:             ; push our scoped entry
0a2b:             ; ptr = symEnd
0a2b:             ; symEnd += 7
0a2b:a9 07        lda #7
0a2d:20 f3 0a     jsr symPush
0a30:         
0a30:         
0a30:             ; nptr = (string).symbols
0a30:             ; (string).symbols = ptr
0a30:a0 02        ldy #2
0a32:b1 23        lda (string),y
0a34:85 25        sta nptr
0a36:a5 27        lda ptr
0a38:91 23        sta (string),y
0a3a:c8           iny
0a3b:         
0a3b:b1 23        lda (string),y
0a3d:85 26        sta nptr+1
0a3f:a5 28        lda ptr+1
0a41:91 23        sta (string),y
0a43:         
0a43:             ; (ptr++)=nptr
0a43:             ; next linkage
0a43:a0 00        ldy #0
0a45:a5 25        lda nptr
0a47:91 27        sta (ptr),y
0a49:c8           iny
0a4a:         
0a4a:a5 26        lda nptr+1
0a4c:91 27        sta (ptr),y
0a4e:c8           iny
0a4f:         
0a4f:             ; (ptr++)=scope
0a4f:a5 2d        lda symScope
0a51:91 27        sta (ptr),y
0a53:c8           iny
0a54:         
0a54:a5 2e        lda symScope+1
0a56:91 27        sta (ptr),y
0a58:c8           iny
0a59:         
0a59:             ; (ptr++)=0
0a59:             ; zero out flags when creating
0a59:a9 00        lda #0
0a5b:91 27        sta (ptr),y
0a5d:c8           iny
0a5e:         
0a5e:             ; (++ptr)=non-zero
0a5e:             ; default value (forward decl) not presumed to be zero page
0a5e:c8           iny
0a5f:98           tya
0a60:91 27        sta (ptr),y
0a62:         
0a62:60           rts
0a63:         
0a63:         
0a63:         ; layout of a string entry:
0a63:         ; 00-01:    next (0 if end)
0a63:         ; 02-03:    symbols having this label
0a63:         ; 04-??:    counted string
0a63:         
0a63:         ;
0a63:         ; enter or return existing counted string
0a63:         ; result in ptr
0a63:         strGet:
0a63:             ; nptr = hash(symLabel)
0a63:20 e2 0a     jsr strHash
0a66:bd 00 23     lda hashTable,x
0a69:85 25        sta nptr
0a6b:bd 01 23     lda hashTable+1,x
0a6e:85 26        sta nptr+1
0a70:         
0a70:         :next
0a70:20 07 0b     jsr ptrNext
0a73:f0 13        beq :notFound
0a75:         
0a75:             ; compare string
0a75:             ; string = ptr+4
0a75:a5 27        lda ptr
0a77:18           clc
0a78:69 04        adc #4
0a7a:85 23        sta string
0a7c:a5 28        lda ptr+1
0a7e:69 00        adc #0
0a80:85 24        sta string+1
0a82:20 1e 0b     jsr strEqual
0a85:d0 e9        bne :next
0a87:         
0a87:             ; found/created, result in ptr
0a87:         :done
0a87:60           rts
0a88:         
0a88:         :notFound
0a88:             ; write new entry to head of list
0a88:             ; nptr = hashEntry
0a88:bd 00 23     lda hashTable,x
0a8b:85 25        sta nptr
0a8d:bd 01 23     lda hashTable+1,x
0a90:85 26        sta nptr+1
0a92:         
0a92:             ; hash = symEnd
0a92:             ; ptr = symEnd
0a92:             ; symEnd += 5 + symLength
0a92:a9 05        lda #5
0a94:20 f3 0a     jsr symPush
0a97:         
0a97:a5 27        lda ptr
0a99:9d 00 23     sta hashTable,x
0a9c:a5 28        lda ptr+1
0a9e:9d 01 23     sta hashTable+1,x
0aa1:         
0aa1:a5 2f        lda symLength
0aa3:20 f3 0a     jsr symPush
0aa6:         
0aa6:             ; (ptr++) = nptr
0aa6:bd 00 23     lda hashTable,x
0aa9:85 27        sta ptr
0aab:bd 01 23     lda hashTable+1,x
0aae:85 28        sta ptr+1
0ab0:             
0ab0:a0 00        ldy #0
0ab2:a5 25        lda nptr
0ab4:91 27        sta (ptr),y
0ab6:c8           iny
0ab7:a5 26        lda nptr+1
0ab9:91 27        sta (ptr),y
0abb:c8           iny
0abc:         
0abc:             ; (ptr++) = $0000
0abc:             ; (symbol entries pointer)
0abc:a9 00        lda #0
0abe:91 27        sta (ptr),y
0ac0:c8           iny
0ac1:91 27        sta (ptr),y
0ac3:c8           iny
0ac4:         
0ac4:             ; (ptr) = symLength
0ac4:a5 2f        lda symLength
0ac6:91 27        sta (ptr),y
0ac8:         
0ac8:             ; string = ptr+5
0ac8:a5 27        lda ptr
0aca:18           clc
0acb:69 05        adc #5
0acd:85 23        sta string
0acf:a5 28        lda ptr+1
0ad1:69 00        adc #0
0ad3:85 24        sta string+1
0ad5:         
0ad5:a0 00        ldy #0
0ad7:         :copy
0ad7:c4 2f        cpy symLength
0ad9:f0 ac        beq :done
0adb:b1 31        lda (symLabel),y
0add:91 23        sta (string),y
0adf:c8           iny
0ae0:d0 f5        bne :copy
0ae2:         
0ae2:         ;
0ae2:         ; compute hash value for counted string
0ae2:         strHash:
0ae2:a5 2f        lda symLength
0ae4:a8           tay
0ae5:18           clc
0ae6:         :loop
0ae6:f0 08        beq :done
0ae8:88           dey
0ae9:2a           rol                 ; c << output << c
0aea:51 31        eor (symLabel),y    ; output = output xor byte
0aec:c8           iny
0aed:88           dey
0aee:d0 f6        bne :loop
0af0:         
0af0:             ; truncate to 7 bit
0af0:         :done
0af0:0a           asl
0af1:aa           tax                 ; result in index form
0af2:60           rts
0af3:         
0af3:         ;
0af3:         ; push symEnd by A bytes
0af3:         ; ptr=symEnd before increment
0af3:         symPush:
0af3:85 22        sta scratch
0af5:a5 41        lda symEnd
0af7:85 27        sta ptr
0af9:18           clc
0afa:65 22        adc scratch
0afc:85 41        sta symEnd
0afe:a5 42        lda symEnd+1
0b00:85 28        sta ptr+1
0b02:69 00        adc #0
0b04:85 42        sta symEnd+1
0b06:60           rts
0b07:         
0b07:         ;
0b07:         ; ptr=nptr, nptr=(ptr)
0b07:         ; Z if nptrH=0
0b07:         ; Y=2 otherwise
0b07:         ptrNext:
0b07:a5 26        lda nptr+1
0b09:f0 12        beq :out            ; nptrH=0
0b0b:85 28        sta ptr+1
0b0d:a5 25        lda nptr
0b0f:85 27        sta ptr
0b11:a0 00        ldy #0
0b13:b1 27        lda (ptr),y
0b15:85 25        sta nptr
0b17:c8           iny
0b18:b1 27        lda (ptr),y         ; Z=0
0b1a:85 26        sta nptr+1
0b1c:c8           iny
0b1d:         :out
0b1d:60           rts
0b1e:         
0b1e:         ;
0b1e:         ; compare counted string at (string) against symLength/symLabel
0b1e:         ; for equality, Z=1 if so
0b1e:         strEqual:
0b1e:a0 00        ldy #0
0b20:b1 23        lda (string),y
0b22:c5 2f        cmp symLength
0b24:d0 0d        bne :out
0b26:         :loop
0b26:c4 2f        cpy symLength
0b28:f0 09        beq :out
0b2a:b1 31        lda (symLabel),y
0b2c:c8           iny
0b2d:d1 23        cmp (string),y
0b2f:d0 02        bne :out
0b31:f0 f3        beq :loop
0b33:         :out
0b33:60           rts
0b34:         
0b34:             .in 'eval.asm'
0b34:             .in 'zp.asm'
0b34:             .fi ; zpAsm
0b34:         
0b34:         
0b34:         esInit  = 0
0b34:         esOp    = 1
0b34:         
0b34:         
0b34:         eDone:
0b34:             ; err if not in esOp state
0b34:18           clc
0b35:a5 3c        lda eState
0b37:f0 01        beq :error
0b39:60           rts
0b3a:         :error
0b3a:38           sec
0b3b:60           rts
0b3c:         
0b3c:         ;
0b3c:         ; normalize petscii in A into lineBuf,x
0b3c:         ePet:
0b3c:85 22        sta scratch
0b3e:29 e0        and #$e0
0b40:c9 60        cmp #$60        ; %011xxxxx -> %110xxxxx
0b42:d0 08        bne :nopet
0b44:a5 22        lda scratch
0b46:49 a0        eor #$a0
0b48:9d 00 22     sta lineBuf,x
0b4b:60           rts
0b4c:         :nopet
0b4c:a5 22        lda scratch
0b4e:60           rts
0b4f:         
0b4f:         ;
0b4f:         ; evaluate expression at lineBuf,x
0b4f:         eEval:
0b4f:64 3c        stz eState
0b51:64 3b        stz eOp
0b53:64 35        stz arg
0b55:64 36        stz arg+1
0b57:20 dd 0d     jsr ePush
0b5a:         
0b5a:         :loop
0b5a:bd 00 22     lda lineBuf,x
0b5d:f0 d5        beq eDone       ; eof
0b5f:c9 2c        cmp #',
0b61:f0 d1        beq eDone
0b63:c9 3b        cmp #';
0b65:f0 cd        beq eDone
0b67:c9 29        cmp #')
0b69:f0 c9        beq eDone
0b6b:         
0b6b:a4 3c        ldy eState
0b6d:d0 26        bne :op
0b6f:         
0b6f:         :init
0b6f:20 11 0e     jsr eIsDec
0b72:b0 4f        bcs :dec
0b74:20 42 0e     jsr eIsAlpha
0b77:b0 6b        bcs :tosym
0b79:c9 3a        cmp #':
0b7b:f0 67        beq :tosym
0b7d:c9 25        cmp #'%
0b7f:f0 58        beq :bin
0b81:c9 24        cmp #'$
0b83:f0 49        beq :hex
0b85:c9 28        cmp #'(
0b87:f0 65        beq :sub
0b89:c9 2a        cmp #'*
0b8b:f0 71        beq :pc
0b8d:c9 27        cmp #''
0b8f:f0 7a        beq :char
0b91:             
0b91:a0 80        ldy #$80        ; indicate unary
0b93:84 3b        sty eOp
0b95:             ; fall thru
0b95:         
0b95:         :op
0b95:e8           inx
0b96:         
0b96:29 7f        and #$7f        ; normalize petscii whitespace (shift+space)
0b98:c9 21        cmp #33         ; whitespace?
0b9a:90 be        bcc :loop
0b9c:         
0b9c:05 3b        ora eOp         ; push unary or binary op
0b9e:85 3b        sta eOp
0ba0:         
0ba0:c9 3e        cmp #'>
0ba2:f0 0a        beq :optwo
0ba4:             
0ba4:c9 3c        cmp #'<
0ba6:f0 06        beq :optwo
0ba8:         
0ba8:c9 21        cmp #'!
0baa:f0 02        beq :optwo
0bac:             
0bac:80 0e        bra :opone
0bae:         
0bae:         :optwo
0bae:bd 00 22     lda lineBuf,x
0bb1:c9 3d        cmp #'=
0bb3:d0 07        bne :opone 
0bb5:         
0bb5:e8           inx             ; this is >=, <=, or !=
0bb6:a9 40        lda #$40        ; add 64 to indicate = suffix
0bb8:05 3b        ora eOp
0bba:85 3b        sta eOp
0bbc:         
0bbc:         :opone
0bbc:20 dd 0d     jsr ePush
0bbf:64 3c        stz eState
0bc1:80 97        bra :loop
0bc3:         
0bc3:         :dec
0bc3:20 11 0e     jsr eIsDec
0bc6:90 57        bcc :term       ; not a decimal digit?
0bc8:20 7c 0d     jsr eDec
0bcb:e8           inx
0bcc:d0 f5        bne :dec
0bce:         
0bce:         :hex
0bce:e8           inx
0bcf:20 27 0e     jsr eIsHex
0bd2:90 4b        bcc :term       ; not a hex digit?
0bd4:20 af 0d     jsr eHex
0bd7:80 f5        bra :hex
0bd9:             
0bd9:         :bin
0bd9:e8           inx
0bda:20 38 0e     jsr eIsBin
0bdd:d0 40        bne :term       ; not a binary digit?
0bdf:20 d1 0d     jsr eBin
0be2:80 f5        bra :bin
0be4:         
0be4:         :tosym
0be4:86 3d        stx labelPtr    ; note where it starts
0be6:             
0be6:         :sym
0be6:20 5a 0e     jsr eIsSym
0be9:d0 2b        bne :termsym
0beb:e8           inx
0bec:80 f8        bra :sym
0bee:         
0bee:         :sub
0bee:e8           inx             ; skip '('
0bef:20 4f 0b     jsr eEval       ; evaluate subexpression
0bf2:b0 39        bcs :out
0bf4:bd 00 22     lda lineBuf,x
0bf7:c9 29        cmp #')
0bf9:d0 24        bne :term
0bfb:e8           inx             ; consume ')'
0bfc:80 21        bra :term
0bfe:         
0bfe:         :pc
0bfe:e8           inx             ; skip '*'
0bff:ad e5 1d     lda pc          ; arg=pc
0c02:85 35        sta arg
0c04:ad e6 1d     lda pc+1
0c07:85 36        sta arg+1
0c09:80 14        bra :term
0c0b:         
0c0b:         :char
0c0b:e8           inx             ; skip '
0c0c:bd 00 22     lda lineBuf,x   ; arg=literal character
0c0f:e8           inx             ; consume
0c10:85 35        sta arg
0c12:64 36        stz arg+1
0c14:80 09        bra :term
0c16:         
0c16:         :termsym
0c16:86 29        stx labelEnd
0c18:20 6a 0e     jsr eResolveSym ; resolve label value into arg
0c1b:b0 10        bcs :out
0c1d:a6 29        ldx labelEnd
0c1f:             ; fall thru
0c1f:         
0c1f:         :term
0c1f:20 2e 0c     jsr eExec       ; pop and execute what we have so far
0c22:b0 09        bcs :out
0c24:a9 01        lda #esOp       ; now in op state
0c26:85 3c        sta eState
0c28:64 3b        stz eOp         ; clear op, and not unary
0c2a:4c 5a 0b     jmp :loop
0c2d:         
0c2d:         :out    
0c2d:60           rts
0c2e:         
0c2e:         ;
0c2e:         ; exec term
0c2e:         eExec:
0c2e:20 38 0c     jsr eExecOne
0c31:b0 04        bcs :out
0c33:24 3b        bit eOp
0c35:30 f7        bmi eExec
0c37:         :out
0c37:60           rts
0c38:         
0c38:         eExecOne:
0c38:20 fa 0d     jsr ePop
0c3b:a5 3b        lda eOp
0c3d:f0 63        beq :assign
0c3f:c9 2b        cmp #'+
0c41:f0 61        beq :add
0c43:c9 2d        cmp #'-
0c45:f0 6c        beq :sub
0c47:c9 ad        cmp #$80+'- ; unary -
0c49:f0 68        beq :sub
0c4b:c9 26        cmp #'&
0c4d:f0 73        beq :and
0c4f:c9 5e        cmp #'^
0c51:f0 2e        beq :xorb
0c53:c9 2e        cmp #'.
0c55:f0 79        beq :or
0c57:c9 a1        cmp #$80+'! ; unary '!'
0c59:f0 29        beq :notb
0c5b:c9 bc        cmp #$80+'< ; unary '<'
0c5d:f0 28        beq :lob
0c5f:c9 be        cmp #$80+'> ; unary '>'
0c61:f0 27        beq :hib
0c63:c9 3d        cmp #'=
0c65:f0 26        beq :eqb
0c67:c9 3e        cmp #'>
0c69:f0 25        beq :gtb
0c6b:c9 3c        cmp #'<
0c6d:f0 24        beq :ltb
0c6f:c9 7e        cmp #$40+'> ; >=
0c71:f0 23        beq :geb
0c73:c9 7c        cmp #$40+'< ; <=
0c75:f0 22        beq :leb
0c77:c9 61        cmp #$40+'! ; !=
0c79:f0 21        beq :neb
0c7b:c9 25        cmp #'%
0c7d:f0 20        beq :alignb
0c7f:38           sec
0c80:60           rts
0c81:         
0c81:         :xorb
0c81:4c de 0c     jmp :xor
0c84:         
0c84:         :notb
0c84:4c ec 0c     jmp :not
0c87:         
0c87:         :lob
0c87:4c fe 0c     jmp :lo
0c8a:         
0c8a:         :hib
0c8a:4c fa 0c     jmp :hi
0c8d:         
0c8d:         :eqb
0c8d:4c 02 0d     jmp :eq
0c90:         
0c90:         :gtb
0c90:4c 10 0d     jmp :gt
0c93:         
0c93:         :ltb
0c93:4c 20 0d     jmp :lt
0c96:         
0c96:         :geb
0c96:4c 30 0d     jmp :ge
0c99:         
0c99:         :leb
0c99:4c 40 0d     jmp :le
0c9c:         
0c9c:         :neb
0c9c:4c 50 0d     jmp :ne
0c9f:         
0c9f:         :alignb
0c9f:4c 6a 0d     jmp :align
0ca2:         
0ca2:         ;
0ca2:         ; arg=arg
0ca2:         :assign
0ca2:18           clc
0ca3:60           rts
0ca4:         
0ca4:         ;
0ca4:         ; arg+=term
0ca4:         :add
0ca4:a5 35        lda arg
0ca6:18           clc
0ca7:65 37        adc term
0ca9:85 35        sta arg
0cab:a5 36        lda arg+1
0cad:65 38        adc term+1
0caf:85 36        sta arg+1
0cb1:18           clc
0cb2:60           rts
0cb3:         
0cb3:         ;
0cb3:         ; arg=term-arg
0cb3:         :sub
0cb3:a5 37        lda term
0cb5:38           sec
0cb6:e5 35        sbc arg
0cb8:85 35        sta arg
0cba:a5 38        lda term+1
0cbc:e5 36        sbc arg+1
0cbe:85 36        sta arg+1
0cc0:18           clc
0cc1:60           rts
0cc2:         
0cc2:         ;
0cc2:         ; arg&=term
0cc2:         :and
0cc2:a5 35        lda arg
0cc4:25 37        and term
0cc6:85 35        sta arg
0cc8:a5 36        lda arg+1
0cca:25 38        and term+1
0ccc:85 36        sta arg+1
0cce:18           clc
0ccf:60           rts
0cd0:         
0cd0:         ;
0cd0:         ; arg.=term
0cd0:         :or
0cd0:a5 35        lda arg
0cd2:05 37        ora term
0cd4:85 35        sta arg
0cd6:a5 36        lda arg+1
0cd8:05 38        ora term+1
0cda:85 36        sta arg+1
0cdc:18           clc
0cdd:60           rts
0cde:         
0cde:         ;
0cde:         ; arg^=term
0cde:         :xor
0cde:a5 35        lda arg
0ce0:45 37        eor term
0ce2:85 35        sta arg
0ce4:a5 36        lda arg+1
0ce6:45 38        eor term+1
0ce8:85 36        sta arg+1
0cea:18           clc
0ceb:60           rts
0cec:         
0cec:         ;
0cec:         ; arg=!arg
0cec:         :not
0cec:a5 35        lda arg
0cee:49 ff        eor #$ff
0cf0:85 35        sta arg
0cf2:a5 36        lda arg+1
0cf4:49 ff        eor #$ff
0cf6:85 36        sta arg+1
0cf8:18           clc
0cf9:60           rts
0cfa:         
0cfa:         ;
0cfa:         ; arg=>arg
0cfa:         :hi
0cfa:a5 36        lda arg+1
0cfc:85 35        sta arg
0cfe:             ; fall thru
0cfe:         
0cfe:         ;
0cfe:         ; arg=<arg
0cfe:         :lo
0cfe:64 36        stz arg+1
0d00:18           clc
0d01:60           rts
0d02:         
0d02:         ;
0d02:         ; arg=term?
0d02:         :eq
0d02:a5 35        lda arg
0d04:c5 37        cmp term
0d06:d0 5c        bne :false
0d08:a5 36        lda arg+1
0d0a:c5 38        cmp term+1
0d0c:d0 56        bne :false
0d0e:80 4c        bra :true
0d10:         
0d10:         ;
0d10:         ; term>arg?
0d10:         :gt
0d10:a5 36        lda arg+1
0d12:c5 38        cmp term+1
0d14:90 46        bcc :true
0d16:d0 4c        bne :false
0d18:a5 35        lda arg
0d1a:c5 37        cmp term
0d1c:90 3e        bcc :true
0d1e:80 44        bra :false
0d20:         
0d20:         ;
0d20:         ; term<arg?
0d20:         :lt
0d20:a5 38        lda term+1
0d22:c5 36        cmp arg+1
0d24:90 36        bcc :true
0d26:d0 3c        bne :false
0d28:a5 37        lda term
0d2a:c5 35        cmp arg
0d2c:90 2e        bcc :true
0d2e:80 34        bra :false
0d30:         
0d30:         ;
0d30:         ; term>=arg?
0d30:         :ge
0d30:a5 38        lda term+1
0d32:c5 36        cmp arg+1
0d34:90 2e        bcc :false
0d36:d0 24        bne :true
0d38:a5 37        lda term
0d3a:c5 35        cmp arg
0d3c:90 26        bcc :false
0d3e:80 1c        bra :true
0d40:         
0d40:         ; term<=arg?
0d40:         :le
0d40:a5 36        lda arg+1
0d42:c5 38        cmp term+1
0d44:90 1e        bcc :false
0d46:d0 14        bne :true
0d48:a5 35        lda arg
0d4a:c5 37        cmp term
0d4c:90 16        bcc :false
0d4e:80 0c        bra :true
0d50:         
0d50:         ; term!=arg?
0d50:         :ne
0d50:a5 36        lda arg+1
0d52:c5 38        cmp term+1
0d54:d0 06        bne :true
0d56:a5 35        lda arg
0d58:c5 37        cmp term
0d5a:f0 08        beq :false
0d5c:         
0d5c:         :true
0d5c:a9 ff        lda #$ff
0d5e:85 35        sta arg
0d60:85 36        sta arg+1
0d62:18           clc
0d63:60           rts
0d64:         
0d64:         :false
0d64:64 35        stz arg
0d66:64 36        stz arg+1
0d68:18           clc
0d69:60           rts
0d6a:         
0d6a:         ; arg=term%arg
0d6a:         :align              ; limited to $100 max
0d6a:c6 35        dec arg
0d6c:a5 35        lda arg
0d6e:25 37        and term
0d70:45 35        eor arg
0d72:1a           inc
0d73:25 35        and arg
0d75:85 35        sta arg
0d77:64 36        stz arg+1
0d79:4c a4 0c     jmp :add
0d7c:         
0d7c:         ;
0d7c:         ; add decimal digit in lineBuf,x to arg
0d7c:         eDec:
0d7c:a5 35        lda arg         ; scratch=arg*8
0d7e:0a           asl
0d7f:85 22        sta scratch
0d81:a5 36        lda arg+1
0d83:2a           rol
0d84:85 23        sta scratch+1
0d86:         
0d86:06 22        asl scratch
0d88:26 23        rol scratch+1
0d8a:06 22        asl scratch
0d8c:26 23        rol scratch+1
0d8e:         
0d8e:06 35        asl arg         ; arg=arg*2
0d90:26 36        rol arg+1
0d92:         
0d92:a5 35        lda arg         ; arg=arg+scratch
0d94:18           clc
0d95:65 22        adc scratch
0d97:85 35        sta arg
0d99:a5 36        lda arg+1
0d9b:65 23        adc scratch+1
0d9d:85 36        sta arg+1
0d9f:         
0d9f:bd 00 22     lda lineBuf,x
0da2:38           sec
0da3:e9 30        sbc #'0
0da5:18           clc
0da6:65 35        adc arg
0da8:85 35        sta arg
0daa:90 02        bcc :out
0dac:e6 36        inc arg+1
0dae:         :out
0dae:60           rts
0daf:         
0daf:         ;
0daf:         ; add hex digit in lineBuf,x to arg
0daf:         eHex:
0daf:06 35        asl arg
0db1:26 36        rol arg+1
0db3:06 35        asl arg
0db5:26 36        rol arg+1
0db7:06 35        asl arg
0db9:26 36        rol arg+1
0dbb:06 35        asl arg
0dbd:26 36        rol arg+1
0dbf:         
0dbf:bd 00 22     lda lineBuf,x
0dc2:38           sec
0dc3:e9 3a        sbc #'9+1
0dc5:90 03        bcc :digit
0dc7:e9 07        sbc #7
0dc9:18           clc
0dca:         :digit
0dca:69 0a        adc #10
0dcc:         
0dcc:05 35        ora arg
0dce:85 35        sta arg
0dd0:60           rts
0dd1:         
0dd1:         ;
0dd1:         ; add binary digit in lineBuf,x to arg
0dd1:         eBin:
0dd1:06 35        asl arg
0dd3:26 36        rol arg+1
0dd5:38           sec
0dd6:e9 30        sbc #'0
0dd8:05 35        ora arg
0dda:85 35        sta arg
0ddc:60           rts
0ddd:         
0ddd:         ;
0ddd:         ; push arg,op,state
0ddd:         ePush:
0ddd:a4 43        ldy ePtr
0ddf:         
0ddf:a5 3b        lda eOp
0de1:99 00 21     sta eStack,y
0de4:88           dey
0de5:         
0de5:a5 36        lda arg+1
0de7:99 00 21     sta eStack,y
0dea:88           dey
0deb:         
0deb:a5 35        lda arg
0ded:99 00 21     sta eStack,y
0df0:88           dey
0df1:         
0df1:84 43        sty ePtr
0df3:         
0df3:64 3b        stz eOp
0df5:64 35        stz arg
0df7:64 36        stz arg+1
0df9:60           rts
0dfa:         
0dfa:         ;
0dfa:         ; pop term,op,state
0dfa:         ePop:
0dfa:a4 43        ldy ePtr
0dfc:         
0dfc:c8           iny
0dfd:b9 00 21     lda eStack,y
0e00:85 37        sta term
0e02:         
0e02:c8           iny
0e03:b9 00 21     lda eStack,y
0e06:85 38        sta term+1
0e08:         
0e08:c8           iny
0e09:b9 00 21     lda eStack,y
0e0c:85 3b        sta eOp
0e0e:         
0e0e:84 43        sty ePtr
0e10:60           rts
0e11:         
0e11:         ;
0e11:         ; test if lineBuf,x is decimal digit
0e11:         ; C=1 if so
0e11:         eIsDec:
0e11:bd 00 22     lda lineBuf,x
0e14:c9 3a        cmp #'9+1
0e16:b0 03        bcs eIsNot
0e18:         
0e18:c9 30        cmp #'0
0e1a:60           rts
0e1b:         
0e1b:         eIsNot:
0e1b:18           clc
0e1c:60           rts
0e1d:         
0e1d:         ;
0e1d:         ; test if lineBuf,x is octal digit
0e1d:         ; C=1 if so, also returns char in A
0e1d:         eIsOct:
0e1d:bd 00 22     lda lineBuf,x
0e20:c9 38        cmp #'7+1
0e22:b0 f7        bcs eIsNot
0e24:         
0e24:c9 30        cmp #'0
0e26:60           rts
0e27:         
0e27:         ;
0e27:         ; test if lineBuf,x is hex digit
0e27:         ; C=1 if so
0e27:         ; side effect: uppercase normalized
0e27:         eIsHex:
0e27:20 11 0e     jsr eIsDec
0e2a:b0 0b        bcs :out
0e2c:20 3c 0b     jsr ePet
0e2f:29 7f        and #$7f
0e31:         
0e31:c9 47        cmp #'f+1
0e33:b0 e6        bcs eIsNot
0e35:         
0e35:c9 41        cmp #'a
0e37:         :out
0e37:60           rts
0e38:         
0e38:         ;
0e38:         ; test if lineBuf,x is binary digit
0e38:         ; Z=1 if so
0e38:         eIsBin:
0e38:bd 00 22     lda lineBuf,x
0e3b:c9 31        cmp #'1
0e3d:f0 02        beq :out
0e3f:c9 30        cmp #'0
0e41:         :out
0e41:60           rts
0e42:         
0e42:         ;
0e42:         ; test if lineBuf,X is alpha
0e42:         ; C=1 if so
0e42:         eIsAlpha:
0e42:bd 00 22     lda lineBuf,x
0e45:20 3c 0b     jsr ePet
0e48:         
0e48:c9 db        cmp #'z+128+1   ; 'Z'
0e4a:b0 cf        bcs eIsNot      ; > 'Z'
0e4c:         
0e4c:c9 41        cmp #'a
0e4e:90 09        bcc :out        ; < 'a'
0e50:         
0e50:c9 c1        cmp #'a+128     ; 'A'
0e52:b0 05        bcs :out        ; >= 'A' and <= 'Z'
0e54:         
0e54:c9 5b        cmp #'z+1
0e56:b0 c3        bcs eIsNot      ; > 'z'
0e58:         
0e58:38           sec
0e59:         :out
0e59:60           rts
0e5a:         
0e5a:         ;
0e5a:         ; test if lineBuf,x is a valid symbol character
0e5a:         ; Z=1 if so
0e5a:         eIsSym:
0e5a:20 42 0e     jsr eIsAlpha
0e5d:b0 08        bcs :yes
0e5f:20 11 0e     jsr eIsDec
0e62:b0 03        bcs :yes
0e64:c9 3a        cmp #':
0e66:60           rts
0e67:         :yes
0e67:89 00        bit #0          ; set zero
0e69:60           rts
0e6a:         
0e6a:         ;
0e6a:         ; resolve label from lineBuf into arg
0e6a:         eResolveSym:
0e6a:a5 2d        lda symScope    ; note our current scope
0e6c:8d f0 1d     sta tScope
0e6f:a5 2e        lda symScope+1
0e71:8d f1 1d     sta tScope+1
0e74:         
0e74:a4 3d        ldy labelPtr    ; start of label sequence
0e76:b9 00 22     lda lineBuf,y
0e79:c9 3a        cmp #':
0e7b:f0 04        beq :loop
0e7d:         
0e7d:64 2d        stz symScope    ; global scope
0e7f:64 2e        stz symScope+1
0e81:         
0e81:         :loop
0e81:20 bc 0e     jsr :next
0e84:a5 2f        lda symLength
0e86:f0 0f        beq :skip       ; empty label in sequence means do not adjust scope
0e88:         
0e88:84 2b        sty emitY
0e8a:20 02 0a     jsr symGet
0e8d:a4 2b        ldy emitY
0e8f:         
0e8f:a5 27        lda ptr
0e91:85 2d        sta symScope
0e93:a5 28        lda ptr+1
0e95:85 2e        sta symScope+1
0e97:         
0e97:         :skip
0e97:c4 29        cpy labelEnd
0e99:d0 e6        bne :loop
0e9b:         
0e9b:         :done
0e9b:18           clc
0e9c:a0 04        ldy #4
0e9e:b1 27        lda (ptr),y     ; no forward reference in pass >0
0ea0:d0 05        bne :fine
0ea2:a5 40        lda pass
0ea4:f0 01        beq :fine
0ea6:38           sec             ; set error
0ea7:         
0ea7:         :fine
0ea7:c8           iny             ; symbol value in arg
0ea8:b1 27        lda (ptr),y
0eaa:85 35        sta arg
0eac:c8           iny
0ead:b1 27        lda (ptr),y
0eaf:85 36        sta arg+1
0eb1:         
0eb1:ad f0 1d     lda tScope      ; put scope back
0eb4:85 2d        sta symScope
0eb6:ad f1 1d     lda tScope+1
0eb9:85 2e        sta symScope+1
0ebb:         
0ebb:60           rts
0ebc:         
0ebc:         :next
0ebc:98           tya             ; point symLabel at lineBuf+y
0ebd:18           clc
0ebe:69 00        adc #<lineBuf
0ec0:85 31        sta symLabel
0ec2:a9 00        lda #0
0ec4:69 22        adc #>lineBuf
0ec6:85 32        sta symLabel+1
0ec8:64 2f        stz symLength   ; reset length=0
0eca:         
0eca:         :search
0eca:b9 00 22     lda lineBuf,y
0ecd:c8           iny
0ece:c9 3a        cmp #':
0ed0:f0 06        beq :out        ; colon terminate at scope seperator
0ed2:e6 2f        inc symLength
0ed4:c4 29        cpy labelEnd
0ed6:d0 f2        bne :search
0ed8:         :out
0ed8:60           rts
0ed9:         
0ed9:             .in 'line.asm'
0ed9:             .in 'zp.asm'
0ed9:             .fi ; zpAsm
0ed9:         
0ed9:             .in 'mode.asm'
0ed9:             .fi ; modeAsm
0ed9:         
0ed9:         
0ed9:         
0ed9:         ;
0ed9:         ; assembles lineBuf
0ed9:         lineAsm:
0ed9:ba           tsx
0eda:8e e2 1d     stx lineSP
0edd:64 35        stz arg
0edf:64 36        stz arg+1
0ee1:a2 00        ldx #0
0ee3:         
0ee3:         :start
0ee3:bd 00 22     lda lineBuf,x
0ee6:20 3c 0b     jsr ePet
0ee9:20 5a 0e     jsr eIsSym
0eec:d0 03        bne :label
0eee:e8           inx
0eef:d0 f2        bne :start
0ef1:         :label
0ef1:64 27        stz ptr         ; assume no label yet
0ef3:64 28        stz ptr+1
0ef5:         
0ef5:86 29        stx labelEnd
0ef7:e0 00        cpx #0          ; no label
0ef9:f0 07        beq :post
0efb:         
0efb:24 44        bit lineIfs     ; test if we are if'd out
0efd:30 03        bmi :post
0eff:         
0eff:20 e2 10     jsr linePinLabel
0f02:         
0f02:         :post
0f02:20 c9 12     jsr lineNextTokenExit
0f05:         
0f05:c9 3d        cmp #'=
0f07:d0 1e        bne :op
0f09:         
0f09:24 44        bit lineIfs
0f0b:30 5f        bmi :opdone
0f0d:         
0f0d:e8           inx             ; skip '='
0f0e:a5 27        lda ptr
0f10:85 39        sta assign      ; assign=ptr
0f12:a5 28        lda ptr+1
0f14:f0 23        beq :assignError
0f16:85 3a        sta assign+1
0f18:         
0f18:20 f3 12     jsr lineEval    ; eval rhs
0f1b:         
0f1b:a0 05        ldy #5          ; store evaluated result
0f1d:a5 35        lda arg
0f1f:91 39        sta (assign),y
0f21:c8           iny
0f22:a5 36        lda arg+1
0f24:91 39        sta (assign),y
0f26:60           rts
0f27:         
0f27:         :op
0f27:bd 00 22     lda lineBuf,x
0f2a:c9 2a        cmp #'*
0f2c:f0 15        beq :star
0f2e:c9 2e        cmp #'.
0f30:f0 3b        beq :dot
0f32:         
0f32:24 44        bit lineIfs
0f34:30 36        bmi :opdone     ; if'd out
0f36:         
0f36:4c 3d 11     jmp lineIsn
0f39:         
0f39:         :assignError
0f39:a9 0a        lda #errors:assign
0f3b:85 46        sta error
0f3d:60           rts
0f3e:         
0f3e:         :backwardError
0f3e:a9 06        lda #errors:backward
0f40:85 46        sta error
0f42:60           rts
0f43:         
0f43:         :star
0f43:e8           inx             ; skip '*'
0f44:20 c9 12     jsr lineNextTokenExit
0f47:c9 3d        cmp #'=
0f49:d0 21        bne :opdone
0f4b:e8           inx             ; consume '='
0f4c:e6 40        inc pass        ; cannot be forward reference
0f4e:20 f3 12     jsr lineEval
0f51:c6 40        dec pass
0f53:         
0f53:         :starloop
0f53:a5 36        lda arg+1
0f55:cd e6 1d     cmp pc+1
0f58:90 e4        bcc :backwardError
0f5a:d0 09        bne :stardo
0f5c:a5 35        lda arg
0f5e:cd e5 1d     cmp pc
0f61:90 db        bcc :backwardError
0f63:f0 07        beq :stardone
0f65:         :stardo
0f65:a9 00        lda #0
0f67:20 32 11     jsr lineEmit    ; emit zeros until desired pc
0f6a:80 e7        bra :starloop
0f6c:         
0f6c:         :stardone
0f6c:         :opdone
0f6c:60           rts
0f6d:         
0f6d:         :dot
0f6d:e8           inx             ; skip '.'
0f6e:bd 01 22     lda lineBuf+1,x
0f71:a8           tay             ; second char in Y
0f72:bd 00 22     lda lineBuf,x   ; first char in A
0f75:e8           inx
0f76:e8           inx             ; skip the two (if not present, we will err anyway)
0f77:         
0f77:c9 45        cmp #'e
0f79:f0 19        beq :E
0f7b:c9 46        cmp #'f
0f7d:f0 1f        beq :F
0f7f:c9 49        cmp #'i
0f81:f0 27        beq :I
0f83:         
0f83:24 44        bit lineIfs
0f85:30 e5        bmi :opdone     ; if'd out
0f87:         
0f87:c9 4f        cmp #'o
0f89:f0 19        beq :O
0f8b:c9 44        cmp #'d
0f8d:f0 2d        beq :D
0f8f:             ; fall thru
0f8f:         
0f8f:         :dotOpError
0f8f:a9 0c        lda #errors:dotOp
0f91:85 46        sta error
0f93:60           rts
0f94:         
0f94:         :E
0f94:c0 49        cpy #'i
0f96:f0 5b        beq :EI
0f98:c0 4c        cpy #'l
0f9a:f0 43        beq :EL
0f9c:80 f1        bra :dotOpError
0f9e:         
0f9e:         :F
0f9e:c0 49        cpy #'i
0fa0:f0 73        beq :FI
0fa2:80 eb        bra :dotOpError
0fa4:         
0fa4:         :O
0fa4:c0 52        cpy #'r
0fa6:f0 22        beq :ORb
0fa8:80 e5        bra :dotOpError
0faa:         
0faa:         :I
0faa:c0 46        cpy #'f
0fac:f0 1f        beq :IFb
0fae:             
0fae:24 44        bit lineIfs
0fb0:30 ba        bmi :opdone     ; if'd out
0fb2:             
0fb2:c0 4e        cpy #'n
0fb4:f0 1a        beq :INb
0fb6:c0 42        cpy #'b
0fb8:f0 19        beq :IBb
0fba:80 d3        bra :dotOpError
0fbc:           
0fbc:         :D
0fbc:c0 42        cpy #'b
0fbe:f0 16        beq :DBb
0fc0:c0 57        cpy #'w
0fc2:f0 15        beq :DWb
0fc4:c0 46        cpy #'f
0fc6:f0 14        beq :DFb
0fc8:80 c5        bra :dotOpError
0fca:         
0fca:         :ORb
0fca:4c 9d 10     jmp :OR
0fcd:         
0fcd:         :IFb
0fcd:4c bd 10     jmp :IF
0fd0:         
0fd0:         :INb
0fd0:4c ae 10     jmp :IN
0fd3:             
0fd3:         :IBb
0fd3:4c b4 10     jmp :IB
0fd6:             
0fd6:         :DBb
0fd6:4c 1c 10     jmp :DB
0fd9:             
0fd9:         :DWb
0fd9:4c 46 10     jmp :DW
0fdc:         
0fdc:         :DFb
0fdc:4c 5f 10     jmp :DF
0fdf:         
0fdf:         :EL
0fdf:24 45        bit lineIfd     ; have we chosen our destiny
0fe1:10 07        bpl :else
0fe3:a9 80        lda #$80        ; prior destiny has already been set
0fe5:04 44        tsb lineIfs
0fe7:4c db 12     jmp lineAssertEnd
0fea:         
0fea:         :else
0fea:a5 44        lda lineIfs     ; flip top if bit
0fec:49 80        eor #$80
0fee:85 44        sta lineIfs
0ff0:4c db 12     jmp lineAssertEnd
0ff3:         
0ff3:         :EI
0ff3:20 e7 12     jsr lineAssertToken
0ff6:         
0ff6:24 45        bit lineIfd     ; have we chosen our destiny
0ff8:10 05        bpl :elseif
0ffa:a9 80        lda #$80        ; stay false
0ffc:04 44        tsb lineIfs     ; prior destiny has already been set
0ffe:60           rts
0fff:         
0fff:         :elseif
0fff:20 f3 12     jsr lineEval
1002:20 25 11     jsr lineTruth
1005:06 44        asl lineIfs
1007:a5 36        lda arg+1       ; top of ifs stack becomes condition
1009:29 80        and #$80
100b:04 45        tsb lineIfd     ; destiny set
100d:49 80        eor #$80
100f:0a           asl
1010:66 44        ror lineIfs
1012:4c db 12     jmp lineAssertEnd
1015:         
1015:         :FI
1015:06 44        asl lineIfs     ; pop if stack
1017:06 45        asl lineIfd     ; pop destiny stack
1019:4c db 12     jmp lineAssertEnd
101c:         
101c:         :DB
101c:64 35        stz arg
101e:20 c9 12     jsr lineNextTokenExit
1021:c9 27        cmp #''
1023:f0 11        beq :string
1025:c9 2c        cmp #',
1027:f0 0a        beq :DBcomma
1029:         
1029:20 f3 12     jsr lineEval
102c:a5 35        lda arg         ; send it
102e:20 32 11     jsr lineEmit
1031:         
1031:80 e9        bra :DB
1033:         
1033:         :DBcomma
1033:e8           inx             ; consume ',' ready for next
1034:80 e6        bra :DB
1036:         
1036:         :string
1036:e8           inx
1037:bd 00 22     lda lineBuf,x
103a:f0 09        beq :stringEOF
103c:c9 27        cmp #''
103e:f0 f3        beq :DBcomma
1040:         
1040:20 32 11     jsr lineEmit    ; send it
1043:80 f1        bra :string
1045:         :stringEOF
1045:60           rts
1046:         
1046:         :DW
1046:20 c9 12     jsr lineNextTokenExit
1049:c9 2c        cmp #',
104b:f0 0f        beq :DWcomma
104d:         
104d:20 f3 12     jsr lineEval
1050:         
1050:a5 35        lda arg         ; send it
1052:20 32 11     jsr lineEmit
1055:a5 36        lda arg+1
1057:20 32 11     jsr lineEmit
105a:         
105a:80 ea        bra :DW
105c:         
105c:         :DWcomma
105c:e8           inx             ; consume ',' ready for next word
105d:80 e7        bra :DW
105f:         
105f:         :DF
105f:20 c9 12     jsr lineNextTokenExit
1062:         
1062:86 2a        stx emitX
1064:         :DFscan
1064:20 ac 12     jsr lineEnd
1067:f0 07        beq :DFscanned
1069:c9 2c        cmp #',
106b:f0 03        beq :DFscanned
106d:e8           inx
106e:d0 f4        bne :DFscan
1070:         
1070:         :DFscanned
1070:86 22        stx scratch
1072:8a           txa
1073:38           sec
1074:e5 2a        sbc emitX       ; A: length
1076:a6 2a        ldx emitX       ; X/Y: string
1078:a0 22        ldy #>lineBuf
107a:20 09 fe     jsr VAL1
107d:a2 d4        ldx #<fpack
107f:a0 1d        ldy #>fpack
1081:20 66 fe     jsr MOVMF       ; pack FACC->constant
1084:         
1084:a6 22        ldx scratch     ; get X back
1086:a0 00        ldy #0
1088:         
1088:         :DFemit
1088:b9 d4 1d     lda fpack,y     ; write 5 byte packed output
108b:20 32 11     jsr lineEmit
108e:c8           iny
108f:c0 05        cpy #5
1091:d0 f5        bne :DFemit
1093:         
1093:         :DFnext
1093:bd 00 22     lda lineBuf,x
1096:c9 2c        cmp #',
1098:d0 c5        bne :DF
109a:e8           inx             ; consume ,
109b:80 c2        bra :DF
109d:         
109d:         :OR
109d:20 e7 12     jsr lineAssertToken
10a0:         
10a0:20 f3 12     jsr lineEval
10a3:         
10a3:a5 35        lda arg
10a5:8d e5 1d     sta pc
10a8:a5 36        lda arg+1
10aa:8d e6 1d     sta pc+1
10ad:60           rts
10ae:         
10ae:         :IN
10ae:20 87 12     jsr lineGetName
10b1:4c 11 14     jmp ioPush
10b4:         
10b4:         :IB
10b4:20 87 12     jsr lineGetName
10b7:20 11 14     jsr ioPush
10ba:4c f6 15     jmp ioCopy
10bd:         
10bd:         :IF
10bd:20 e7 12     jsr lineAssertToken
10c0:         
10c0:24 44        bit lineIfs
10c2:30 17        bmi :falseIf
10c4:         
10c4:20 f3 12     jsr lineEval
10c7:20 25 11     jsr lineTruth
10ca:a5 36        lda arg+1
10cc:29 80        and #$80
10ce:0a           asl
10cf:66 45        ror lineIfd     ; desinty set
10d1:a5 36        lda arg+1
10d3:49 80        eor #$80
10d5:0a           asl             ; truth->C
10d6:66 44        ror lineIfs     ; push if stack
10d8:4c db 12     jmp lineAssertEnd
10db:         
10db:         :falseIf
10db:38           sec
10dc:66 44        ror lineIfs     ; stay in false state
10de:38           sec
10df:66 45        ror lineIfd     ; and this is our destiny at this level
10e1:60           rts
10e2:         
10e2:         ;
10e2:         ; resolve label field into ptr, adjusting symScope if necessary
10e2:         linePinLabel:
10e2:64 3d        stz labelPtr
10e4:20 6a 0e     jsr eResolveSym
10e7:ad 00 22     lda lineBuf
10ea:c9 3a        cmp #58         ; ':'
10ec:f0 08        beq :local
10ee:a5 27        lda ptr
10f0:85 2d        sta symScope    ; this becomes our new scope
10f2:a5 28        lda ptr+1
10f4:85 2e        sta symScope+1
10f6:         :local
10f6:a5 40        lda pass
10f8:d0 1a        bne :out        ; if pass >0, just return it
10fa:24 44        bit lineIfs
10fc:30 16        bmi :out        ; if'd out, just return it
10fe:a0 04        ldy #4
1100:b1 27        lda (ptr),y
1102:d0 13        bne :dupLabel
1104:a9 01        lda #1
1106:91 27        sta (ptr),y
1108:c8           iny
1109:ad e5 1d     lda pc
110c:91 27        sta (ptr),y     ; initially store pc
110e:c8           iny
110f:ad e6 1d     lda pc+1
1112:91 27        sta (ptr),y     ; may be set later with =expr
1114:         :out
1114:a6 29        ldx labelEnd    ; restore x
1116:60           rts
1117:         
1117:         :dupLabel
1117:a9 02        lda #errors:dupLabel
1119:85 46        sta error
111b:4c ce 12     jmp lineExit
111e:         
111e:         lineEmitError:
111e:a9 18        lda #errors:emit
1120:85 46        sta error
1122:4c ce 12     jmp lineExit
1125:         
1125:         ;
1125:         ; normalize non-0 to $8xxx for if checking
1125:         lineTruth:
1125:a9 ff        lda #$ff
1127:24 35        bit arg
1129:d0 04        bne :true
112b:24 36        bit arg+1
112d:f0 02        beq :false
112f:         :true
112f:85 36        sta arg+1
1131:         :false
1131:60           rts
1132:         
1132:         ;
1132:         ; emit byte
1132:         ; pc incremented, (emit) called
1132:         lineEmit:
1132:20 34 13     jsr ioEmit
1135:b0 e7        bcs lineEmitError
1137:60           rts
1138:         
1138:         lineOpError:
1138:a9 0e        lda #errors:op
113a:85 46        sta error
113c:60           rts
113d:         
113d:         ;
113d:         ; isn (arg) part
113d:         lineIsn:
113d:20 6b 18     jsr isnGet
1140:b0 f6        bcs lineOpError
1142:a9 07        lda #modeImp
1144:85 34        sta isnMode     ; assume implied
1146:64 2c        stz isnBit      ; start not assuming bit instruction
1148:e8           inx             ; skip isn
1149:e8           inx
114a:e8           inx
114b:20 1d 0e     jsr eIsOct      ; test for bit number
114e:90 03        bcc :notbitn
1150:85 2c        sta isnBit      ; '0'-'7' if this is a bitn
1152:e8           inx
1153:         
1153:         :notbitn
1153:20 b4 12     jsr lineNextToken
1156:f0 47        beq :gob        ; implied
1158:c9 23        cmp #'#
115a:f0 46        beq :imm
115c:c9 28        cmp #'(
115e:f0 4c        beq :ind
1160:         
1160:20 f3 12     jsr lineEval
1163:         
1163:a9 00        lda #modeAbs    ; abs (so far)
1165:85 34        sta isnMode
1167:         
1167:bd 00 22     lda lineBuf,x
116a:c9 2c        cmp #',
116c:d0 31        bne :gob
116e:e8           inx             ; consume ,
116f:bd 00 22     lda lineBuf,x
1172:20 3c 0b     jsr ePet
1175:29 7f        and #$7f        ; normalize case
1177:c9 58        cmp #'x
1179:f0 18        beq :absx
117b:c9 59        cmp #'y
117d:f0 1b        beq :absy
117f:         
117f:a5 35        lda arg
1181:8d e3 1d     sta argZ        ; zp,rel
1184:20 f3 12     jsr lineEval
1187:         
1187:a9 09        lda #modeBitRel
1189:85 34        sta isnMode
118b:4c f7 11     jmp :go
118e:         
118e:         :modeError:
118e:a9 10        lda #errors:mode
1190:85 46        sta error
1192:60           rts
1193:         
1193:         :absx
1193:e8           inx             ; consume 'x'
1194:a9 02        lda #modeAbsX   ; abs,x
1196:85 34        sta isnMode
1198:80 05        bra :gob
119a:         
119a:         :absy
119a:e8           inx             ; consume 'y'
119b:a9 03        lda #modeAbsY   ; abs,y
119d:85 34        sta isnMode
119f:             ; fall thru
119f:         
119f:         :gob
119f:4c f7 11     jmp :go
11a2:         
11a2:         :imm
11a2:e8           inx             ; skip #
11a3:20 f3 12     jsr lineEval
11a6:         
11a6:a9 06        lda #modeImm    ; imm
11a8:85 34        sta isnMode
11aa:80 4b        bra :go
11ac:         
11ac:         :ind
11ac:e8           inx             ; skip (
11ad:20 f3 12     jsr lineEval
11b0:             
11b0:a9 04        lda #modeAbsInd ; indirect
11b2:85 34        sta isnMode
11b4:             
11b4:bd 00 22     lda lineBuf,x
11b7:c9 2c        cmp #',
11b9:f0 06        beq :indx
11bb:c9 29        cmp #')
11bd:f0 1e        beq :indy
11bf:             
11bf:80 cd        bra :modeError
11c1:             
11c1:         :indx
11c1:e8           inx             ; skip ,
11c2:bd 00 22     lda lineBuf,x
11c5:20 3c 0b     jsr ePet
11c8:29 7f        and #$7f
11ca:c9 58        cmp #'x
11cc:d0 c0        bne :modeError
11ce:e8           inx
11cf:bd 00 22     lda lineBuf,x
11d2:c9 29        cmp #')
11d4:d0 b8        bne :modeError
11d6:e8           inx
11d7:         
11d7:a9 01        lda #modeAbsIndX ; (ind,x)
11d9:85 34        sta isnMode
11db:80 1a        bra :go
11dd:         
11dd:         :indy
11dd:e8           inx             ; skip )
11de:bd 00 22     lda lineBuf,x
11e1:c9 2c        cmp #',
11e3:d0 12        bne :go         ; presume (ind)
11e5:e8           inx
11e6:bd 00 22     lda lineBuf,x
11e9:20 3c 0b     jsr ePet
11ec:29 7f        and #$7f
11ee:c9 59        cmp #'y
11f0:d0 9c        bne :modeError
11f2:e8           inx
11f3:         
11f3:a9 0f        lda #modeZeroIndY
11f5:85 34        sta isnMode     ; (ind),y
11f7:             ; fall thru
11f7:         
11f7:             ; resolved address mode
11f7:         :go
11f7:20 db 12     jsr lineAssertEnd
11fa:a5 2c        lda isnBit      ; check for bitn
11fc:f0 13        beq :notbit
11fe:38           sec
11ff:e9 30        sbc #'0
1201:0a           asl
1202:0a           asl
1203:0a           asl
1204:0a           asl
1205:85 2c        sta isnBit
1207:a5 34        lda isnMode
1209:c9 00        cmp #modeAbs
120b:d0 04        bne :notbit
120d:a9 05        lda #modeBitZero
120f:85 34        sta isnMode
1211:         
1211:         :notbit
1211:a5 33        lda isnOp
1213:c9 54        cmp #$54        ; BRK is special
1215:f0 49        beq :brk
1217:         
1217:20 c0 18     jsr opResolve   ; opcode in a
121a:b0 4f        bcs :modeErrorb
121c:         
121c:65 2c        adc isnBit      ; if bitn, adjust
121e:20 32 11     jsr lineEmit    ; opcode
1221:         
1221:a5 34        lda isnMode
1223:c9 08        cmp #modeRel
1225:f0 0a        beq :rel
1227:c9 09        cmp #modeBitRel
1229:d0 43        bne :notrel
122b:         
122b:ad e3 1d     lda argZ
122e:20 32 11     jsr lineEmit    ; zp arg of bitRel
1231:         
1231:         :rel
1231:a5 40        lda pass
1233:f0 28        beq :pass0      ; no check in first pass    
1235:         
1235:ad e5 1d     lda pc          ; relative
1238:18           clc
1239:69 01        adc #1          ; scratch=pc+1
123b:85 22        sta scratch
123d:ad e6 1d     lda pc+1
1240:69 00        adc #0
1242:85 23        sta scratch+1
1244:         
1244:a5 35        lda arg         ; arg-=scratch
1246:38           sec
1247:e5 22        sbc scratch
1249:85 35        sta arg
124b:a5 36        lda arg+1
124d:e5 23        sbc scratch+1
124f:85 36        sta arg+1
1251:         
1251:a2 ff        ldx #$ff
1253:a5 35        lda arg         ; test for valid range
1255:30 02        bmi :checkBack
1257:a2 00        ldx #$00
1259:         :checkBack
1259:e4 36        cpx arg+1
125b:d0 25        bne :relError
125d:         
125d:         :pass0
125d:4c 32 11     jmp lineEmit    ; send it
1260:         
1260:         :brk
1260:a5 34        lda isnMode
1262:c9 07        cmp #modeImp
1264:d0 05        bne :modeErrorb
1266:a9 00        lda #0
1268:4c 32 11     jmp lineEmit    ; emit the single $00
126b:         
126b:         :modeErrorb
126b:4c 8e 11     jmp :modeError
126e:         
126e:         :notrel
126e:c9 07        cmp #modeImp
1270:f0 14        beq :done
1272:         
1272:a5 35        lda arg         ; low byte or zp
1274:20 32 11     jsr lineEmit
1277:         
1277:a5 34        lda isnMode
1279:c9 05        cmp #5
127b:b0 09        bcs :done
127d:         
127d:a5 36        lda arg+1       ; high byte
127f:4c 32 11     jmp lineEmit
1282:         
1282:         :relError
1282:a9 12        lda #errors:rel
1284:85 46        sta error
1286:         :done
1286:60           rts
1287:         
1287:         ;
1287:         ; expect 'quoted string' and return in a/x/y
1287:         lineGetName:
1287:20 e7 12     jsr lineAssertToken
128a:e8           inx
128b:c9 27        cmp #''
128d:d0 17        bne lineErrorDotArg
128f:86 22        stx scratch
1291:a0 00        ldy #0
1293:         :count
1293:20 d3 12     jsr lineEndExit
1296:c9 27        cmp #''
1298:f0 04        beq :got
129a:c8           iny
129b:e8           inx
129c:d0 f5        bne :count
129e:         :got
129e:98           tya             ; length -> A
129f:a6 22        ldx scratch
12a1:a0 22        ldy #>lineBuf
12a3:4c af 13     jmp ioCopySourceName
12a6:         
12a6:         lineErrorDotArg:
12a6:a9 1a        lda #errors:dotArg
12a8:85 46        sta error
12aa:80 22        bra lineExit
12ac:         
12ac:         ;
12ac:         ; Z=1 if at end
12ac:         lineEnd:
12ac:bd 00 22     lda lineBuf,x
12af:f0 02        beq :out        ; eof
12b1:c9 3b        cmp #';
12b3:         :out
12b3:60           rts
12b4:         
12b4:         ;
12b4:         ; Z=1 if at end (; or eof)
12b4:         lineNextToken:
12b4:20 ac 12     jsr lineEnd
12b7:f0 0c        beq :out
12b9:c9 21        cmp #33
12bb:90 09        bcc :white
12bd:c9 a0        cmp #160
12bf:f0 05        beq :white
12c1:c9 e0        cmp #224
12c3:f0 01        beq :white
12c5:         :out
12c5:60           rts
12c6:         :white
12c6:e8           inx
12c7:80 eb        bra lineNextToken
12c9:         
12c9:         ;
12c9:         ; lineNextToken with a fast exit at end
12c9:         lineNextTokenExit:
12c9:20 b4 12     jsr lineNextToken
12cc:d0 04        bne lineExit:out
12ce:         lineExit:
12ce:ae e2 1d     ldx lineSP      ; rewind stack for fast exit
12d1:9a           txs
12d2:         :out
12d2:60           rts
12d3:         
12d3:         ;
12d3:         ; lineEnd with fast exit
12d3:         lineEndExit:
12d3:20 ac 12     jsr lineEnd
12d6:d0 02        bne :out
12d8:80 f4        bra lineExit
12da:         :out
12da:60           rts
12db:         
12db:         ;
12db:         ; lineNextToken with an error and fast exit if not at end
12db:         lineAssertEnd:
12db:20 b4 12     jsr lineNextToken
12de:f0 06        beq :out
12e0:a9 14        lda #errors:parse
12e2:85 46        sta error
12e4:80 e8        bra lineExit
12e6:         :out
12e6:60           rts
12e7:         
12e7:         ;
12e7:         ; lineNextToken with an error and fast exit if at end
12e7:         lineAssertToken:
12e7:20 b4 12     jsr lineNextToken
12ea:d0 06        bne :out
12ec:a9 16        lda #errors:noArg
12ee:85 46        sta error
12f0:80 dc        bra lineExit
12f2:         :out
12f2:60           rts
12f3:         
12f3:         ;
12f3:         ; call eEval and fast exit on error
12f3:         lineEval
12f3:20 4f 0b     jsr eEval
12f6:90 06        bcc :out
12f8:a9 08        lda #errors:eval
12fa:85 46        sta error
12fc:80 d0        bra lineExit
12fe:         :out
12fe:60           rts
12ff:         
12ff:             .in 'io.asm'
12ff:             .in 'zp.asm'
12ff:             .fi ; zpAsm
12ff:         
12ff:             .in 'kernal.asm'
12ff:             .fi ; kernalAsm
12ff:         
12ff:         
12ff:         ;
12ff:         ; initialize
12ff:         ioInit:
12ff:20 e7 ff     jsr CLALL
1302:9c e0 1d     stz ioLFN
1305:64 49        stz ioNameL
1307:64 3f        stz ioBufStatus
1309:64 46        stz error
130b:9c dd 1d     stz ioLine
130e:9c de 1d     stz ioLine+1
1311:64 4a        stz ioOutPtr
1313:9c df 1d     stz ioFDS
1316:a9 ff        lda #$ff
1318:8d db 1d     sta ioPtr
131b:a9 08        lda #8          ; default to device 8
131d:8d dc 1d     sta ioDev
1320:a9 32        lda #<:null
1322:8d d9 1d     sta emit
1325:a9 13        lda #>:null
1327:8d da 1d     sta emit+1
132a:a2 0f        ldx #$0f        ; initialize io buffers
132c:         :loop
132c:9e f2 1d     stz ioBufs,x
132f:ca           dex
1330:10 fa        bpl :loop
1332:         :null
1332:18           clc
1333:60           rts
1334:         
1334:         ;
1334:         ; write a byte via the emit vector
1334:         ioEmit:
1334:ee e5 1d     inc pc
1337:d0 03        bne :lo
1339:ee e6 1d     inc pc+1
133c:         :lo
133c:6c d9 1d     jmp (emit)
133f:         
133f:         ;
133f:         ; close all files and display error
133f:         ioError:
133f:20 92 16     jsr ioCloseAll
1342:a9 0d        lda #13         ; cr
1344:20 d2 ff     jsr CHROUT
1347:a0 00        ldy #0
1349:         :print
1349:c4 49        cpy ioNameL
134b:f0 08        beq :printed
134d:b1 47        lda (ioName),y  ; print "filename:"
134f:20 d2 ff     jsr CHROUT
1352:c8           iny
1353:d0 f4        bne :print
1355:         :printed
1355:a9 3a        lda #':
1357:20 d2 ff     jsr CHROUT
135a:ad de 1d     lda ioLine+1
135d:20 20 17     jsr ioPrintHex
1360:ad dd 1d     lda ioLine
1363:20 20 17     jsr ioPrintHex
1366:a9 20        lda #32
1368:20 d2 ff     jsr CHROUT
136b:20 61 17     jsr errPrint
136e:a9 0d        lda #13         ; cr
1370:4c d2 ff     jmp CHROUT
1373:         
1373:         appendPtr:
1373:91 27        sta (ptr),y
1375:c8           iny
1376:60           rts
1377:         
1377:         comma:
1377:a9 2c        lda #',
1379:80 f8        bra appendPtr
137b:         
137b:         commaS:
137b:20 77 13     jsr comma
137e:a9 53        lda #'s
1380:80 f1        bra appendPtr
1382:         
1382:         commaP:
1382:20 77 13     jsr comma
1385:a9 50        lda #'p
1387:80 ea        bra appendPtr
1389:         
1389:         commaR:
1389:20 77 13     jsr comma
138c:a9 52        lda #'r
138e:80 e3        bra appendPtr
1390:         
1390:         commaW:
1390:20 77 13     jsr comma
1393:a9 57        lda #'w
1395:80 dc        bra appendPtr
1397:         
1397:         ;
1397:         ; make a copy of a/x/y with ,p,w appended
1397:         ; result in a/x/y
1397:         ioCopyDestName:
1397:20 bd 13     jsr ioCopyName
139a:20 82 13     jsr commaP
139d:20 90 13     jsr commaW
13a0:         copyOut:
13a0:98           tya
13a1:a4 28        ldy ptr+1
13a3:60           rts
13a4:         
13a4:         ;
13a4:         ; make a copy of a/x/y with ,s,w appended
13a4:         ioCopyListName:
13a4:20 bd 13     jsr ioCopyName
13a7:20 7b 13     jsr commaS
13aa:20 90 13     jsr commaW
13ad:80 f1        bra copyOut
13af:         
13af:         ;
13af:         ; make a copy of a/x/y with ,s,r appended
13af:         ; result in a/(ptr)
13af:         ioCopySourceName:
13af:20 da 13     jsr ioStringOut
13b2:20 bd 13     jsr ioCopyName
13b5:20 7b 13     jsr commaS
13b8:20 89 13     jsr commaR
13bb:80 e3        bra copyOut
13bd:         
13bd:         ioCopyName:
13bd:86 23        stx string
13bf:84 24        sty string+1
13c1:a8           tay
13c2:18           clc
13c3:69 04        adc #4
13c5:20 f3 0a     jsr symPush
13c8:84 22        sty scratch
13ca:a0 00        ldy #0
13cc:         :loop
13cc:c4 22        cpy scratch
13ce:f0 07        beq :done
13d0:b1 23        lda (string),y
13d2:91 27        sta (ptr),y
13d4:c8           iny
13d5:d0 f5        bne :loop
13d7:         :done
13d7:a6 27        ldx ptr
13d9:60           rts
13da:         
13da:         ;
13da:         ; print string a/x/y with CR
13da:         ; all preserved
13da:         ioStringOut:
13da:85 22        sta scratch
13dc:86 23        stx string
13de:84 24        sty string+1
13e0:a0 00        ldy #0
13e2:         :loop
13e2:c4 22        cpy scratch
13e4:f0 08        beq :done
13e6:b1 23        lda (string),y
13e8:20 d2 ff     jsr CHROUT
13eb:c8           iny
13ec:d0 f4        bne :loop
13ee:         :done
13ee:a9 0d        lda #13
13f0:20 d2 ff     jsr CHROUT
13f3:a5 22        lda scratch
13f5:a6 23        ldx string
13f7:a4 24        ldy string+1
13f9:60           rts
13fa:         
13fa:         ;
13fa:         ; open output file named in a/x/y with LFN 2
13fa:         ioOpenDest:
13fa:20 bd ff     jsr SETNAM
13fd:a9 02        lda #2
13ff:ae dc 1d     ldx ioDev
1402:a0 02        ldy #2
1404:20 ba ff     jsr SETLFS
1407:20 c0 ff     jsr OPEN
140a:90 04        bcc :opened
140c:a9 1c        lda #errors:io
140e:85 46        sta error
1410:         :opened
1410:60           rts
1411:         
1411:         ;
1411:         ; push input file a/x/y
1411:         ioPush:
1411:85 22        sta scratch
1413:86 27        stx ptr
1415:84 28        sty ptr+1
1417:20 cc ff     jsr CLRCHN
141a:         
141a:ac db 1d     ldy ioPtr       ; push current state
141d:         
141d:ad e0 1d     lda ioLFN       ; push current LFN (zero is done)
1420:99 00 20     sta ioStack,y
1423:88           dey
1424:         
1424:ad dc 1d     lda ioDev       ; device
1427:99 00 20     sta ioStack,y
142a:88           dey
142b:         
142b:a5 3f        lda ioBufStatus ; buffer status
142d:99 00 20     sta ioStack,y
1430:88           dey
1431:         
1431:a5 4b        lda ioInPtr     ; buffer position
1433:99 00 20     sta ioStack,y
1436:88           dey
1437:         
1437:a5 4d        lda ioIn+1      ; buffer
1439:99 00 20     sta ioStack,y
143c:88           dey
143d:         
143d:a5 4c        lda ioIn
143f:99 00 20     sta ioStack,y
1442:88           dey
1443:         
1443:a5 4e        lda ioBufLen    ; buffer length
1445:99 00 20     sta ioStack,y
1448:88           dey
1449:         
1449:a5 48        lda ioName+1    ; filename
144b:99 00 20     sta ioStack,y
144e:88           dey
144f:a5 47        lda ioName
1451:99 00 20     sta ioStack,y
1454:88           dey
1455:         
1455:a5 49        lda ioNameL     ; filename length
1457:99 00 20     sta ioStack,y
145a:88           dey
145b:         
145b:ad de 1d     lda ioLine+1    ; line
145e:99 00 20     sta ioStack,y
1461:88           dey
1462:ad dd 1d     lda ioLine
1465:99 00 20     sta ioStack,y
1468:88           dey
1469:         
1469:8c db 1d     sty ioPtr       ; current state all pushed
146c:         
146c:             ; TODO: parse for @device:
146c:         
146c:a5 22        lda scratch     ; scratch/ptr -> nameL/name
146e:85 49        sta ioNameL
1470:a6 27        ldx ptr
1472:86 47        stx ioName
1474:a4 28        ldy ptr+1
1476:84 48        sty ioName+1
1478:20 bd ff     jsr SETNAM      ; filename
147b:         
147b:20 1b 15     jsr ioAlloc     ; device secondary in Y
147e:b0 2c        bcs :toomany
1480:c8           iny
1481:c8           iny
1482:c8           iny             ; ..and add 3 to it (we use 2 for the output)
1483:ae dc 1d     ldx ioDev
1486:98           tya             ; use LFN=device secondary
1487:8d e0 1d     sta ioLFN
148a:20 ba ff     jsr SETLFS
148d:         
148d:20 c0 ff     jsr OPEN        ; open the file
1490:b0 15        bcs :error
1492:ae e0 1d     ldx ioLFN
1495:20 c6 ff     jsr CHKIN
1498:b0 0d        bcs :error      ; now current file for reading
149a:9c dd 1d     stz ioLine
149d:9c de 1d     stz ioLine+1
14a0:         
14a0:64 4b        stz ioInPtr
14a2:64 4e        stz ioBufLen
14a4:         
14a4:4c 97 15     jmp ioReadStatus
14a7:         
14a7:         :error
14a7:a9 1c        lda #errors:io
14a9:85 46        sta error
14ab:60           rts
14ac:         
14ac:         :toomany
14ac:a9 1e        lda #errors:tooMany
14ae:85 46        sta error
14b0:60           rts
14b1:         
14b1:         ;
14b1:         ; pop current file state
14b1:         ioPop:
14b1:20 cc ff     jsr CLRCHN      ; disconnect existing
14b4:ad e0 1d     lda ioLFN
14b7:20 c3 ff     jsr CLOSE       ; close current logical file
14ba:ac e0 1d     ldy ioLFN
14bd:88           dey
14be:88           dey
14bf:88           dey
14c0:20 4d 15     jsr ioDealloc   ; deallocate device secondary
14c3:         
14c3:ac db 1d     ldy ioPtr
14c6:         
14c6:c8           iny             ; line number
14c7:b9 00 20     lda ioStack,y
14ca:8d dd 1d     sta ioLine
14cd:c8           iny
14ce:b9 00 20     lda ioStack,y
14d1:8d de 1d     sta ioLine+1
14d4:         
14d4:c8           iny             ; filename length
14d5:b9 00 20     lda ioStack,y
14d8:85 49        sta ioNameL
14da:         
14da:c8           iny             ; filename
14db:b9 00 20     lda ioStack,y
14de:85 47        sta ioName
14e0:c8           iny
14e1:b9 00 20     lda ioStack,y
14e4:85 48        sta ioName+1
14e6:         
14e6:c8           iny             ; buffer length
14e7:b9 00 20     lda ioStack,y
14ea:85 4e        sta ioBufLen
14ec:         
14ec:c8           iny             ; buffer
14ed:b9 00 20     lda ioStack,y
14f0:85 4c        sta ioIn
14f2:c8           iny
14f3:b9 00 20     lda ioStack,y
14f6:85 4d        sta ioIn+1
14f8:         
14f8:c8           iny             ; buffer position
14f9:b9 00 20     lda ioStack,y
14fc:85 4b        sta ioInPtr
14fe:         
14fe:c8           iny             ; buffer status
14ff:b9 00 20     lda ioStack,y
1502:85 3f        sta ioBufStatus
1504:         
1504:c8           iny
1505:b9 00 20     lda ioStack,y   ; device
1508:8d dc 1d     sta ioDev
150b:         
150b:c8           iny             ; LFN
150c:be 00 20     ldx ioStack,y
150f:8e e0 1d     stx ioLFN
1512:             
1512:8c db 1d     sty ioPtr
1515:         
1515:f0 03        beq :zero       ; do not redirect from 0
1517:4c c6 ff     jmp CHKIN       ; this also becomes our current input
151a:         :zero
151a:60           rts
151b:         
151b:         ;
151b:         ; allocate device secondary
151b:         ; result in Y
151b:         ioAlloc:
151b:a9 01        lda #$01
151d:a0 00        ldy #0
151f:18           clc
1520:         :scan
1520:2c df 1d     bit ioFDS
1523:f0 05        beq :done
1525:c8           iny
1526:0a           asl
1527:90 f7        bcc :scan
1529:60           rts
152a:         :done
152a:0c df 1d     tsb ioFDS
152d:98           tya             ; potentially allocate input buffer
152e:0a           asl
152f:aa           tax
1530:bd f3 1d     lda ioBufs+1,x
1533:d0 0f        bne :alloced
1535:         
1535:a9 80        lda #$80        ; allocate a buffer
1537:20 f3 0a     jsr symPush
153a:a5 27        lda ptr
153c:9d f2 1d     sta ioBufs,x
153f:a5 28        lda ptr+1
1541:9d f3 1d     sta ioBufs+1,x
1544:         
1544:         :alloced            ; allocated
1544:85 4d        sta ioIn+1
1546:bd f2 1d     lda ioBufs,x
1549:85 4c        sta ioIn
154b:18           clc
154c:60           rts
154d:         
154d:         ;
154d:         ; deallocate device secondary in Y
154d:         ioDealloc:
154d:a9 01        lda #$01
154f:         :shift
154f:c0 00        cpy #0
1551:f0 04        beq :done
1553:0a           asl
1554:88           dey
1555:d0 f8        bne :shift
1557:         :done
1557:1c df 1d     trb ioFDS
155a:60           rts
155b:         
155b:         ;
155b:         ; read a line of input from current file
155b:         ; if ioLFN is 0 on return, at end of all files and nothing read
155b:         ioReadLine:
155b:f8           sed             ; increment bcd line number
155c:18           clc
155d:ad dd 1d     lda ioLine
1560:69 01        adc #$01
1562:8d dd 1d     sta ioLine
1565:ad de 1d     lda ioLine+1
1568:69 00        adc #0
156a:8d de 1d     sta ioLine+1
156d:d8           cld
156e:         
156e:64 22        stz scratch
1570:         :loop
1570:20 a7 15     jsr ioRead      ; read from input buffer until CR or EOF
1573:a6 22        ldx scratch
1575:b0 0b        bcs :readerr
1577:e6 22        inc scratch
1579:c9 0d        cmp #13         ; CR?
157b:f0 16        beq :linedone
157d:9d 00 22     sta lineBuf,x
1580:80 ee        bra :loop
1582:         :readerr
1582:a5 22        lda scratch     ; if we read something, deal with it
1584:d0 0d        bne :linedone
1586:         
1586:a5 46        lda error       ; non eof error?
1588:d0 08        bne :done
158a:         
158a:20 b1 14     jsr ioPop       ; eof; pop this input
158d:ad e0 1d     lda ioLFN
1590:d0 c9        bne ioReadLine  ; continue previous input
1592:         :done
1592:60           rts
1593:         
1593:         :linedone
1593:9e 00 22     stz lineBuf,x   ; mark end of line
1596:60           rts
1597:         
1597:         ;
1597:         ; call READST, set error if not EOF
1597:         ; Z=1 if all clear
1597:         ioReadStatus:
1597:20 b7 ff     jsr READST
159a:85 3f        sta ioBufStatus
159c:89 bf        bit #$bf        ; everything except eof
159e:f0 04        beq :done
15a0:a9 1c        lda #errors:io
15a2:85 46        sta error
15a4:         :done
15a4:89 ff        bit #$ff        ; leave Z=0 if EOF
15a6:60           rts
15a7:         
15a7:         ;
15a7:         ; read byte from input buffer, refilling if needed
15a7:         ioRead:
15a7:a4 4b        ldy ioInPtr
15a9:c4 4e        cpy ioBufLen
15ab:f0 06        beq :refill
15ad:e6 4b        inc ioInPtr
15af:b1 4c        lda (ioIn),y
15b1:18           clc
15b2:60           rts
15b3:         :refill
15b3:64 4b        stz ioInPtr     ; reset input
15b5:64 4e        stz ioBufLen
15b7:a5 3f        lda ioBufStatus ; check for end of file
15b9:d0 33        bne :end
15bb:a9 80        lda #$80        ; read max 128 bytes into buffer
15bd:a6 4c        ldx ioIn
15bf:a4 4d        ldy ioIn+1
15c1:18           clc
15c2:20 44 ff     jsr MACPTR
15c5:b0 0b        bcs :bytes      ; unsupported or error
15c7:e0 00        cpx #0
15c9:f0 25        beq :eof        ; end of file
15cb:86 4e        stx ioBufLen
15cd:20 97 15     jsr ioReadStatus
15d0:80 d5        bra ioRead
15d2:         :bytes
15d2:20 97 15     jsr ioReadStatus
15d5:d0 17        bne :end
15d7:a0 00        ldy #0
15d9:         :loop
15d9:20 cf ff     jsr CHRIN
15dc:91 4c        sta (ioIn),y
15de:20 97 15     jsr ioReadStatus
15e1:d0 07        bne :bytesdone  ; error or eof
15e3:c8           iny
15e4:10 f3        bpl :loop       ; read max 128 bytes
15e6:         :partial
15e6:84 4e        sty ioBufLen
15e8:80 bd        bra ioRead
15ea:         :bytesdone
15ea:c0 00        cpy #0
15ec:d0 f8        bne :partial    ; if we made progress, use partial read
15ee:         :end
15ee:38           sec
15ef:60           rts
15f0:         :eof
15f0:a9 40        lda #$40
15f2:85 3f        sta ioBufStatus
15f4:80 f8        bra :end
15f6:         
15f6:         ;
15f6:         ; copy
15f6:         ioCopy:
15f6:a5 46        lda error
15f8:d0 0a        bne :done
15fa:20 a7 15     jsr ioRead
15fd:b0 05        bcs :done
15ff:20 34 13     jsr ioEmit
1602:90 f2        bcc ioCopy
1604:         :done
1604:a5 46        lda error
1606:f0 03        beq :out
1608:4c b1 14     jmp ioPop
160b:         :out
160b:60           rts
160c:         
160c:         ;
160c:         ; emit byte to output (binary or listing char)
160c:         ioEmitBin:
160c:86 2a        stx emitX
160e:84 2b        sty emitY
1610:a4 4a        ldy ioOutPtr
1612:99 00 1f     sta ioBuf,y
1615:c8           iny
1616:84 4a        sty ioOutPtr
1618:18           clc             ; no error
1619:d0 03        bne :out
161b:20 46 16     jsr ioFlushAlways
161e:         :out
161e:a6 2a        ldx emitX
1620:a4 2b        ldy emitY
1622:60           rts
1623:         
1623:         ;
1623:         ; emit listing output
1623:         ioEmitListing:
1623:20 38 17     jsr ioHex
1626:a9 20        lda #32
1628:20 0c 16     jsr ioEmitBin
162b:b0 14        bcs :out
162d:ee e4 1d     inc ioColumn
1630:ad e4 1d     lda ioColumn
1633:c9 08        cmp #8
1635:90 0a        bcc :out
1637:a9 0d        lda #13
1639:20 0c 16     jsr ioEmitBin
163c:b0 03        bcs :out
163e:20 d6 16     jsr ioListing
1641:         :out
1641:60           rts
1642:         
1642:         
1642:         ;
1642:         ; flush any unwritten output
1642:         ioFlush:
1642:a5 4a        lda ioOutPtr
1644:f0 42        beq ioSuccess
1646:         ioFlushAlways:
1646:20 cc ff     jsr CLRCHN
1649:a2 02        ldx #2
164b:20 c9 ff     jsr CHKOUT
164e:b0 1e        bcs :done
1650:         
1650:a5 4a        lda ioOutPtr    ; try to write entire buffer
1652:a2 00        ldx #<ioBuf     ; invariant: 0; this is page aligned
1654:a0 1f        ldy #>ioBuf
1656:20 b1 fe     jsr MCIOUT
1659:b0 06        bcs :slow       ; not supported
165b:         
165b:e4 4a        cpx ioOutPtr    ; did we write everything?
165d:f0 0f        beq :done
165f:80 02        bra :loop       ; byte bang the rest
1661:         
1661:         :slow
1661:a2 00        ldx #0          ; byte bang
1663:         :loop
1663:bd 00 1f     lda ioBuf,x
1666:20 d2 ff     jsr CHROUT
1669:e8           inx
166a:e4 4a        cpx ioOutPtr
166c:d0 f5        bne :loop
166e:         :done
166e:64 4a        stz ioOutPtr
1670:20 cc ff     jsr CLRCHN
1673:ae e0 1d     ldx ioLFN
1676:f0 03        beq :noread
1678:20 c6 ff     jsr CHKIN
167b:         :noread
167b:20 b7 ff     jsr READST
167e:c9 00        cmp #0
1680:f0 06        beq ioSuccess
1682:a9 1c        lda #errors:io
1684:85 46        sta error
1686:38           sec
1687:60           rts
1688:         ioSuccess:
1688:18           clc
1689:60           rts
168a:         
168a:         ;
168a:         ; flush output buffer and close
168a:         ioClose:
168a:20 42 16     jsr ioFlush
168d:a9 02        lda #2
168f:4c c3 ff     jmp CLOSE
1692:         
1692:         ;
1692:         ; close all disk before exiting abnormally
1692:         ioCloseAll:
1692:             ; preserve filename and line number for error
1692:ad dd 1d     lda ioLine
1695:8d 00 22     sta lineBuf
1698:ad de 1d     lda ioLine+1
169b:8d 01 22     sta lineBuf+1
169e:a5 49        lda ioNameL
16a0:8d 02 22     sta lineBuf+2
16a3:a5 47        lda ioName
16a5:8d 03 22     sta lineBuf+3
16a8:a5 48        lda ioName+1
16aa:8d 04 22     sta lineBuf+4
16ad:         
16ad:20 8a 16     jsr ioClose
16b0:         :loop
16b0:ad e0 1d     lda ioLFN
16b3:f0 05        beq :done
16b5:20 b1 14     jsr ioPop
16b8:80 f6        bra :loop
16ba:         :done
16ba:ad 00 22     lda lineBuf
16bd:8d dd 1d     sta ioLine
16c0:ad 01 22     lda lineBuf+1
16c3:8d de 1d     sta ioLine+1
16c6:ad 02 22     lda lineBuf+2
16c9:85 49        sta ioNameL
16cb:ad 03 22     lda lineBuf+3
16ce:85 47        sta ioName
16d0:ad 04 22     lda lineBuf+4
16d3:85 48        sta ioName+1
16d5:         
16d5:60           rts
16d6:         
16d6:         ;
16d6:         ; emit listing address, reset column count
16d6:         ioListing:
16d6:a5 40        lda pass
16d8:10 18        bpl :silent     ; $80 must be set in pass for this output
16da:a5 44        lda lineIfs
16dc:30 14        bmi :silent     ; do not list if'd out
16de:ad e6 1d     lda pc+1        ; PC:
16e1:20 38 17     jsr ioHex
16e4:ad e5 1d     lda pc
16e7:20 38 17     jsr ioHex
16ea:a9 3a        lda #':
16ec:20 0c 16     jsr ioEmitBin
16ef:9c e4 1d     stz ioColumn
16f2:         :silent
16f2:60           rts
16f3:         
16f3:         ;
16f3:         ; pad trailing spaced per ioColumn
16f3:         ioPadListing:
16f3:a9 03        lda #3
16f5:38           sec
16f6:ed e4 1d     sbc ioColumn
16f9:90 0c        bcc :nextLine
16fb:aa           tax
16fc:18           clc
16fd:         :loop
16fd:ca           dex
16fe:30 1f        bmi :done
1700:a0 03        ldy #3
1702:20 15 17     jsr :spaces
1705:80 f6        bra :loop
1707:         :nextLine
1707:a9 0d        lda #13         ; cr
1709:20 0c 16     jsr ioEmitBin
170c:b0 11        bcs :done
170e:a0 0d        ldy #13         ; xxxx:aa bb cc
1710:20 15 17     jsr :spaces
1713:80 e8        bra :loop
1715:         :spaces
1715:a9 20        lda #32         ; space
1717:20 0c 16     jsr ioEmitBin
171a:b0 03        bcs :done
171c:88           dey
171d:d0 f6        bne :spaces
171f:         :done
171f:60           rts
1720:         
1720:         ;
1720:         ; print hex byte in A
1720:         ioPrintHex:
1720:85 22        sta scratch
1722:4a           lsr
1723:4a           lsr
1724:4a           lsr
1725:4a           lsr
1726:20 2d 17     jsr :digit
1729:a5 22        lda scratch
172b:29 0f        and #$0f
172d:         :digit
172d:c9 0a        cmp #10
172f:90 02        bcc :num
1731:69 06        adc #6          ; add 7 (C=1)
1733:         :num
1733:69 30        adc #'0
1735:4c d2 ff     jmp CHROUT
1738:         
1738:         ;
1738:         ; emit hex byte in A
1738:         ioHex:
1738:85 22        sta scratch
173a:4a           lsr
173b:4a           lsr
173c:4a           lsr
173d:4a           lsr
173e:20 45 17     jsr :digit
1741:a5 22        lda scratch
1743:29 0f        and #$0f
1745:         :digit
1745:c9 0a        cmp #10
1747:90 02        bcc :num
1749:69 06        adc #6
174b:         :num
174b:69 30        adc #'0
174d:4c 0c 16     jmp ioEmitBin
1750:         
1750:         ;
1750:         ; print 0 terminated string in X/Y
1750:         ; uses ptr
1750:         ioPrint:
1750:86 27        stx ptr
1752:84 28        sty ptr+1
1754:a0 00        ldy #0
1756:         :loop
1756:b1 27        lda (ptr),y
1758:f0 06        beq :done
175a:20 d2 ff     jsr CHROUT
175d:c8           iny
175e:d0 f6        bne :loop
1760:         :done
1760:60           rts
1761:         
1761:         
1761:             .in 'error.asm'
1761:             .in 'zp.asm'
1761:             .fi ; zpAsm
1761:         
1761:             .in 'kernal.asm'
1761:             .fi ; kernalAsm
1761:         
1761:         
1761:         ;
1761:         ; print errror message
1761:         errPrint:
1761:a6 46        ldx error
1763:bd 6d 17     lda :table,x
1766:bc 6e 17     ldy :table+1,x
1769:aa           tax
176a:4c 50 17     jmp ioPrint
176d:         :table
176d:         errors:
176d:         :fine   =*-errors
176d:8d 17        .dw :strings:fine
176f:         :dupLabel=*-errors
176f:92 17        .dw :strings:dupLabel
1771:         :star   =*-errors
1771:9c 17        .dw :strings:star
1773:         :backward=*-errors
1773:a6 17        .dw :strings:backward
1775:         :eval   =*-errors
1775:b4 17        .dw :strings:eval
1777:         :assign =*-errors
1777:c3 17        .dw :strings:assign
1779:         :dotOp  =*-errors
1779:d1 17        .dw :strings:dotOp
177b:         :op =*-errors
177b:e3 17        .dw :strings:op
177d:         :mode   =*-errors
177d:ee 17        .dw :strings:mode
177f:         :rel    =*-errors
177f:ff 17        .dw :strings:rel
1781:         :parse  =*-errors
1781:13 18        .dw :strings:parse
1783:         :noArg  =*-errors
1783:20 18        .dw :strings:noArg
1785:         :emit   =*-errors
1785:2d 18        .dw :strings:emit
1787:         :dotArg =*-errors
1787:3c 18        .dw :strings:dotArg
1789:         :io =*-errors
1789:4e 18        .dw :strings:io
178b:         :tooMany=*-errors
178b:57 18        .dw :strings:tooMany
178d:         
178d:         errors:strings:
178d:         :fine
178d:46 49 4e 45 00 
                 .db 'fine',0
1792:         :dupLabel
1792:44 55 50 20 4c 41 42 45 
179a:4c 00        .db 'dup label',0
179c:         :star
179c:53 54 41 52 20 45 58 50 
17a4:52 00        .db 'star expr',0
17a6:         :backward
17a6:50 43 20 4d 4f 56 45 44 
17ae:20 42 41 43 4b 00 
                 .db 'pc moved back',0
17b4:         :eval
17b4:42 41 44 20 45 58 50 52 
17bc:45 53 53 49 4f 4e 00 
                 .db 'bad expression',0
17c3:         :assign
17c3:42 41 44 20 41 53 53 49 
17cb:47 4d 45 4e 54 00 
                 .db 'bad assigment',0
17d1:         :dotOp
17d1:55 4e 4b 4e 4f 57 4e 20 
17d9:50 53 45 55 44 4f 20 4f 
17e1:50 00        .db 'unknown pseudo op',0
17e3:         :op
17e3:55 4e 4b 4e 4f 57 4e 20 
17eb:4f 50 00     .db 'unknown op',0
17ee:         :mode
17ee:42 41 44 20 41 44 44 52 
17f6:45 53 53 20 4d 4f 44 45 
17fe:00           .db 'bad address mode',0
17ff:         :rel
17ff:42 52 41 4e 43 48 20 4f 
1807:55 54 20 4f 46 20 52 41 
180f:4e 47 45 00 
                 .db 'branch out of range',0
1813:         :parse
1813:53 59 4e 54 41 58 20 45 
181b:52 52 4f 52 00 
                 .db 'syntax error',0
1820:         :noArg
1820:41 52 47 20 45 58 50 45 
1828:43 54 45 44 00 
                 .db 'arg expected',0
182d:         :emit
182d:49 4f 20 57 52 49 54 45 
1835:20 45 52 52 4f 52 00 
                 .db 'io write error',0
183c:         :dotArg
183c:42 41 44 20 50 53 45 55 
1844:44 4f 20 4f 50 20 41 52 
184c:47 00        .db 'bad pseudo op arg',0
184e:         :io
184e:49 4f 20 45 52 52 4f 52 
1856:00           .db 'io error',0
1857:         :tooMany
1857:54 4f 4f 20 4d 41 4e 59 
185f:20 4f 50 45 4e 20 46 49 
1867:4c 45 53 00 
                 .db 'too many open files',0
186b:         
186b:             .in 'isns.asm'
186b:             .in 'zp.asm'
186b:             .fi ; zpAsm
186b:         
186b:             .in 'mode.asm'
186b:             .fi ; modeAsm
186b:         
186b:         
186b:         
186b:         ;
186b:         ; return isn token at lineBuf,x
186b:         ; isnOp: result
186b:         ; C: not found
186b:         isnGet:
186b:             ; A,B,C = a-'A', b-'A', c-'A'
186b:             ; 
186b:             ; bit fedcba9876543210
186b:             ;     0AAAAABBBBBCCCCC
186b:             ; ex "LDA" is $2c60
186b:             ;
186b:bd 00 22     lda lineBuf,x
186e:38           sec
186f:e9 41        sbc #'a
1871:0a           asl
1872:0a           asl
1873:85 23        sta isn2
1875:bd 01 22     lda lineBuf+1,x
1878:38           sec
1879:e9 41        sbc #'a
187b:85 22        sta isn1
187d:4a           lsr
187e:4a           lsr
187f:4a           lsr
1880:04 23        tsb isn2
1882:a5 22        lda isn1
1884:0a           asl
1885:0a           asl
1886:0a           asl
1887:0a           asl
1888:0a           asl
1889:85 22        sta isn1
188b:bd 02 22     lda lineBuf+2,x
188e:38           sec
188f:e9 41        sbc #'a
1891:04 22        tsb isn1
1893:         
1893:             ; incr=1 element (2 bytes per entry)
1893:a0 02        ldy #2
1895:84 24        sty incr
1897:         
1897:         :loop
1897:a5 23        lda isn2        ; hi cmp
1899:d9 65 19     cmp isns+1,y
189c:d0 07        bne :cmp        ; if =, continue with lo cmp
189e:         
189e:a5 22        lda isn1        ; lo cmp
18a0:d9 64 19     cmp isns,y
18a3:f0 11        beq :found      ; if =, found
18a5:         
18a5:         :cmp
18a5:90 05        bcc :lo         ; needle < haystack location?
18a7:20 ba 18     jsr :next       ; no: extra advance to do it twice
18aa:b0 09        bcs :not
18ac:         
18ac:         :lo
18ac:20 ba 18     jsr :next       ; advance
18af:b0 04        bcs :not
18b1:         
18b1:06 24        asl incr        ; double incr for next advance
18b3:90 e2        bcc :loop
18b5:         :not
18b5:60           rts             ; invariant: C=1
18b6:         
18b6:         :found
18b6:18           clc             ; C=0 to indicate found
18b7:84 33        sty isnOp
18b9:60           rts
18ba:         
18ba:         :next
18ba:98           tya             ; y += incr
18bb:18           clc
18bc:65 24        adc incr        ; C=1 if over
18be:a8           tay
18bf:60           rts
18c0:         
18c0:         ;
18c0:         ; resolve deduced address mode and instruction
18c0:         opResolve:
18c0:a6 33        ldx isnOp
18c2:bd 65 1a     lda ops+1,x
18c5:f0 2e        beq :imp
18c7:85 28        sta ptr+1
18c9:bd 64 1a     lda ops,x
18cc:85 27        sta ptr
18ce:         
18ce:             ; can we zp this?
18ce:a5 36        lda arg+1       ; no, it is a 16 bit arg
18d0:d0 15        bne :try
18d2:         
18d2:a5 34        lda isnMode     ; does this have a potential zp version?
18d4:c9 05        cmp #5
18d6:b0 0f        bcs :try        ; no
18d8:         
18d8:69 0a        adc #10         ; try the zp form
18da:85 34        sta isnMode
18dc:20 e7 18     jsr :try
18df:90 20        bcc :out        ; we win (or it was relative)
18e1:         
18e1:a5 34        lda isnMode
18e3:e9 0a        sbc #10
18e5:85 34        sta isnMode     ; continue with original absolute
18e7:         
18e7:         :try
18e7:a4 34        ldy isnMode
18e9:b1 27        lda (ptr),y
18eb:d0 11        bne :found      ; found it
18ed:         
18ed:a0 08        ldy #modeRel
18ef:b1 27        lda (ptr),y
18f1:d0 0b        bne :found
18f3:         
18f3:80 0d        bra :err
18f5:             
18f5:         :imp
18f5:a4 34        ldy isnMode     ; has to be modeImp
18f7:c0 07        cpy #modeImp
18f9:d0 07        bne :err
18fb:bd 64 1a     lda ops,x
18fe:             ; fall thru
18fe:         
18fe:         :found
18fe:84 34        sty isnMode
1900:18           clc
1901:         :out
1901:60           rts
1902:         
1902:         :err
1902:38           sec
1903:60           rts
1904:         
1904:             .in 'isns-table.asm'
1904:00 00 00 00 00 00 00 00 
190c:00 00 00 00 00 00 00 00 
1914:00 00 00 00 00 00 00 00 
191c:00 00 00 00 00 00 00 00 
1924:00 00 00 00 00 00 00 00 
192c:00 00 00 00 00 00 00 00 
1934:00 00 00 00 00 00 00 00 
193c:00 00 00 00 00 00 00 00 
1944:00 00 00 00 00 00 00 00 
194c:00 00 00 00 00 00 00 00 
1954:00 00 00 00 00 00 00 00 
195c:00 00 00 00 00 00 00 00 
1964:         *=*%100
1964:         isns:
1964:00 00        .dw $0000
1966:51 2e        .dw $2e51 ; 02 lsr
1968:32 04        .dw $0432 ; 04 bbs
196a:f2 4e        .dw $4ef2 ; 06 txs
196c:00 00        .dw $0000
196e:22 48        .dw $4822 ; 0a sbc
1970:75 09        .dw $0975 ; 0c clv
1972:ff 7f        .dw $7fff
1974:00 00        .dw $0000
1976:6f 3d        .dw $3d6f ; 12 plp
1978:eb 05        .dw $05eb ; 14 bpl
197a:ff 7f        .dw $7fff
197c:00 00        .dw $0000
197e:78 4a        .dw $4a78 ; 1a sty
1980:a2 21        .dw $21a2 ; 1c inc
1982:ff 7f        .dw $7fff
1984:00 00        .dw $0000
1986:ef 3c        .dw $3cef ; 22 php
1988:90 04        .dw $0490 ; 24 beq
198a:ff 7f        .dw $7fff
198c:00 00        .dw $0000
198e:81 49        .dw $4981 ; 2a smb
1990:82 0c        .dw $0c82 ; 2c dec
1992:ff 7f        .dw $7fff
1994:00 00        .dw $0000
1996:cb 45        .dw $45cb ; 32 rol
1998:b2 06        .dw $06b2 ; 34 bvs
199a:ff 7f        .dw $7fff
199c:62 00        .dw $0062 ; 38 adc
199e:21 4e        .dw $4e21 ; 3a trb
19a0:51 26        .dw $2651 ; 3c jsr
19a2:ff 7f        .dw $7fff
19a4:00 00        .dw $0000
19a6:20 3a        .dw $3a20 ; 42 ora
19a8:42 04        .dw $0442 ; 44 bcc
19aa:08 58        .dw $5808 ; 46 wai
19ac:00 00        .dw $0000
19ae:83 48        .dw $4883 ; 4a sed
19b0:f7 09        .dw $09f7 ; 4c cpx
19b2:ff 7f        .dw $7fff
19b4:00 00        .dw $0000
19b6:78 3d        .dw $3d78 ; 52 ply
19b8:2a 06        .dw $062a ; 54 brk
19ba:ff 7f        .dw $7fff
19bc:00 00        .dw $0000
19be:17 4c        .dw $4c17 ; 5a tax
19c0:b8 21        .dw $21b8 ; 5c iny
19c2:ff 7f        .dw $7fff
19c4:00 00        .dw $0000
19c6:f8 3c        .dw $3cf8 ; 62 phy
19c8:88 05        .dw $0588 ; 64 bmi
19ca:ff 7f        .dw $7fff
19cc:00 00        .dw $0000
19ce:6f 4a        .dw $4a6f ; 6a stp
19d0:98 0c        .dw $0c98 ; 6c dey
19d2:ff 7f        .dw $7fff
19d4:00 00        .dw $0000
19d6:68 46        .dw $4668 ; 72 rti
19d8:63 09        .dw $0963 ; 74 cld
19da:ff 7f        .dw $7fff
19dc:4b 02        .dw $024b ; 78 asl
19de:57 4e        .dw $4e57 ; 7a tsx
19e0:77 2c        .dw $2c77 ; 7c ldx
19e2:ff 7f        .dw $7fff
19e4:00 00        .dw $0000
19e6:cf 35        .dw $35cf ; 82 nop
19e8:42 04        .dw $0442 ; 84 bcc
19ea:00 4f        .dw $4f00 ; 86 tya
19ec:00 00        .dw $0000
19ee:82 48        .dw $4882 ; 8a sec
19f0:8f 09        .dw $098f ; 8c cmp
19f2:ff 7f        .dw $7fff
19f4:00 00        .dw $0000
19f6:77 3d        .dw $3d77 ; 92 plx
19f8:20 06        .dw $0620 ; 94 bra
19fa:ff 7f        .dw $7fff
19fc:00 00        .dw $0000
19fe:79 4a        .dw $4a79 ; 9a stz
1a00:b7 21        .dw $21b7 ; 9c inx
1a02:ff 7f        .dw $7fff
1a04:00 00        .dw $0000
1a06:f7 3c        .dw $3cf7 ; a2 phx
1a08:13 05        .dw $0513 ; a4 bit
1a0a:ff 7f        .dw $7fff
1a0c:00 00        .dw $0000
1a0e:60 4a        .dw $4a60 ; aa sta
1a10:97 0c        .dw $0c97 ; ac dex
1a12:ff 7f        .dw $7fff
1a14:00 00        .dw $0000
1a16:d1 45        .dw $45d1 ; b2 ror
1a18:62 09        .dw $0962 ; b4 clc
1a1a:ff 7f        .dw $7fff
1a1c:a3 01        .dw $01a3 ; b8 and
1a1e:41 4e        .dw $4e41 ; ba tsb
1a20:60 2c        .dw $2c60 ; bc lda
1a22:ff 7f        .dw $7fff
1a24:00 00        .dw $0000
1a26:e0 3c        .dw $3ce0 ; c2 pha
1a28:52 04        .dw $0452 ; c4 bcs
1a2a:ff 7f        .dw $7fff
1a2c:00 00        .dw $0000
1a2e:88 48        .dw $4888 ; ca sei
1a30:f8 09        .dw $09f8 ; cc cpy
1a32:ff 7f        .dw $7fff
1a34:00 00        .dw $0000
1a36:81 45        .dw $4581 ; d2 rmb
1a38:a2 06        .dw $06a2 ; d4 bvc
1a3a:ff 7f        .dw $7fff
1a3c:00 00        .dw $0000
1a3e:18 4c        .dw $4c18 ; da tay
1a40:8f 25        .dw $258f ; dc jmp
1a42:ff 7f        .dw $7fff
1a44:00 00        .dw $0000
1a46:60 3d        .dw $3d60 ; e2 pla
1a48:a4 05        .dw $05a4 ; e4 bne
1a4a:ff 7f        .dw $7fff
1a4c:00 00        .dw $0000
1a4e:77 4a        .dw $4a77 ; ea stx
1a50:d1 11        .dw $11d1 ; ec eor
1a52:ff 7f        .dw $7fff
1a54:00 00        .dw $0000
1a56:72 46        .dw $4672 ; f2 rts
1a58:68 09        .dw $0968 ; f4 cli
1a5a:ff 7f        .dw $7fff
1a5c:31 04        .dw $0431 ; f8 bbr
1a5e:e0 4e        .dw $4ee0 ; fa txa
1a60:78 2c        .dw $2c78 ; fc ldy
1a62:ff 7f        .dw $7fff
1a64:         
1a64:         ops:
1a64:00 00     .dw 0
1a66:04 1d     .dw :lsr
1a68:a4 1b     .dw :bbs
1a6a:9a 00     .dw $9a ; txs
1a6c:00 00     .dw 0
1a6e:54 1d     .dw :sbc
1a70:b8 00     .dw $b8 ; clv
1a72:00 00     .dw 0
1a74:00 00     .dw 0
1a76:28 00     .dw $28 ; plp
1a78:14 1c     .dw :bpl
1a7a:00 00     .dw 0
1a7c:00 00     .dw 0
1a7e:94 1d     .dw :sty
1a80:a4 1c     .dw :inc
1a82:00 00     .dw 0
1a84:00 00     .dw 0
1a86:08 00     .dw $08 ; php
1a88:d4 1b     .dw :beq
1a8a:00 00     .dw 0
1a8c:00 00     .dw 0
1a8e:64 1d     .dw :smb
1a90:84 1c     .dw :dec
1a92:00 00     .dw 0
1a94:00 00     .dw 0
1a96:34 1d     .dw :rol
1a98:44 1c     .dw :bvs
1a9a:00 00     .dw 0
1a9c:64 1b     .dw :adc
1a9e:b4 1d     .dw :trb
1aa0:c4 1c     .dw :jsr
1aa2:00 00     .dw 0
1aa4:00 00     .dw 0
1aa6:14 1d     .dw :ora
1aa8:b4 1b     .dw :bcc
1aaa:cb 00     .dw $cb ; wai
1aac:00 00     .dw 0
1aae:f8 00     .dw $f8 ; sed
1ab0:64 1c     .dw :cpx
1ab2:00 00     .dw 0
1ab4:00 00     .dw 0
1ab6:7a 00     .dw $7a ; ply
1ab8:00 00     .dw $00 ; brk
1aba:00 00     .dw 0
1abc:00 00     .dw 0
1abe:aa 00     .dw $aa ; tax
1ac0:c8 00     .dw $c8 ; iny
1ac2:00 00     .dw 0
1ac4:00 00     .dw 0
1ac6:5a 00     .dw $5a ; phy
1ac8:f4 1b     .dw :bmi
1aca:00 00     .dw 0
1acc:00 00     .dw 0
1ace:db 00     .dw $db ; stp
1ad0:88 00     .dw $88 ; dey
1ad2:00 00     .dw 0
1ad4:00 00     .dw 0
1ad6:40 00     .dw $40 ; rti
1ad8:d8 00     .dw $d8 ; cld
1ada:00 00     .dw 0
1adc:84 1b     .dw :asl
1ade:ba 00     .dw $ba ; tsx
1ae0:e4 1c     .dw :ldx
1ae2:00 00     .dw 0
1ae4:00 00     .dw 0
1ae6:ea 00     .dw $ea ; nop
1ae8:b4 1b     .dw :bcc
1aea:98 00     .dw $98 ; tya
1aec:00 00     .dw 0
1aee:38 00     .dw $38 ; sec
1af0:54 1c     .dw :cmp
1af2:00 00     .dw 0
1af4:00 00     .dw 0
1af6:fa 00     .dw $fa ; plx
1af8:24 1c     .dw :bra
1afa:00 00     .dw 0
1afc:00 00     .dw 0
1afe:a4 1d     .dw :stz
1b00:e8 00     .dw $e8 ; inx
1b02:00 00     .dw 0
1b04:00 00     .dw 0
1b06:da 00     .dw $da ; phx
1b08:e4 1b     .dw :bit
1b0a:00 00     .dw 0
1b0c:00 00     .dw 0
1b0e:74 1d     .dw :sta
1b10:ca 00     .dw $ca ; dex
1b12:00 00     .dw 0
1b14:00 00     .dw 0
1b16:44 1d     .dw :ror
1b18:18 00     .dw $18 ; clc
1b1a:00 00     .dw 0
1b1c:74 1b     .dw :and
1b1e:c4 1d     .dw :tsb
1b20:d4 1c     .dw :lda
1b22:00 00     .dw 0
1b24:00 00     .dw 0
1b26:48 00     .dw $48 ; pha
1b28:c4 1b     .dw :bcs
1b2a:00 00     .dw 0
1b2c:00 00     .dw 0
1b2e:78 00     .dw $78 ; sei
1b30:74 1c     .dw :cpy
1b32:00 00     .dw 0
1b34:00 00     .dw 0
1b36:24 1d     .dw :rmb
1b38:34 1c     .dw :bvc
1b3a:00 00     .dw 0
1b3c:00 00     .dw 0
1b3e:a8 00     .dw $a8 ; tay
1b40:b4 1c     .dw :jmp
1b42:00 00     .dw 0
1b44:00 00     .dw 0
1b46:68 00     .dw $68 ; pla
1b48:04 1c     .dw :bne
1b4a:00 00     .dw 0
1b4c:00 00     .dw 0
1b4e:84 1d     .dw :stx
1b50:94 1c     .dw :eor
1b52:00 00     .dw 0
1b54:00 00     .dw 0
1b56:60 00     .dw $60 ; rts
1b58:58 00     .dw $58 ; cli
1b5a:00 00     .dw 0
1b5c:94 1b     .dw :bbr
1b5e:8a 00     .dw $8a ; txa
1b60:f4 1c     .dw :ldy
1b62:00 00     .dw 0
1b64:         :adc
1b64:6d 00 7d 79 00 00 69 00 
1b6c:00 00 65 61 75 00 72 71 
1b74:          .db $6d,$00,$7d,$79,$00,$00,$69,$00,$00,$00,$65,$61,$75,$00,$72,$71
1b74:         :and
1b74:2d 00 3d 39 00 00 29 00 
1b7c:00 00 25 21 35 00 32 31 
1b84:          .db $2d,$00,$3d,$39,$00,$00,$29,$00,$00,$00,$25,$21,$35,$00,$32,$31
1b84:         :asl
1b84:0e 00 1e 00 00 00 00 0a 
1b8c:00 00 06 00 16 00 00 00 
1b94:          .db $0e,$00,$1e,$00,$00,$00,$00,$0a,$00,$00,$06,$00,$16,$00,$00,$00
1b94:         :bbr
1b94:00 00 00 00 00 00 00 00 
1b9c:00 0f 00 00 00 00 00 00 
1ba4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$0f,$00,$00,$00,$00,$00,$00
1ba4:         :bbs
1ba4:00 00 00 00 00 00 00 00 
1bac:00 8f 00 00 00 00 00 00 
1bb4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$8f,$00,$00,$00,$00,$00,$00
1bb4:         :bcc
1bb4:00 00 00 00 00 00 00 00 
1bbc:90 00 00 00 00 00 00 00 
1bc4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$90,$00,$00,$00,$00,$00,$00,$00
1bc4:         :bcs
1bc4:00 00 00 00 00 00 00 00 
1bcc:b0 00 00 00 00 00 00 00 
1bd4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$b0,$00,$00,$00,$00,$00,$00,$00
1bd4:         :beq
1bd4:00 00 00 00 00 00 00 00 
1bdc:f0 00 00 00 00 00 00 00 
1be4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$f0,$00,$00,$00,$00,$00,$00,$00
1be4:         :bit
1be4:2c 00 3c 00 00 00 89 00 
1bec:00 00 24 00 34 00 00 00 
1bf4:          .db $2c,$00,$3c,$00,$00,$00,$89,$00,$00,$00,$24,$00,$34,$00,$00,$00
1bf4:         :bmi
1bf4:00 00 00 00 00 00 00 00 
1bfc:30 00 00 00 00 00 00 00 
1c04:          .db $00,$00,$00,$00,$00,$00,$00,$00,$30,$00,$00,$00,$00,$00,$00,$00
1c04:         :bne
1c04:00 00 00 00 00 00 00 00 
1c0c:d0 00 00 00 00 00 00 00 
1c14:          .db $00,$00,$00,$00,$00,$00,$00,$00,$d0,$00,$00,$00,$00,$00,$00,$00
1c14:         :bpl
1c14:00 00 00 00 00 00 00 00 
1c1c:10 00 00 00 00 00 00 00 
1c24:          .db $00,$00,$00,$00,$00,$00,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00
1c24:         :bra
1c24:00 00 00 00 00 00 00 00 
1c2c:80 00 00 00 00 00 00 00 
1c34:          .db $00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00
1c34:         :bvc
1c34:00 00 00 00 00 00 00 00 
1c3c:50 00 00 00 00 00 00 00 
1c44:          .db $00,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00,$00,$00,$00,$00,$00
1c44:         :bvs
1c44:00 00 00 00 00 00 00 00 
1c4c:70 00 00 00 00 00 00 00 
1c54:          .db $00,$00,$00,$00,$00,$00,$00,$00,$70,$00,$00,$00,$00,$00,$00,$00
1c54:         :cmp
1c54:cd 00 dd d9 00 00 c9 00 
1c5c:00 00 c5 c1 d5 00 d2 d1 
1c64:          .db $cd,$00,$dd,$d9,$00,$00,$c9,$00,$00,$00,$c5,$c1,$d5,$00,$d2,$d1
1c64:         :cpx
1c64:ec 00 00 00 00 00 e0 00 
1c6c:00 00 e4 00 00 00 00 00 
1c74:          .db $ec,$00,$00,$00,$00,$00,$e0,$00,$00,$00,$e4,$00,$00,$00,$00,$00
1c74:         :cpy
1c74:cc 00 00 00 00 00 c0 00 
1c7c:00 00 c4 00 00 00 00 00 
1c84:          .db $cc,$00,$00,$00,$00,$00,$c0,$00,$00,$00,$c4,$00,$00,$00,$00,$00
1c84:         :dec
1c84:ce 00 de 00 00 00 00 3a 
1c8c:00 00 c6 00 d6 00 00 00 
1c94:          .db $ce,$00,$de,$00,$00,$00,$00,$3a,$00,$00,$c6,$00,$d6,$00,$00,$00
1c94:         :eor
1c94:4d 00 5d 59 00 00 49 00 
1c9c:00 00 45 41 55 00 52 51 
1ca4:          .db $4d,$00,$5d,$59,$00,$00,$49,$00,$00,$00,$45,$41,$55,$00,$52,$51
1ca4:         :inc
1ca4:ee 00 fe 00 00 00 00 1a 
1cac:00 00 e6 00 f6 00 00 00 
1cb4:          .db $ee,$00,$fe,$00,$00,$00,$00,$1a,$00,$00,$e6,$00,$f6,$00,$00,$00
1cb4:         :jmp
1cb4:4c 7c 00 00 6c 00 00 00 
1cbc:00 00 00 00 00 00 00 00 
1cc4:          .db $4c,$7c,$00,$00,$6c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1cc4:         :jsr
1cc4:20 00 00 00 00 00 00 00 
1ccc:00 00 00 00 00 00 00 00 
1cd4:          .db $20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1cd4:         :lda
1cd4:ad 00 bd b9 00 00 a9 00 
1cdc:00 00 a5 a1 b5 00 b2 b1 
1ce4:          .db $ad,$00,$bd,$b9,$00,$00,$a9,$00,$00,$00,$a5,$a1,$b5,$00,$b2,$b1
1ce4:         :ldx
1ce4:ae 00 00 be 00 00 a2 00 
1cec:00 00 a6 00 00 b6 00 00 
1cf4:          .db $ae,$00,$00,$be,$00,$00,$a2,$00,$00,$00,$a6,$00,$00,$b6,$00,$00
1cf4:         :ldy
1cf4:ac 00 bc 00 00 00 a0 00 
1cfc:00 00 a4 00 b4 00 00 00 
1d04:          .db $ac,$00,$bc,$00,$00,$00,$a0,$00,$00,$00,$a4,$00,$b4,$00,$00,$00
1d04:         :lsr
1d04:4e 00 5e 00 00 00 00 4a 
1d0c:00 00 46 00 56 00 00 00 
1d14:          .db $4e,$00,$5e,$00,$00,$00,$00,$4a,$00,$00,$46,$00,$56,$00,$00,$00
1d14:         :ora
1d14:0d 00 1d 19 00 00 09 00 
1d1c:00 00 05 01 15 00 12 11 
1d24:          .db $0d,$00,$1d,$19,$00,$00,$09,$00,$00,$00,$05,$01,$15,$00,$12,$11
1d24:         :rmb
1d24:00 00 00 00 00 07 00 00 
1d2c:00 00 00 00 00 00 00 00 
1d34:          .db $00,$00,$00,$00,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1d34:         :rol
1d34:2e 00 3e 00 00 00 00 2a 
1d3c:00 00 26 00 36 00 00 00 
1d44:          .db $2e,$00,$3e,$00,$00,$00,$00,$2a,$00,$00,$26,$00,$36,$00,$00,$00
1d44:         :ror
1d44:6e 00 7e 00 00 00 00 6a 
1d4c:00 00 66 00 76 00 00 00 
1d54:          .db $6e,$00,$7e,$00,$00,$00,$00,$6a,$00,$00,$66,$00,$76,$00,$00,$00
1d54:         :sbc
1d54:ed 00 fd f9 00 00 e9 00 
1d5c:00 00 e5 e1 f5 00 f2 f1 
1d64:          .db $ed,$00,$fd,$f9,$00,$00,$e9,$00,$00,$00,$e5,$e1,$f5,$00,$f2,$f1
1d64:         :smb
1d64:00 00 00 00 00 87 00 00 
1d6c:00 00 00 00 00 00 00 00 
1d74:          .db $00,$00,$00,$00,$00,$87,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1d74:         :sta
1d74:8d 00 9d 99 00 00 00 00 
1d7c:00 00 85 81 95 00 92 91 
1d84:          .db $8d,$00,$9d,$99,$00,$00,$00,$00,$00,$00,$85,$81,$95,$00,$92,$91
1d84:         :stx
1d84:8e 00 00 00 00 00 00 00 
1d8c:00 00 86 00 00 96 00 00 
1d94:          .db $8e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$86,$00,$00,$96,$00,$00
1d94:         :sty
1d94:8c 00 00 00 00 00 00 00 
1d9c:00 00 84 00 94 00 00 00 
1da4:          .db $8c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$84,$00,$94,$00,$00,$00
1da4:         :stz
1da4:9c 00 9e 00 00 00 00 00 
1dac:00 00 64 00 74 00 00 00 
1db4:          .db $9c,$00,$9e,$00,$00,$00,$00,$00,$00,$00,$64,$00,$74,$00,$00,$00
1db4:         :trb
1db4:1c 00 00 00 00 00 00 00 
1dbc:00 00 14 00 00 00 00 00 
1dc4:          .db $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$14,$00,$00,$00,$00,$00
1dc4:         :tsb
1dc4:0c 00 00 00 00 00 00 00 
1dcc:00 00 04 00 00 00 00 00 
1dd4:          .db $0c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$00,$00,$00,$00,$00
1dd4:         ; size=$0470
1dd4:         
1dd4:         
1dd4:             .in 'memory.asm'
1dd4:         ;
1dd4:         ; runtime data
1dd4:         ; include LAST
1dd4:         
1dd4:         fpack:          ; 5 bytes of space for packed floating point number
1dd4:             .or *+5
1dd9:         emit:           ; emit vector
1dd9:             .or *+2
1ddb:         ioPtr:          ; io stack pointer
1ddb:             .or *+1
1ddc:         ioDev:          ; current disk device
1ddc:             .or *+1
1ddd:         ioLine:         ; current line
1ddd:             .or *+2
1ddf:         ioFDS:          ; allocation bitmap of channels
1ddf:             .or *+1
1de0:         ioLFN:          ; current logical file number
1de0:             .or *+1
1de1:         asmSP:          ; stack frame we started with
1de1:             .or *+1
1de2:         lineSP:         ; stack frame for calls into per line assembly for error return
1de2:             .or *+1
1de3:         argZ:           ; first zp of zp,arg
1de3:             .or *+1
1de4:         ioColumn:       ; listing output column
1de4:             .or *+1
1de5:         pc:             ; pc
1de5:             .or *+2
1de7:         inputOpt:       ; input filename length
1de7:             .or *+1
1de8:         inputName:      ; input filename
1de8:             .or *+2
1dea:         listOpt:        ; listing filename length
1dea:             .or *+1
1deb:         listName:       ; listing filename
1deb:             .or *+2
1ded:         outOpt:         ; output filename length
1ded:             .or *+1
1dee:         outName:        ; output filename
1dee:             .or *+2
1df0:         tScope:         ; save scope
1df0:             .or *+2
1df2:         ioBufs:         ; allocated io buffers
1df2:             .or *+$10
1e02:             .or *%$100  ; page align
1f00:         ioBuf:          ; binary output buffer
1f00:             .or *+$100
2000:         ioStack:        ; source file stack
2000:             .or *+$100
2100:         eStack:         ; numeric evaluation stack
2100:             .or *+$100
2200:         lineBuf:        ; line to parse
2200:             .or *+$100
2300:         hashTable:      ; symbol hash table page
2300:             .or *+$100
2400:         symbols:        ; start of symbol table
2400:         
2400:         
2400: