1000:01 08        .dw $801
1002:             .or $801
0801:         
0801:             ; 10 SYS 2062
0801:0c 08 0a 00 
                 .dw zero, 10
0805:9e 20 32 30 36 32 00 
                 .db $9e,' 2062',0
080c:         zero:
080c:00 00        .dw 0
080e:         
080e:             *=2062
080e:         
080e:             .in 'zp.asm'
080e:             .fi ; zpAsm
080e:             .in 'kernal.asm'
080e:             .fi ; kernalAsm
080e:         
080e:             .in 'xasm-macros.asm'
080e:         ;
080e:         ; return true if arg can relative branch from pc+branch instruction
080e:         ISREL   .ma
080e:             ; branch distance from instruction
080e:             _ = @0-(*+2)
080e:             ; range -128 to 127
080e:             _ = (_ < $80) . (!_ < $80)
080e:             .em
080e:         
080e:         ;
080e:         ; jmp or bra
080e:         JMP .ma
080e:             ISREL @0
080e:             .if _
080e:                 bra @0
080e:             .el
080e:                 jmp @0
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; beq with potential long
080e:         BEQ .ma
080e:             ISREL @0
080e:             .if _
080e:                 beq @0
080e:             .el
080e:                 bne :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; bne with potential long
080e:         BNE .ma
080e:             ISREL @0
080e:             .if _
080e:                 bne @0
080e:             .el
080e:                 beq :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; bcs with potential long
080e:         BCS .ma
080e:             ISREL @0
080e:             .if _
080e:                 bcs @0
080e:             .el
080e:                 bcc :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; bcc with potential long
080e:         BCC .ma
080e:             ISREL @0
080e:             .if _
080e:                 bcc @0
080e:             .el
080e:                 bcs :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; bmi with potential long
080e:         BMI .ma
080e:             ISREL @0
080e:             .if _
080e:                 bmi @0
080e:             .el
080e:                 bpl :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; bpl with potential long
080e:         BPL .ma
080e:             ISREL @0
080e:             .if _
080e:                 bpl @0
080e:             .el
080e:                 bmi :@:not
080e:                 jmp @0
080e:         :@:not:
080e:             .fi
080e:             .em
080e:         
080e:         ;
080e:         ; load ax with 16 bit immediate
080e:         LAX .ma
080e:             lda #<@0
080e:             ldx #>@0
080e:             .em
080e:         
080e:         ;
080e:         ; load xy with 16 bit immediate
080e:         LXY .ma
080e:             ldx #<@0
080e:             ldy #>@0
080e:             .em
080e:         
080e:         ;
080e:         ; assign zp ptr @0 to zp ptr @1
080e:         TXPTR   .ma
080e:             lda @1
080e:             sta @0
080e:             lda @1+1
080e:             sta @1+1
080e:             .em
080e:         
080e:         
080e:         options=$bf00
080e:         
080e:ba           tsx
080f:8e fa 20     stx asmSP
0812:20 47 14     jsr ioInit
0815:20 33 0a     jsr symInit
0818:20 69 18     jsr hiInit
081b:20 ef 18     jsr macInit
081e:64 40        stz pass
0820:9c 05 21     stz listOpt
0823:9c 08 21     stz outOpt
0826:64 44        stz lineIfs
0828:64 45        stz lineIfd
082a:a9 ff        lda #$ff
082c:85 43        sta ePtr
082e:9c 10 21     stz inMac
0831:80 0a        bra begin
0833:         
0833:         usage:
0833:a2 bc        ldx #<usageStr
0835:a0 09        ldy #>usageStr
0837:20 58 18     jsr ioPrint
083a:4c a3 09     jmp exit
083d:         
083d:         begin:
083d:64 00        stz $00             ; select system bank for params
083f:a9 04        lda #4
0841:85 01        sta $01             ; select rom bank 4
0843:20 14 0a     jsr getOpt
0846:c9 00        cmp #0
0848:d0 07        bne :got
084a:20 57 09     jsr askArgs         ; get interactively
084d:c9 00        cmp #0
084f:f0 e2        beq usage
0851:         :got
0851:20 2b 15     jsr ioCopySourceName
0854:8d 02 21     sta inputOpt        ; source filename length
0857:8e 03 21     stx inputName
085a:8c 04 21     sty inputName+1
085d:         
085d:20 14 0a     jsr getOpt          ; output
0860:c9 00        cmp #0
0862:f0 0c        beq :nooutOpt
0864:20 13 15     jsr ioCopyDestName
0867:8d 08 21     sta outOpt          ; dest filename length
086a:8e 09 21     stx outName
086d:8c 0a 21     sty outName+1
0870:         :nooutOpt
0870:         
0870:20 14 0a     jsr getOpt          ; listing
0873:c9 00        cmp #0
0875:f0 0c        beq :nolistOpt
0877:20 1f 15     jsr ioCopyListName
087a:8d 05 21     sta listOpt
087d:8e 06 21     stx listName
0880:8c 07 21     sty listName+1
0883:         :nolistOpt
0883:         
0883:         asmPass:
0883:64 2e        stz symScope
0885:64 2f        stz symScope+1
0887:         
0887:ae 03 21     ldx inputName
088a:ac 04 21     ldy inputName+1
088d:ad 02 21     lda inputOpt
0890:20 94 15     jsr ioPushFile
0893:         
0893:9c fe 20     stz pc
0896:a9 10        lda #$10
0898:8d ff 20     sta pc+1            ; default pc=$1000
089b:         
089b:a2 fd        ldx #<passStr       ; "pass:n"
089d:a0 09        ldy #>passStr
089f:20 58 18     jsr ioPrint
08a2:a5 40        lda pass            ; pass #
08a4:29 07        and #$07
08a6:1a           inc
08a7:20 28 18     jsr ioPrintHex
08aa:a9 0d        lda #13             ; cr
08ac:20 d2 ff     jsr CHROUT
08af:         
08af:         :line
08af:20 de 17     jsr ioListing       ; possibly show pc for listing
08b2:20 6b 16     jsr ioReadLine      ; read next line
08b5:20 b2 09     jsr asmError        ; poll for error
08b8:ad e8 20     lda input:lfn       ; check for EOF
08bb:f0 30        beq :next
08bd:         
08bd:20 51 0f     jsr lineAsm         ; assemble line
08c0:20 b2 09     jsr asmError        ; poll for error
08c3:         
08c3:a5 40        lda pass
08c5:10 e8        bpl :line           ; listing output in second pass, if enabled
08c7:a5 44        lda lineIfs
08c9:30 e4        bmi :line           ; do not list if'd out 
08cb:         
08cb:20 fb 17     jsr ioPadListing
08ce:         
08ce:a2 00        ldx #0
08d0:         :listLine
08d0:bd 00 25     lda lineBuf,x
08d3:f0 0a        beq :listed         ; eof
08d5:c9 0d        cmp #13
08d7:f0 06        beq :listed         ; cr
08d9:20 29 17     jsr ioEmitBin
08dc:e8           inx
08dd:d0 f1        bne :listLine
08df:         :listed
08df:a9 0d        lda #13
08e1:20 29 17     jsr ioEmitBin
08e4:80 c9        bra :line
08e6:         
08e6:         :looping
08e6:a9 26        lda #errors:looping
08e8:85 46        sta error
08ea:4c b2 09     jmp asmError
08ed:         
08ed:         :next
08ed:a5 40        lda pass
08ef:e6 40        inc pass
08f1:89 ff        bit #$ff
08f3:f0 8e        beq asmPass         ; pass 0 always goes around again
08f5:         
08f5:a9 40        lda #$40            ; check for additional passes
08f7:14 40        trb pass
08f9:f0 08        beq :output         ; ready for output
08fb:         
08fb:a5 40        lda pass            ; check for excessive rescans
08fd:c9 0a        cmp #10
08ff:b0 e5        bcs :looping
0901:         
0901:80 80        bra asmPass
0903:         
0903:         :output
0903:a5 40        lda pass
0905:89 a0        bit #$a0
0907:f0 06        beq :noclose        ; no output files open
0909:         
0909:20 a7 17     jsr ioClose         ; flush and close output or listing
090c:20 b2 09     jsr asmError
090f:         
090f:         :noclose
090f:ad 08 21     lda outOpt          ; do we have output?
0912:f0 1f        beq :listing        ; no, skip to listing (if enabled)
0914:         
0914:a9 20        lda #$20            ; indicate writing binary
0916:04 40        tsb pass
0918:d0 19        bne :listing        ; done writing binary
091a:         
091a:ae 09 21     ldx outName         ; set up output filename
091d:ac 0a 21     ldy outName+1
0920:20 5a 15     jsr ioOpenDest      ; open
0923:20 b2 09     jsr asmError        ; poll for error
0926:         
0926:a9 29        lda #<ioEmitBin     ; connect the output hose
0928:8d e5 20     sta emit
092b:a9 17        lda #>ioEmitBin
092d:8d e6 20     sta emit+1
0930:4c 83 08     jmp asmPass         ; go around again
0933:         
0933:         :listing
0933:a9 80        lda #$80            ; indicate listing
0935:04 40        tsb pass
0937:d0 41        bne asmDone         ; done listing
0939:         
0939:ad 05 21     lda listOpt
093c:f0 3c        beq asmDone         ; no listing, we are done
093e:         
093e:ae 06 21     ldx listName        ; open the listing file  
0941:ac 07 21     ldy listName+1
0944:         
0944:20 5a 15     jsr ioOpenDest      ; open
0947:20 b2 09     jsr asmError        ; poll for error
094a:         
094a:a9 40        lda #<ioEmitListing
094c:8d e5 20     sta emit
094f:a9 17        lda #>ioEmitListing
0951:8d e6 20     sta emit+1
0954:4c 83 08     jmp asmPass
0957:         
0957:         askArgs:
0957:a9 3f        lda #'?
0959:20 d2 ff     jsr CHROUT
095c:a2 00        ldx #0
095e:86 2d        stx optPtr
0960:         :loop
0960:20 cf ff     jsr CHRIN
0963:c9 0d        cmp #13
0965:f0 06        beq :done
0967:9d 00 bf     sta options,x
096a:e8           inx
096b:d0 f3        bne :loop
096d:         :done
096d:9e 00 bf     stz options,x
0970:a9 0d        lda #13             ; cr
0972:20 d2 ff     jsr CHROUT
0975:64 2d        stz optPtr
0977:4c 14 0a     jmp getOpt
097a:         
097a:         asmDone:
097a:a2 04        ldx #<symendStr     ; "symend="
097c:a0 0a        ldy #>symendStr
097e:20 58 18     jsr ioPrint
0981:a5 42        lda symEnd+1
0983:20 28 18     jsr ioPrintHex
0986:a5 41        lda symEnd
0988:20 28 18     jsr ioPrintHex
098b:a2 0e        ldx #<pcStr         ; "pc="
098d:a0 0a        ldy #>pcStr
098f:20 58 18     jsr ioPrint
0992:ad ff 20     lda pc+1
0995:20 28 18     jsr ioPrintHex
0998:ad fe 20     lda pc
099b:20 28 18     jsr ioPrintHex
099e:a9 0d        lda #13
09a0:20 d2 ff     jsr CHROUT
09a3:         
09a3:         exit:
09a3:a2 00        ldx #0              ; zero out options buf on our way out
09a5:86 00        stx $00
09a7:         :fill
09a7:9e 00 bf     stz options,x
09aa:e8           inx
09ab:d0 fa        bne :fill
09ad:ae fa 20     ldx asmSP           ; get top level stack pointer
09b0:9a           txs
09b1:60           rts                 ; exit out completely    
09b2:         
09b2:         asmError:
09b2:a5 46        lda error           ; error non-z?
09b4:f0 05        beq :fine
09b6:20 84 14     jsr ioError         ; print error
09b9:80 e8        bra exit            ; abort
09bb:         :fine
09bb:60           rts
09bc:         
09bc:         usageStr:
09bc:55 53 41 47 45 3a 20 3f 
09c4:49 4e 50 55 54 2e 41 53 
09cc:4d 5b 3b 4f 55 54 50 55 
09d4:54 5d 5b 3b 4c 49 53 54 
09dc:49 4e 47 5d 0d 
                 .db 'usage: ?input.asm[;output][;listing]',13
09e1:47 49 54 48 55 42 2e 43 
09e9:4f 4d 2f d0 41 55 4c c6 
09f1:4f 52 47 45 59 2f 58 41 
09f9:53 4d 0d 00 
                 .db 'github.com/PaulForgey/xasm',13,0
09fd:         passStr:
09fd:0d 50 41 53 53 3a 00 
                 .db 13,'pass:',0
0a04:         symendStr:
0a04:0d 53 59 4d 45 4e 44 3d 
0a0c:24 00        .db 13,'symend=$',0
0a0e:         pcStr:
0a0e:0d 50 43 3d 24 00 
                 .db 13,'pc=$',0
0a14:         
0a14:         ;
0a14:         ; returns next option in a/x/y
0a14:         getOpt:
0a14:a6 2d        ldx optPtr
0a16:86 22        stx scratch
0a18:a0 00        ldy #0
0a1a:         :loop
0a1a:bd 00 bf     lda options,x
0a1d:f0 0c        beq :got
0a1f:c9 0d        cmp #13         ; cr (shouldn't see this, but be defensive)
0a21:f0 08        beq :got
0a23:e8           inx
0a24:c9 3b        cmp #';
0a26:f0 03        beq :got
0a28:c8           iny
0a29:d0 ef        bne :loop
0a2b:         :got
0a2b:98           tya
0a2c:86 2d        stx optPtr
0a2e:a6 22        ldx scratch
0a30:a0 bf        ldy #>options
0a32:60           rts
0a33:          
0a33:             .in 'symtab.asm'
0a33:             .in 'zp.asm'
0a33:             .fi ; zpAsm
0a33:         
0a33:         ;
0a33:         ; initialize hash table
0a33:         symInit:
0a33:a9 00        lda #<symbols
0a35:85 41        sta symEnd
0a37:a9 27        lda #>symbols
0a39:85 42        sta symEnd+1
0a3b:a2 00        ldx #0
0a3d:         
0a3d:         :fill
0a3d:9e 00 26     stz hashTable,x
0a40:e8           inx
0a41:d0 fa        bne :fill
0a43:         
0a43:60           rts
0a44:         
0a44:         ; layout of a symbol entry:
0a44:         ; 00-01:    next (0 if end)
0a44:         ; 02-03:    scope (parent entry, or 0)
0a44:         ; 04:       caller status
0a44:         ; 05-07:    value
0a44:         ; 08-09:    filename declared in
0a44:         ; 0a:       filename length
0a44:         ; 0b-0c:    line number declared in
0a44:         
0a44:         ;
0a44:         ; enter or return existing symbol entry
0a44:         ; result in ptr
0a44:         symGet:
0a44:             ; string = strGet
0a44:             ; nptr = (string).symbols
0a44:20 b2 0a     jsr strGet
0a47:a0 02        ldy #2
0a49:b1 27        lda (ptr),y
0a4b:85 25        sta nptr
0a4d:a5 27        lda ptr
0a4f:85 23        sta string
0a51:c8           iny
0a52:b1 27        lda (ptr),y
0a54:85 26        sta nptr+1
0a56:a5 28        lda ptr+1
0a58:85 24        sta string+1
0a5a:         
0a5a:         :next
0a5a:20 55 0b     jsr ptrNext
0a5d:f0 0e        beq :notFound
0a5f:         
0a5f:             ; compare scope
0a5f:b1 27        lda (ptr),y
0a61:c5 2e        cmp symScope
0a63:d0 f5        bne :next
0a65:c8           iny
0a66:b1 27        lda (ptr),y
0a68:c5 2f        cmp symScope+1
0a6a:d0 ee        bne :next
0a6c:         
0a6c:             ; found!
0a6c:60           rts
0a6d:         
0a6d:         :notFound
0a6d:             ; push our scoped entry
0a6d:             ; ptr = symEnd
0a6d:             ; symEnd += $d
0a6d:a9 0d        lda #$d
0a6f:20 41 0b     jsr symPush
0a72:         
0a72:         
0a72:             ; nptr = (string).symbols
0a72:             ; (string).symbols = ptr
0a72:a0 02        ldy #2
0a74:b1 23        lda (string),y
0a76:85 25        sta nptr
0a78:a5 27        lda ptr
0a7a:91 23        sta (string),y
0a7c:c8           iny
0a7d:         
0a7d:b1 23        lda (string),y
0a7f:85 26        sta nptr+1
0a81:a5 28        lda ptr+1
0a83:91 23        sta (string),y
0a85:         
0a85:             ; (ptr++)=nptr
0a85:             ; next linkage
0a85:a0 00        ldy #0
0a87:a5 25        lda nptr
0a89:91 27        sta (ptr),y
0a8b:c8           iny
0a8c:         
0a8c:a5 26        lda nptr+1
0a8e:91 27        sta (ptr),y
0a90:c8           iny
0a91:         
0a91:             ; (ptr++)=scope
0a91:a5 2e        lda symScope
0a93:91 27        sta (ptr),y
0a95:c8           iny
0a96:         
0a96:a5 2f        lda symScope+1
0a98:91 27        sta (ptr),y
0a9a:c8           iny
0a9b:         
0a9b:             ; (ptr++)=0
0a9b:             ; zero out flags when creating
0a9b:a9 00        lda #0
0a9d:91 27        sta (ptr),y
0a9f:c8           iny
0aa0:         
0aa0:             ; (++ptr)=non-zero
0aa0:             ; default value (forward decl) not presumed to be zero page
0aa0:c8           iny
0aa1:98           tya
0aa2:91 27        sta (ptr),y
0aa4:         
0aa4:             ; copy name/nameLen/line
0aa4:a0 0c        ldy #8+4
0aa6:a2 04        ldx #4
0aa8:         :fileLine
0aa8:bd f2 20     lda input:name,x
0aab:91 27        sta (ptr),y
0aad:88           dey
0aae:ca           dex
0aaf:10 f7        bpl :fileLine
0ab1:         
0ab1:60           rts
0ab2:         
0ab2:         
0ab2:         ; layout of a string entry:
0ab2:         ; 00-01:    next (0 if end)
0ab2:         ; 02-03:    symbols having this label
0ab2:         ; 04-??:    counted string
0ab2:         
0ab2:         ;
0ab2:         ; enter or return existing counted string
0ab2:         ; result in ptr
0ab2:         strGet:
0ab2:             ; nptr = hash(symLabel)
0ab2:20 30 0b     jsr strHash
0ab5:bd 00 26     lda hashTable,x
0ab8:85 25        sta nptr
0aba:bd 01 26     lda hashTable+1,x
0abd:85 26        sta nptr+1
0abf:         
0abf:         :next
0abf:20 55 0b     jsr ptrNext
0ac2:f0 13        beq :notFound
0ac4:         
0ac4:             ; compare string
0ac4:             ; string = ptr+4
0ac4:a5 27        lda ptr
0ac6:18           clc
0ac7:69 04        adc #4
0ac9:85 23        sta string
0acb:a5 28        lda ptr+1
0acd:69 00        adc #0
0acf:85 24        sta string+1
0ad1:20 6c 0b     jsr strEqual
0ad4:d0 e9        bne :next
0ad6:         
0ad6:             ; found/created, result in ptr
0ad6:         :done
0ad6:60           rts
0ad7:         
0ad7:         :notFound
0ad7:             ; write new entry to head of list
0ad7:             ; nptr = hashEntry
0ad7:bd 00 26     lda hashTable,x
0ada:85 25        sta nptr
0adc:bd 01 26     lda hashTable+1,x
0adf:85 26        sta nptr+1
0ae1:         
0ae1:             ; hash = symEnd
0ae1:             ; ptr = symEnd
0ae1:             ; symEnd += 5 + symLength
0ae1:a9 05        lda #5
0ae3:20 41 0b     jsr symPush
0ae6:         
0ae6:a5 27        lda ptr
0ae8:9d 00 26     sta hashTable,x
0aeb:a5 28        lda ptr+1
0aed:9d 01 26     sta hashTable+1,x
0af0:         
0af0:a5 30        lda symLength
0af2:20 41 0b     jsr symPush
0af5:         
0af5:             ; (ptr++) = nptr
0af5:bd 00 26     lda hashTable,x
0af8:85 27        sta ptr
0afa:bd 01 26     lda hashTable+1,x
0afd:85 28        sta ptr+1
0aff:             
0aff:a5 25        lda nptr
0b01:92 27        sta (ptr)
0b03:a0 01        ldy #1
0b05:a5 26        lda nptr+1
0b07:91 27        sta (ptr),y
0b09:c8           iny
0b0a:         
0b0a:             ; (ptr++) = $0000
0b0a:             ; (symbol entries pointer)
0b0a:a9 00        lda #0
0b0c:91 27        sta (ptr),y
0b0e:c8           iny
0b0f:91 27        sta (ptr),y
0b11:c8           iny
0b12:         
0b12:             ; (ptr) = symLength
0b12:a5 30        lda symLength
0b14:91 27        sta (ptr),y
0b16:         
0b16:             ; string = ptr+5
0b16:a5 27        lda ptr
0b18:18           clc
0b19:69 05        adc #5
0b1b:85 23        sta string
0b1d:a5 28        lda ptr+1
0b1f:69 00        adc #0
0b21:85 24        sta string+1
0b23:         
0b23:a0 00        ldy #0
0b25:         :copy
0b25:c4 30        cpy symLength
0b27:f0 ad        beq :done
0b29:b1 31        lda (symLabel),y
0b2b:91 23        sta (string),y
0b2d:c8           iny
0b2e:d0 f5        bne :copy
0b30:         
0b30:         ;
0b30:         ; compute hash value for counted string
0b30:         strHash:
0b30:a5 30        lda symLength
0b32:a8           tay
0b33:18           clc
0b34:         :loop
0b34:f0 08        beq :done
0b36:88           dey
0b37:2a           rol                 ; c << output << c
0b38:51 31        eor (symLabel),y    ; output = output xor byte
0b3a:c8           iny
0b3b:88           dey
0b3c:d0 f6        bne :loop
0b3e:         
0b3e:             ; truncate to 7 bit
0b3e:         :done
0b3e:0a           asl
0b3f:aa           tax                 ; result in index form
0b40:60           rts
0b41:         
0b41:         ;
0b41:         ; push symEnd by A bytes
0b41:         ; ptr=symEnd before increment
0b41:         symPush:
0b41:85 22        sta scratch
0b43:a5 41        lda symEnd
0b45:85 27        sta ptr
0b47:18           clc
0b48:65 22        adc scratch
0b4a:85 41        sta symEnd
0b4c:a5 42        lda symEnd+1
0b4e:85 28        sta ptr+1
0b50:69 00        adc #0
0b52:85 42        sta symEnd+1
0b54:60           rts
0b55:         
0b55:         ;
0b55:         ; ptr=nptr, nptr=(ptr)
0b55:         ; Z if nptrH=0
0b55:         ; Y=2 otherwise
0b55:         ptrNext:
0b55:a5 26        lda nptr+1
0b57:f0 12        beq :out            ; nptrH=0
0b59:85 28        sta ptr+1
0b5b:a5 25        lda nptr
0b5d:85 27        sta ptr
0b5f:a0 00        ldy #0
0b61:b1 27        lda (ptr),y
0b63:85 25        sta nptr
0b65:c8           iny
0b66:b1 27        lda (ptr),y         ; Z=0
0b68:85 26        sta nptr+1
0b6a:c8           iny
0b6b:         :out
0b6b:60           rts
0b6c:         
0b6c:         ;
0b6c:         ; compare counted string at (string) against symLength/symLabel
0b6c:         ; for equality, Z=1 if so
0b6c:         strEqual:
0b6c:a0 00        ldy #0
0b6e:b1 23        lda (string),y
0b70:c5 30        cmp symLength
0b72:d0 0d        bne :out
0b74:         :loop
0b74:c4 30        cpy symLength
0b76:f0 09        beq :out
0b78:b1 31        lda (symLabel),y
0b7a:c8           iny
0b7b:d1 23        cmp (string),y
0b7d:d0 02        bne :out
0b7f:f0 f3        beq :loop
0b81:         :out
0b81:60           rts
0b82:         
0b82:         
0b82:             .in 'eval.asm'
0b82:             .in 'zp.asm'
0b82:             .fi ; zpAsm
0b82:         
0b82:         esInit  = 0
0b82:         esOp    = 1
0b82:         
0b82:         
0b82:         eDone:
0b82:             ; err if not in esOp state
0b82:18           clc
0b83:a5 3c        lda eState
0b85:f0 01        beq :error
0b87:60           rts
0b88:         :error
0b88:38           sec
0b89:60           rts
0b8a:         
0b8a:         ;
0b8a:         ; normalize petscii in A into lineBuf,x
0b8a:         ePet:
0b8a:85 22        sta scratch
0b8c:29 e0        and #$e0
0b8e:c9 60        cmp #$60        ; %011xxxxx -> %110xxxxx
0b90:d0 08        bne :nopet
0b92:a5 22        lda scratch
0b94:49 a0        eor #$a0
0b96:9d 00 25     sta lineBuf,x
0b99:60           rts
0b9a:         :nopet
0b9a:a5 22        lda scratch
0b9c:60           rts
0b9d:         
0b9d:         ;
0b9d:         ; evaluate expression at lineBuf,x
0b9d:         eEval:
0b9d:64 3c        stz eState
0b9f:64 3b        stz eOp
0ba1:64 35        stz arg
0ba3:64 36        stz arg+1
0ba5:20 3e 0e     jsr ePush
0ba8:         
0ba8:         :loop
0ba8:bd 00 25     lda lineBuf,x
0bab:             BEQ eDone       ; eof
0bab:          ISREL eDone       
0bab:          
0bab:          _ = eDone       -(*+2)
0bab:          
0bab:          _ = (_ < $80) . (!_ < $80)
0bab:          .if _
0bab:f0 d5     beq eDone       
0bad:          .fi
0bad:c9 2c        cmp #',
0baf:             BEQ eDone
0baf:          ISREL eDone
0baf:          
0baf:          _ = eDone-(*+2)
0baf:          
0baf:          _ = (_ < $80) . (!_ < $80)
0baf:          .if _
0baf:f0 d1     beq eDone
0bb1:          .fi
0bb1:c9 3b        cmp #';
0bb3:             BEQ eDone
0bb3:          ISREL eDone
0bb3:          
0bb3:          _ = eDone-(*+2)
0bb3:          
0bb3:          _ = (_ < $80) . (!_ < $80)
0bb3:          .if _
0bb3:f0 cd     beq eDone
0bb5:          .fi
0bb5:c9 29        cmp #')
0bb7:             BEQ eDone
0bb7:          ISREL eDone
0bb7:          
0bb7:          _ = eDone-(*+2)
0bb7:          
0bb7:          _ = (_ < $80) . (!_ < $80)
0bb7:          .if _
0bb7:f0 c9     beq eDone
0bb9:          .fi
0bb9:         
0bb9:a4 3c        ldy eState
0bbb:             BNE :op
0bbb:          ISREL :op
0bbb:          
0bbb:          _ = :op-(*+2)
0bbb:          
0bbb:          _ = (_ < $80) . (!_ < $80)
0bbb:          .if _
0bbb:d0 2c     bne :op
0bbd:          .fi
0bbd:         
0bbd:         :init
0bbd:20 72 0e     jsr eIsDec
0bc0:             BCS :dec
0bc0:          ISREL :dec
0bc0:          
0bc0:          _ = :dec-(*+2)
0bc0:          
0bc0:          _ = (_ < $80) . (!_ < $80)
0bc0:          .if _
0bc0:b0 55     bcs :dec
0bc2:          .fi
0bc2:20 bb 0e     jsr eIsSym
0bc5:             BEQ :tosym
0bc5:          ISREL :tosym
0bc5:          
0bc5:          _ = :tosym-(*+2)
0bc5:          
0bc5:          _ = (_ < $80) . (!_ < $80)
0bc5:          .if _
0bc5:f0 71     beq :tosym
0bc7:          .fi
0bc7:c9 25        cmp #'%
0bc9:             BEQ :bin
0bc9:          ISREL :bin
0bc9:          
0bc9:          _ = :bin-(*+2)
0bc9:          
0bc9:          _ = (_ < $80) . (!_ < $80)
0bc9:          .if _
0bc9:f0 62     beq :bin
0bcb:          .fi
0bcb:c9 24        cmp #'$
0bcd:             BEQ :hex
0bcd:          ISREL :hex
0bcd:          
0bcd:          _ = :hex-(*+2)
0bcd:          
0bcd:          _ = (_ < $80) . (!_ < $80)
0bcd:          .if _
0bcd:f0 53     beq :hex
0bcf:          .fi
0bcf:c9 28        cmp #'(
0bd1:             BEQ :sub
0bd1:          ISREL :sub
0bd1:          
0bd1:          _ = :sub-(*+2)
0bd1:          
0bd1:          _ = (_ < $80) . (!_ < $80)
0bd1:          .if _
0bd1:f0 6f     beq :sub
0bd3:          .fi
0bd3:c9 2a        cmp #'*
0bd5:             BEQ :pc
0bd5:          ISREL :pc
0bd5:          
0bd5:          _ = :pc-(*+2)
0bd5:          
0bd5:          _ = (_ < $80) . (!_ < $80)
0bd5:          .if _
0bd5:f0 7b     beq :pc
0bd7:          .fi
0bd7:c9 5f        cmp #'_
0bd9:             BEQ :accum
0bd9:          ISREL :accum
0bd9:          
0bd9:          _ = :accum-(*+2)
0bd9:          
0bd9:          _ = (_ < $80) . (!_ < $80)
0bd9:          .el
0bd9:d0 03     bne :@:not
0bdb:4c 5f 0c  jmp :accum
0bde:         :@:not:
0bde:          .fi
0bde:c9 27        cmp #''
0be0:             BEQ :char
0be0:          ISREL :char
0be0:          
0be0:          _ = :char-(*+2)
0be0:          
0be0:          _ = (_ < $80) . (!_ < $80)
0be0:          .el
0be0:d0 03     bne :@:not
0be2:4c 6c 0c  jmp :char
0be5:         :@:not:
0be5:          .fi
0be5:             
0be5:a0 80        ldy #$80        ; indicate unary
0be7:84 3b        sty eOp
0be9:             ; fall thru
0be9:         
0be9:         :op
0be9:e8           inx
0bea:         
0bea:29 7f        and #$7f        ; normalize petscii whitespace (shift+space)
0bec:c9 21        cmp #33         ; whitespace?
0bee:90 b8        bcc :loop
0bf0:         
0bf0:05 3b        ora eOp         ; push unary or binary op
0bf2:85 3b        sta eOp
0bf4:         
0bf4:c9 3e        cmp #'>
0bf6:f0 0a        beq :optwo
0bf8:             
0bf8:c9 3c        cmp #'<
0bfa:f0 06        beq :optwo
0bfc:         
0bfc:c9 21        cmp #'!
0bfe:f0 02        beq :optwo
0c00:             
0c00:80 0e        bra :opone
0c02:         
0c02:         :optwo
0c02:bd 00 25     lda lineBuf,x
0c05:c9 3d        cmp #'=
0c07:d0 07        bne :opone 
0c09:         
0c09:e8           inx             ; this is >=, <=, or !=
0c0a:a9 40        lda #$40        ; add 64 to indicate = suffix
0c0c:05 3b        ora eOp
0c0e:85 3b        sta eOp
0c10:         
0c10:         :opone
0c10:20 3e 0e     jsr ePush
0c13:64 3c        stz eState
0c15:             JMP :loop
0c15:          ISREL :loop
0c15:          
0c15:          _ = :loop-(*+2)
0c15:          
0c15:          _ = (_ < $80) . (!_ < $80)
0c15:          .if _
0c15:80 91     bra :loop
0c17:          .fi
0c17:         
0c17:         :dec
0c17:20 72 0e     jsr eIsDec
0c1a:             BCC :term       ; not a decimal digit?
0c1a:          ISREL :term       
0c1a:          
0c1a:          _ = :term       -(*+2)
0c1a:          
0c1a:          _ = (_ < $80) . (!_ < $80)
0c1a:          .if _
0c1a:90 64     bcc :term       
0c1c:          .fi
0c1c:20 dd 0d     jsr eDec
0c1f:e8           inx
0c20:d0 f5        bne :dec
0c22:         
0c22:         :hex
0c22:e8           inx
0c23:20 88 0e     jsr eIsHex
0c26:             BCC :term       ; not a hex digit?
0c26:          ISREL :term       
0c26:          
0c26:          _ = :term       -(*+2)
0c26:          
0c26:          _ = (_ < $80) . (!_ < $80)
0c26:          .if _
0c26:90 58     bcc :term       
0c28:          .fi
0c28:20 10 0e     jsr eHex
0c2b:80 f5        bra :hex
0c2d:             
0c2d:         :bin
0c2d:e8           inx
0c2e:20 99 0e     jsr eIsBin
0c31:             BNE :term       ; not a binary digit?
0c31:          ISREL :term       
0c31:          
0c31:          _ = :term       -(*+2)
0c31:          
0c31:          _ = (_ < $80) . (!_ < $80)
0c31:          .if _
0c31:d0 4d     bne :term       
0c33:          .fi
0c33:20 32 0e     jsr eBin
0c36:80 f5        bra :bin
0c38:         
0c38:         :tosym
0c38:86 3d        stx labelPtr    ; note where it starts
0c3a:             
0c3a:         :sym
0c3a:20 bb 0e     jsr eIsSym
0c3d:d0 38        bne :termsym
0c3f:e8           inx
0c40:80 f8        bra :sym
0c42:         
0c42:         :sub
0c42:e8           inx             ; skip '('
0c43:20 9d 0b     jsr eEval       ; evaluate subexpression
0c46:             BCS :out
0c46:          ISREL :out
0c46:          
0c46:          _ = :out-(*+2)
0c46:          
0c46:          _ = (_ < $80) . (!_ < $80)
0c46:          .if _
0c46:b0 46     bcs :out
0c48:          .fi
0c48:bd 00 25     lda lineBuf,x
0c4b:c9 29        cmp #')
0c4d:             BNE :term
0c4d:          ISREL :term
0c4d:          
0c4d:          _ = :term-(*+2)
0c4d:          
0c4d:          _ = (_ < $80) . (!_ < $80)
0c4d:          .if _
0c4d:d0 31     bne :term
0c4f:          .fi
0c4f:e8           inx             ; consume ')'
0c50:             JMP :term
0c50:          ISREL :term
0c50:          
0c50:          _ = :term-(*+2)
0c50:          
0c50:          _ = (_ < $80) . (!_ < $80)
0c50:          .if _
0c50:80 2e     bra :term
0c52:          .fi
0c52:         
0c52:         :pc
0c52:e8           inx             ; skip '*'
0c53:ad fe 20     lda pc          ; arg=pc
0c56:85 35        sta arg
0c58:ad ff 20     lda pc+1
0c5b:85 36        sta arg+1
0c5d:             JMP :term
0c5d:          ISREL :term
0c5d:          
0c5d:          _ = :term-(*+2)
0c5d:          
0c5d:          _ = (_ < $80) . (!_ < $80)
0c5d:          .if _
0c5d:80 21     bra :term
0c5f:          .fi
0c5f:         
0c5f:         :accum
0c5f:e8           inx             ; skip '*'
0c60:ad 00 21     lda accum       ; arg=accum
0c63:85 35        sta arg
0c65:ad 01 21     lda accum+1
0c68:85 36        sta arg+1
0c6a:             JMP :term
0c6a:          ISREL :term
0c6a:          
0c6a:          _ = :term-(*+2)
0c6a:          
0c6a:          _ = (_ < $80) . (!_ < $80)
0c6a:          .if _
0c6a:80 14     bra :term
0c6c:          .fi
0c6c:         
0c6c:         :char
0c6c:e8           inx             ; skip '
0c6d:bd 00 25     lda lineBuf,x   ; arg=literal character
0c70:e8           inx             ; consume
0c71:85 35        sta arg
0c73:64 36        stz arg+1
0c75:             JMP :term
0c75:          ISREL :term
0c75:          
0c75:          _ = :term-(*+2)
0c75:          
0c75:          _ = (_ < $80) . (!_ < $80)
0c75:          .if _
0c75:80 09     bra :term
0c77:          .fi
0c77:         
0c77:         :termsym
0c77:86 29        stx labelEnd
0c79:20 cf 0e     jsr eResolveSym ; resolve label value into arg
0c7c:             BCS :out
0c7c:          ISREL :out
0c7c:          
0c7c:          _ = :out-(*+2)
0c7c:          
0c7c:          _ = (_ < $80) . (!_ < $80)
0c7c:          .if _
0c7c:b0 10     bcs :out
0c7e:          .fi
0c7e:a6 29        ldx labelEnd
0c80:             ; fall thru
0c80:         
0c80:         :term
0c80:20 8f 0c     jsr eExec       ; pop and execute what we have so far
0c83:             BCS :out
0c83:          ISREL :out
0c83:          
0c83:          _ = :out-(*+2)
0c83:          
0c83:          _ = (_ < $80) . (!_ < $80)
0c83:          .if _
0c83:b0 09     bcs :out
0c85:          .fi
0c85:a9 01        lda #esOp       ; now in op state
0c87:85 3c        sta eState
0c89:64 3b        stz eOp         ; clear op, and not unary
0c8b:             JMP :loop
0c8b:          ISREL :loop
0c8b:          
0c8b:          _ = :loop-(*+2)
0c8b:          
0c8b:          _ = (_ < $80) . (!_ < $80)
0c8b:          .el
0c8b:4c a8 0b  jmp :loop
0c8e:          .fi
0c8e:         
0c8e:         :out    
0c8e:60           rts
0c8f:         
0c8f:         ;
0c8f:         ; exec term
0c8f:         eExec:
0c8f:20 99 0c     jsr eExecOne
0c92:b0 04        bcs :out
0c94:24 3b        bit eOp
0c96:30 f7        bmi eExec
0c98:         :out
0c98:60           rts
0c99:         
0c99:         eExecOne:
0c99:20 5b 0e     jsr ePop
0c9c:a5 3b        lda eOp
0c9e:             BEQ :assign
0c9e:          ISREL :assign
0c9e:          
0c9e:          _ = :assign-(*+2)
0c9e:          
0c9e:          _ = (_ < $80) . (!_ < $80)
0c9e:          .if _
0c9e:f0 63     beq :assign
0ca0:          .fi
0ca0:c9 2b        cmp #'+
0ca2:             BEQ :add
0ca2:          ISREL :add
0ca2:          
0ca2:          _ = :add-(*+2)
0ca2:          
0ca2:          _ = (_ < $80) . (!_ < $80)
0ca2:          .if _
0ca2:f0 61     beq :add
0ca4:          .fi
0ca4:c9 2d        cmp #'-
0ca6:             BEQ :sub
0ca6:          ISREL :sub
0ca6:          
0ca6:          _ = :sub-(*+2)
0ca6:          
0ca6:          _ = (_ < $80) . (!_ < $80)
0ca6:          .if _
0ca6:f0 6c     beq :sub
0ca8:          .fi
0ca8:c9 ad        cmp #$80+'- ; unary -
0caa:             BEQ :sub
0caa:          ISREL :sub
0caa:          
0caa:          _ = :sub-(*+2)
0caa:          
0caa:          _ = (_ < $80) . (!_ < $80)
0caa:          .if _
0caa:f0 68     beq :sub
0cac:          .fi
0cac:c9 26        cmp #'&
0cae:             BEQ :and
0cae:          ISREL :and
0cae:          
0cae:          _ = :and-(*+2)
0cae:          
0cae:          _ = (_ < $80) . (!_ < $80)
0cae:          .if _
0cae:f0 73     beq :and
0cb0:          .fi
0cb0:c9 5e        cmp #'^
0cb2:             BEQ :xor
0cb2:          ISREL :xor
0cb2:          
0cb2:          _ = :xor-(*+2)
0cb2:          
0cb2:          _ = (_ < $80) . (!_ < $80)
0cb2:          .el
0cb2:d0 03     bne :@:not
0cb4:4c 3f 0d  jmp :xor
0cb7:         :@:not:
0cb7:          .fi
0cb7:c9 2e        cmp #'.
0cb9:             BEQ :or
0cb9:          ISREL :or
0cb9:          
0cb9:          _ = :or-(*+2)
0cb9:          
0cb9:          _ = (_ < $80) . (!_ < $80)
0cb9:          .if _
0cb9:f0 76     beq :or
0cbb:          .fi
0cbb:c9 a1        cmp #$80+'! ; unary '!'
0cbd:             BEQ :not
0cbd:          ISREL :not
0cbd:          
0cbd:          _ = :not-(*+2)
0cbd:          
0cbd:          _ = (_ < $80) . (!_ < $80)
0cbd:          .el
0cbd:d0 03     bne :@:not
0cbf:4c 4d 0d  jmp :not
0cc2:         :@:not:
0cc2:          .fi
0cc2:c9 bc        cmp #$80+'< ; unary '<'
0cc4:             BEQ :lo
0cc4:          ISREL :lo
0cc4:          
0cc4:          _ = :lo-(*+2)
0cc4:          
0cc4:          _ = (_ < $80) . (!_ < $80)
0cc4:          .el
0cc4:d0 03     bne :@:not
0cc6:4c 5f 0d  jmp :lo
0cc9:         :@:not:
0cc9:          .fi
0cc9:c9 be        cmp #$80+'> ; unary '>'
0ccb:             BEQ :hi
0ccb:          ISREL :hi
0ccb:          
0ccb:          _ = :hi-(*+2)
0ccb:          
0ccb:          _ = (_ < $80) . (!_ < $80)
0ccb:          .el
0ccb:d0 03     bne :@:not
0ccd:4c 5b 0d  jmp :hi
0cd0:         :@:not:
0cd0:          .fi
0cd0:c9 3d        cmp #'=
0cd2:             BEQ :eq
0cd2:          ISREL :eq
0cd2:          
0cd2:          _ = :eq-(*+2)
0cd2:          
0cd2:          _ = (_ < $80) . (!_ < $80)
0cd2:          .el
0cd2:d0 03     bne :@:not
0cd4:4c 63 0d  jmp :eq
0cd7:         :@:not:
0cd7:          .fi
0cd7:c9 3e        cmp #'>
0cd9:             BEQ :gt
0cd9:          ISREL :gt
0cd9:          
0cd9:          _ = :gt-(*+2)
0cd9:          
0cd9:          _ = (_ < $80) . (!_ < $80)
0cd9:          .el
0cd9:d0 03     bne :@:not
0cdb:4c 71 0d  jmp :gt
0cde:         :@:not:
0cde:          .fi
0cde:c9 3c        cmp #'<
0ce0:             BEQ :lt
0ce0:          ISREL :lt
0ce0:          
0ce0:          _ = :lt-(*+2)
0ce0:          
0ce0:          _ = (_ < $80) . (!_ < $80)
0ce0:          .el
0ce0:d0 03     bne :@:not
0ce2:4c 81 0d  jmp :lt
0ce5:         :@:not:
0ce5:          .fi
0ce5:c9 7e        cmp #$40+'> ; >=
0ce7:             BEQ :ge
0ce7:          ISREL :ge
0ce7:          
0ce7:          _ = :ge-(*+2)
0ce7:          
0ce7:          _ = (_ < $80) . (!_ < $80)
0ce7:          .el
0ce7:d0 03     bne :@:not
0ce9:4c 91 0d  jmp :ge
0cec:         :@:not:
0cec:          .fi
0cec:c9 7c        cmp #$40+'< ; <=
0cee:             BEQ :le
0cee:          ISREL :le
0cee:          
0cee:          _ = :le-(*+2)
0cee:          
0cee:          _ = (_ < $80) . (!_ < $80)
0cee:          .el
0cee:d0 03     bne :@:not
0cf0:4c a1 0d  jmp :le
0cf3:         :@:not:
0cf3:          .fi
0cf3:c9 61        cmp #$40+'! ; !=
0cf5:             BEQ :ne
0cf5:          ISREL :ne
0cf5:          
0cf5:          _ = :ne-(*+2)
0cf5:          
0cf5:          _ = (_ < $80) . (!_ < $80)
0cf5:          .el
0cf5:d0 03     bne :@:not
0cf7:4c b1 0d  jmp :ne
0cfa:         :@:not:
0cfa:          .fi
0cfa:c9 25        cmp #'%
0cfc:             BEQ :align
0cfc:          ISREL :align
0cfc:          
0cfc:          _ = :align-(*+2)
0cfc:          
0cfc:          _ = (_ < $80) . (!_ < $80)
0cfc:          .el
0cfc:d0 03     bne :@:not
0cfe:4c cb 0d  jmp :align
0d01:         :@:not:
0d01:          .fi
0d01:38           sec
0d02:60           rts
0d03:         
0d03:         ;
0d03:         ; arg=arg
0d03:         :assign
0d03:18           clc
0d04:60           rts
0d05:         
0d05:         ;
0d05:         ; arg+=term
0d05:         :add
0d05:a5 35        lda arg
0d07:18           clc
0d08:65 37        adc term
0d0a:85 35        sta arg
0d0c:a5 36        lda arg+1
0d0e:65 38        adc term+1
0d10:85 36        sta arg+1
0d12:18           clc
0d13:60           rts
0d14:         
0d14:         ;
0d14:         ; arg=term-arg
0d14:         :sub
0d14:a5 37        lda term
0d16:38           sec
0d17:e5 35        sbc arg
0d19:85 35        sta arg
0d1b:a5 38        lda term+1
0d1d:e5 36        sbc arg+1
0d1f:85 36        sta arg+1
0d21:18           clc
0d22:60           rts
0d23:         
0d23:         ;
0d23:         ; arg&=term
0d23:         :and
0d23:a5 35        lda arg
0d25:25 37        and term
0d27:85 35        sta arg
0d29:a5 36        lda arg+1
0d2b:25 38        and term+1
0d2d:85 36        sta arg+1
0d2f:18           clc
0d30:60           rts
0d31:         
0d31:         ;
0d31:         ; arg.=term
0d31:         :or
0d31:a5 35        lda arg
0d33:05 37        ora term
0d35:85 35        sta arg
0d37:a5 36        lda arg+1
0d39:05 38        ora term+1
0d3b:85 36        sta arg+1
0d3d:18           clc
0d3e:60           rts
0d3f:         
0d3f:         ;
0d3f:         ; arg^=term
0d3f:         :xor
0d3f:a5 35        lda arg
0d41:45 37        eor term
0d43:85 35        sta arg
0d45:a5 36        lda arg+1
0d47:45 38        eor term+1
0d49:85 36        sta arg+1
0d4b:18           clc
0d4c:60           rts
0d4d:         
0d4d:         ;
0d4d:         ; arg=!arg
0d4d:         :not
0d4d:a5 35        lda arg
0d4f:49 ff        eor #$ff
0d51:85 35        sta arg
0d53:a5 36        lda arg+1
0d55:49 ff        eor #$ff
0d57:85 36        sta arg+1
0d59:18           clc
0d5a:60           rts
0d5b:         
0d5b:         ;
0d5b:         ; arg=>arg
0d5b:         :hi
0d5b:a5 36        lda arg+1
0d5d:85 35        sta arg
0d5f:             ; fall thru
0d5f:         
0d5f:         ;
0d5f:         ; arg=<arg
0d5f:         :lo
0d5f:64 36        stz arg+1
0d61:18           clc
0d62:60           rts
0d63:         
0d63:         ;
0d63:         ; arg=term?
0d63:         :eq
0d63:a5 35        lda arg
0d65:c5 37        cmp term
0d67:d0 5c        bne :false
0d69:a5 36        lda arg+1
0d6b:c5 38        cmp term+1
0d6d:d0 56        bne :false
0d6f:80 4c        bra :true
0d71:         
0d71:         ;
0d71:         ; term>arg?
0d71:         :gt
0d71:a5 36        lda arg+1
0d73:c5 38        cmp term+1
0d75:90 46        bcc :true
0d77:d0 4c        bne :false
0d79:a5 35        lda arg
0d7b:c5 37        cmp term
0d7d:90 3e        bcc :true
0d7f:80 44        bra :false
0d81:         
0d81:         ;
0d81:         ; term<arg?
0d81:         :lt
0d81:a5 38        lda term+1
0d83:c5 36        cmp arg+1
0d85:90 36        bcc :true
0d87:d0 3c        bne :false
0d89:a5 37        lda term
0d8b:c5 35        cmp arg
0d8d:90 2e        bcc :true
0d8f:80 34        bra :false
0d91:         
0d91:         ;
0d91:         ; term>=arg?
0d91:         :ge
0d91:a5 38        lda term+1
0d93:c5 36        cmp arg+1
0d95:90 2e        bcc :false
0d97:d0 24        bne :true
0d99:a5 37        lda term
0d9b:c5 35        cmp arg
0d9d:90 26        bcc :false
0d9f:80 1c        bra :true
0da1:         
0da1:         ; term<=arg?
0da1:         :le
0da1:a5 36        lda arg+1
0da3:c5 38        cmp term+1
0da5:90 1e        bcc :false
0da7:d0 14        bne :true
0da9:a5 35        lda arg
0dab:c5 37        cmp term
0dad:90 16        bcc :false
0daf:80 0c        bra :true
0db1:         
0db1:         ; term!=arg?
0db1:         :ne
0db1:a5 36        lda arg+1
0db3:c5 38        cmp term+1
0db5:d0 06        bne :true
0db7:a5 35        lda arg
0db9:c5 37        cmp term
0dbb:f0 08        beq :false
0dbd:         
0dbd:         :true
0dbd:a9 ff        lda #$ff
0dbf:85 35        sta arg
0dc1:85 36        sta arg+1
0dc3:18           clc
0dc4:60           rts
0dc5:         
0dc5:         :false
0dc5:64 35        stz arg
0dc7:64 36        stz arg+1
0dc9:18           clc
0dca:60           rts
0dcb:         
0dcb:         ; arg=term%arg
0dcb:         :align              ; limited to $100 max
0dcb:c6 35        dec arg
0dcd:a5 35        lda arg
0dcf:25 37        and term
0dd1:45 35        eor arg
0dd3:1a           inc
0dd4:25 35        and arg
0dd6:85 35        sta arg
0dd8:64 36        stz arg+1
0dda:             JMP :add
0dda:          ISREL :add
0dda:          
0dda:          _ = :add-(*+2)
0dda:          
0dda:          _ = (_ < $80) . (!_ < $80)
0dda:          .el
0dda:4c 05 0d  jmp :add
0ddd:          .fi
0ddd:         
0ddd:         ;
0ddd:         ; add decimal digit in lineBuf,x to arg
0ddd:         eDec:
0ddd:a5 35        lda arg         ; scratch=arg*8
0ddf:0a           asl
0de0:85 22        sta scratch
0de2:a5 36        lda arg+1
0de4:2a           rol
0de5:85 23        sta scratch+1
0de7:         
0de7:06 22        asl scratch
0de9:26 23        rol scratch+1
0deb:06 22        asl scratch
0ded:26 23        rol scratch+1
0def:         
0def:06 35        asl arg         ; arg=arg*2
0df1:26 36        rol arg+1
0df3:         
0df3:a5 35        lda arg         ; arg=arg+scratch
0df5:18           clc
0df6:65 22        adc scratch
0df8:85 35        sta arg
0dfa:a5 36        lda arg+1
0dfc:65 23        adc scratch+1
0dfe:85 36        sta arg+1
0e00:         
0e00:bd 00 25     lda lineBuf,x
0e03:38           sec
0e04:e9 30        sbc #'0
0e06:18           clc
0e07:65 35        adc arg
0e09:85 35        sta arg
0e0b:90 02        bcc :out
0e0d:e6 36        inc arg+1
0e0f:         :out
0e0f:60           rts
0e10:         
0e10:         ;
0e10:         ; add hex digit in lineBuf,x to arg
0e10:         eHex:
0e10:06 35        asl arg
0e12:26 36        rol arg+1
0e14:06 35        asl arg
0e16:26 36        rol arg+1
0e18:06 35        asl arg
0e1a:26 36        rol arg+1
0e1c:06 35        asl arg
0e1e:26 36        rol arg+1
0e20:         
0e20:bd 00 25     lda lineBuf,x
0e23:38           sec
0e24:e9 3a        sbc #'9+1
0e26:90 03        bcc :digit
0e28:e9 07        sbc #7
0e2a:18           clc
0e2b:         :digit
0e2b:69 0a        adc #10
0e2d:         
0e2d:05 35        ora arg
0e2f:85 35        sta arg
0e31:60           rts
0e32:         
0e32:         ;
0e32:         ; add binary digit in lineBuf,x to arg
0e32:         eBin:
0e32:06 35        asl arg
0e34:26 36        rol arg+1
0e36:38           sec
0e37:e9 30        sbc #'0
0e39:05 35        ora arg
0e3b:85 35        sta arg
0e3d:60           rts
0e3e:         
0e3e:         ;
0e3e:         ; push arg,op,state
0e3e:         ePush:
0e3e:a4 43        ldy ePtr
0e40:         
0e40:a5 3b        lda eOp
0e42:99 00 24     sta eStack,y
0e45:88           dey
0e46:         
0e46:a5 36        lda arg+1
0e48:99 00 24     sta eStack,y
0e4b:88           dey
0e4c:         
0e4c:a5 35        lda arg
0e4e:99 00 24     sta eStack,y
0e51:88           dey
0e52:         
0e52:84 43        sty ePtr
0e54:         
0e54:64 3b        stz eOp
0e56:64 35        stz arg
0e58:64 36        stz arg+1
0e5a:60           rts
0e5b:         
0e5b:         ;
0e5b:         ; pop term,op,state
0e5b:         ePop:
0e5b:a4 43        ldy ePtr
0e5d:         
0e5d:c8           iny
0e5e:b9 00 24     lda eStack,y
0e61:85 37        sta term
0e63:         
0e63:c8           iny
0e64:b9 00 24     lda eStack,y
0e67:85 38        sta term+1
0e69:         
0e69:c8           iny
0e6a:b9 00 24     lda eStack,y
0e6d:85 3b        sta eOp
0e6f:         
0e6f:84 43        sty ePtr
0e71:60           rts
0e72:         
0e72:         ;
0e72:         ; test if lineBuf,x is decimal digit
0e72:         ; C=1 if so
0e72:         eIsDec:
0e72:bd 00 25     lda lineBuf,x
0e75:c9 3a        cmp #'9+1
0e77:b0 03        bcs eIsNot
0e79:         
0e79:c9 30        cmp #'0
0e7b:60           rts
0e7c:         
0e7c:         eIsNot:
0e7c:18           clc
0e7d:60           rts
0e7e:         
0e7e:         ;
0e7e:         ; test if lineBuf,x is octal digit
0e7e:         ; C=1 if so, also returns char in A
0e7e:         eIsOct:
0e7e:bd 00 25     lda lineBuf,x
0e81:c9 38        cmp #'7+1
0e83:b0 f7        bcs eIsNot
0e85:         
0e85:c9 30        cmp #'0
0e87:60           rts
0e88:         
0e88:         ;
0e88:         ; test if lineBuf,x is hex digit
0e88:         ; C=1 if so
0e88:         ; side effect: uppercase normalized
0e88:         eIsHex:
0e88:20 72 0e     jsr eIsDec
0e8b:b0 0b        bcs :out
0e8d:20 8a 0b     jsr ePet
0e90:29 7f        and #$7f
0e92:         
0e92:c9 47        cmp #'f+1
0e94:b0 e6        bcs eIsNot
0e96:         
0e96:c9 41        cmp #'a
0e98:         :out
0e98:60           rts
0e99:         
0e99:         ;
0e99:         ; test if lineBuf,x is binary digit
0e99:         ; Z=1 if so
0e99:         eIsBin:
0e99:bd 00 25     lda lineBuf,x
0e9c:c9 31        cmp #'1
0e9e:f0 02        beq :out
0ea0:c9 30        cmp #'0
0ea2:         :out
0ea2:60           rts
0ea3:         
0ea3:         ;
0ea3:         ; test if lineBuf,X is alpha
0ea3:         ; C=1 if so
0ea3:         eIsAlpha:
0ea3:bd 00 25     lda lineBuf,x
0ea6:20 8a 0b     jsr ePet
0ea9:         
0ea9:c9 db        cmp #'z+128+1   ; 'Z'
0eab:b0 cf        bcs eIsNot      ; > 'Z'
0ead:         
0ead:c9 41        cmp #'a
0eaf:90 09        bcc :out        ; < 'a'
0eb1:         
0eb1:c9 c1        cmp #'a+128     ; 'A'
0eb3:b0 05        bcs :out        ; >= 'A' and <= 'Z'
0eb5:         
0eb5:c9 5b        cmp #'z+1
0eb7:b0 c3        bcs eIsNot      ; > 'z'
0eb9:         
0eb9:38           sec
0eba:         :out
0eba:60           rts
0ebb:         
0ebb:         ;
0ebb:         ; test if lineBuf,x is a valid symbol character
0ebb:         ; Z=1 if so
0ebb:         eIsSym:
0ebb:20 a3 0e     jsr eIsAlpha
0ebe:b0 0c        bcs :yes
0ec0:20 72 0e     jsr eIsDec
0ec3:b0 07        bcs :yes
0ec5:c9 3a        cmp #':
0ec7:f0 02        beq :zero
0ec9:c9 40        cmp #'@
0ecb:         :zero
0ecb:60           rts
0ecc:         :yes
0ecc:89 00        bit #0          ; set zero
0ece:60           rts
0ecf:         
0ecf:         ;
0ecf:         ; resolve label from lineBuf into arg
0ecf:         eResolveSym:
0ecf:a5 2e        lda symScope    ; note our current scope
0ed1:8d 0b 21     sta tScope
0ed4:a5 2f        lda symScope+1
0ed6:8d 0c 21     sta tScope+1
0ed9:         
0ed9:a4 3d        ldy labelPtr    ; start of label sequence
0edb:b9 00 25     lda lineBuf,y
0ede:c9 3a        cmp #':
0ee0:f0 04        beq :loop
0ee2:         
0ee2:64 2e        stz symScope    ; global scope
0ee4:64 2f        stz symScope+1
0ee6:         
0ee6:         :loop
0ee6:20 21 0f     jsr :next
0ee9:a5 30        lda symLength
0eeb:f0 0f        beq :skip       ; empty label in sequence means do not adjust scope
0eed:         
0eed:84 2b        sty emitY
0eef:20 44 0a     jsr symGet
0ef2:a4 2b        ldy emitY
0ef4:         
0ef4:a5 27        lda ptr
0ef6:85 2e        sta symScope
0ef8:a5 28        lda ptr+1
0efa:85 2f        sta symScope+1
0efc:         
0efc:         :skip
0efc:c4 29        cpy labelEnd
0efe:d0 e6        bne :loop
0f00:         
0f00:         :done
0f00:18           clc
0f01:a0 04        ldy #4
0f03:b1 27        lda (ptr),y     ; no forward reference in pass >0
0f05:d0 05        bne :fine
0f07:a5 40        lda pass
0f09:f0 01        beq :fine
0f0b:38           sec             ; set error
0f0c:         
0f0c:         :fine
0f0c:c8           iny             ; symbol value in arg
0f0d:b1 27        lda (ptr),y
0f0f:85 35        sta arg
0f11:c8           iny
0f12:b1 27        lda (ptr),y
0f14:85 36        sta arg+1
0f16:         
0f16:ad 0b 21     lda tScope      ; put scope back
0f19:85 2e        sta symScope
0f1b:ad 0c 21     lda tScope+1
0f1e:85 2f        sta symScope+1
0f20:         
0f20:60           rts
0f21:         
0f21:         :next
0f21:b9 00 25     lda lineBuf,y
0f24:c9 40        cmp #'@         ; @ is a special case
0f26:d0 12        bne :label
0f28:         
0f28:c8           iny             ; consume @
0f29:ad e7 20     lda ioPtr       ; reach into file/line including or playing us
0f2c:18           clc
0f2d:69 0a        adc #input:name-input
0f2f:85 31        sta symLabel
0f31:a9 23        lda #>ioStack
0f33:85 32        sta symLabel+1  ; ioStack is page aligned
0f35:a9 05        lda #5
0f37:85 30        sta symLength
0f39:60           rts
0f3a:         
0f3a:         :label
0f3a:84 31        sty symLabel    ; point symLabel at lineBuf+y
0f3c:a9 25        lda #>lineBuf   ; lineBuf is page aligned
0f3e:85 32        sta symLabel+1
0f40:64 30        stz symLength   ; reset length=0
0f42:         
0f42:         :search
0f42:b9 00 25     lda lineBuf,y
0f45:c8           iny
0f46:c9 3a        cmp #':
0f48:f0 06        beq :out        ; colon terminate at scope seperator
0f4a:e6 30        inc symLength
0f4c:c4 29        cpy labelEnd
0f4e:d0 f2        bne :search
0f50:         :out
0f50:60           rts
0f51:         
0f51:             .in 'line.asm'
0f51:             .in 'zp.asm'
0f51:             .fi ; zpAsm
0f51:             .in 'mode.asm'
0f51:             .fi ; modeAsm
0f51:         
0f51:         
0f51:         
0f51:         ;
0f51:         ; assembles lineBuf
0f51:         lineAsm:
0f51:ba           tsx
0f52:8e fb 20     stx lineSP
0f55:64 35        stz arg
0f57:64 36        stz arg+1
0f59:         
0f59:ad 10 21     lda inMac       ; recording a macro?
0f5c:f0 03        beq lineAsm2
0f5e:4c f6 18     jmp macLine     ; yes, feed this line to it
0f61:         
0f61:         lineAsm2:
0f61:a2 00        ldx #0
0f63:         
0f63:         :start
0f63:bd 00 25     lda lineBuf,x
0f66:20 8a 0b     jsr ePet
0f69:20 bb 0e     jsr eIsSym
0f6c:d0 03        bne :label
0f6e:e8           inx
0f6f:d0 f2        bne :start
0f71:         :label
0f71:64 27        stz ptr         ; assume no label yet
0f73:64 28        stz ptr+1
0f75:         
0f75:86 29        stx labelEnd
0f77:e0 00        cpx #0          ; no label
0f79:f0 07        beq :post
0f7b:         
0f7b:24 44        bit lineIfs     ; test if we are if'd out
0f7d:30 03        bmi :post
0f7f:         
0f7f:20 e8 11     jsr linePinLabel
0f82:         
0f82:         :post
0f82:20 11 14     jsr lineNextTokenExit
0f85:         
0f85:c9 3d        cmp #'=
0f87:             BNE :op
0f87:          ISREL :op
0f87:          
0f87:          _ = :op-(*+2)
0f87:          
0f87:          _ = (_ < $80) . (!_ < $80)
0f87:          .if _
0f87:d0 26     bne :op
0f89:          .fi
0f89:         
0f89:24 44        bit lineIfs
0f8b:             BMI :opdone
0f8b:          ISREL :opdone
0f8b:          
0f8b:          _ = :opdone-(*+2)
0f8b:          
0f8b:          _ = (_ < $80) . (!_ < $80)
0f8b:          .el
0f8b:10 03     bpl :@:not
0f8d:4c 0f 10  jmp :opdone
0f90:         :@:not:
0f90:          .fi
0f90:         
0f90:e8           inx             ; skip '='
0f91:a5 27        lda ptr
0f93:85 39        sta assign      ; assign=ptr
0f95:a5 28        lda ptr+1
0f97:             BEQ :assignError
0f97:          ISREL :assignError
0f97:          
0f97:          _ = :assignError-(*+2)
0f97:          
0f97:          _ = (_ < $80) . (!_ < $80)
0f97:          .if _
0f97:f0 2c     beq :assignError
0f99:          .fi
0f99:85 3a        sta assign+1
0f9b:         
0f9b:20 3b 14     jsr lineEval    ; eval rhs
0f9e:         
0f9e:a0 04        ldy #4          ; store evaluated result
0fa0:a9 81        lda #$81        ; this is not pc assigned
0fa2:91 39        sta (assign),y
0fa4:c8           iny
0fa5:a5 35        lda arg         ; store arg
0fa7:91 39        sta (assign),y
0fa9:c8           iny
0faa:a5 36        lda arg+1
0fac:91 39        sta (assign),y
0fae:60           rts
0faf:         
0faf:         :op
0faf:bd 00 25     lda lineBuf,x
0fb2:c9 2a        cmp #'*
0fb4:             BEQ :star
0fb4:          ISREL :star
0fb4:          
0fb4:          _ = :star-(*+2)
0fb4:          
0fb4:          _ = (_ < $80) . (!_ < $80)
0fb4:          .if _
0fb4:f0 30     beq :star
0fb6:          .fi
0fb6:c9 5f        cmp #'_
0fb8:             BEQ :accum
0fb8:          ISREL :accum
0fb8:          
0fb8:          _ = :accum-(*+2)
0fb8:          
0fb8:          _ = (_ < $80) . (!_ < $80)
0fb8:          .if _
0fb8:f0 15     beq :accum
0fba:          .fi
0fba:c9 2e        cmp #'.
0fbc:             BEQ :dot
0fbc:          ISREL :dot
0fbc:          
0fbc:          _ = :dot-(*+2)
0fbc:          
0fbc:          _ = (_ < $80) . (!_ < $80)
0fbc:          .if _
0fbc:f0 52     beq :dot
0fbe:          .fi
0fbe:         
0fbe:24 44        bit lineIfs
0fc0:             BMI :opdone     ; if'd out
0fc0:          ISREL :opdone     
0fc0:          
0fc0:          _ = :opdone     -(*+2)
0fc0:          
0fc0:          _ = (_ < $80) . (!_ < $80)
0fc0:          .if _
0fc0:30 4d     bmi :opdone     
0fc2:          .fi
0fc2:         
0fc2:4c 5e 12     jmp lineIsn
0fc5:         
0fc5:         :assignError
0fc5:a9 0a        lda #errors:assign
0fc7:85 46        sta error
0fc9:60           rts
0fca:         
0fca:         :backwardError
0fca:a9 06        lda #errors:backward
0fcc:85 46        sta error
0fce:60           rts
0fcf:         
0fcf:         :accum
0fcf:e8           inx             ; skip '_'
0fd0:20 11 14     jsr lineNextTokenExit
0fd3:c9 3d        cmp #'=
0fd5:             BNE :assignError
0fd5:          ISREL :assignError
0fd5:          
0fd5:          _ = :assignError-(*+2)
0fd5:          
0fd5:          _ = (_ < $80) . (!_ < $80)
0fd5:          .if _
0fd5:d0 ee     bne :assignError
0fd7:          .fi
0fd7:e8           inx
0fd8:20 3b 14     jsr lineEval
0fdb:a5 35        lda arg         ; accum=arg
0fdd:8d 00 21     sta accum
0fe0:a5 36        lda arg+1
0fe2:8d 01 21     sta accum+1
0fe5:60           rts
0fe6:         
0fe6:         :star
0fe6:e8           inx             ; skip '*'
0fe7:20 11 14     jsr lineNextTokenExit
0fea:c9 3d        cmp #'=
0fec:             BNE :opdone
0fec:          ISREL :opdone
0fec:          
0fec:          _ = :opdone-(*+2)
0fec:          
0fec:          _ = (_ < $80) . (!_ < $80)
0fec:          .if _
0fec:d0 21     bne :opdone
0fee:          .fi
0fee:e8           inx             ; consume '='
0fef:e6 40        inc pass        ; cannot be forward reference
0ff1:20 3b 14     jsr lineEval
0ff4:c6 40        dec pass
0ff6:         
0ff6:         :starloop
0ff6:a5 36        lda arg+1
0ff8:cd ff 20     cmp pc+1
0ffb:             BCC :backwardError
0ffb:          ISREL :backwardError
0ffb:          
0ffb:          _ = :backwardError-(*+2)
0ffb:          
0ffb:          _ = (_ < $80) . (!_ < $80)
0ffb:          .if _
0ffb:90 cd     bcc :backwardError
0ffd:          .fi
0ffd:d0 09        bne :stardo
0fff:a5 35        lda arg
1001:cd fe 20     cmp pc
1004:             BCC :backwardError
1004:          ISREL :backwardError
1004:          
1004:          _ = :backwardError-(*+2)
1004:          
1004:          _ = (_ < $80) . (!_ < $80)
1004:          .if _
1004:90 c4     bcc :backwardError
1006:          .fi
1006:f0 07        beq :stardone
1008:         :stardo
1008:a9 00        lda #0
100a:20 53 12     jsr lineEmit    ; emit zeros until desired pc
100d:80 e7        bra :starloop
100f:         
100f:         :stardone
100f:         :opdone
100f:60           rts
1010:         
1010:         :dot
1010:e8           inx             ; skip '.'
1011:bd 01 25     lda lineBuf+1,x
1014:a8           tay             ; second char in Y
1015:bd 00 25     lda lineBuf,x   ; first char in A
1018:e8           inx
1019:e8           inx             ; skip the two (if not present, we will err anyway)
101a:         
101a:c9 45        cmp #'e
101c:             BEQ :E
101c:          ISREL :E
101c:          
101c:          _ = :E-(*+2)
101c:          
101c:          _ = (_ < $80) . (!_ < $80)
101c:          .if _
101c:f0 1d     beq :E
101e:          .fi
101e:c9 46        cmp #'f
1020:             BEQ :F
1020:          ISREL :F
1020:          
1020:          _ = :F-(*+2)
1020:          
1020:          _ = (_ < $80) . (!_ < $80)
1020:          .if _
1020:f0 2e     beq :F
1022:          .fi
1022:c9 49        cmp #'i
1024:             BEQ :I
1024:          ISREL :I
1024:          
1024:          _ = :I-(*+2)
1024:          
1024:          _ = (_ < $80) . (!_ < $80)
1024:          .if _
1024:f0 39     beq :I
1026:          .fi
1026:         
1026:24 44        bit lineIfs
1028:             BMI :opdone     ; if'd out
1028:          ISREL :opdone     
1028:          
1028:          _ = :opdone     -(*+2)
1028:          
1028:          _ = (_ < $80) . (!_ < $80)
1028:          .if _
1028:30 e5     bmi :opdone     
102a:          .fi
102a:         
102a:c9 4f        cmp #'o
102c:             BEQ :O
102c:          ISREL :O
102c:          
102c:          _ = :O-(*+2)
102c:          
102c:          _ = (_ < $80) . (!_ < $80)
102c:          .if _
102c:f0 28     beq :O
102e:          .fi
102e:c9 44        cmp #'d
1030:             BEQ :D
1030:          ISREL :D
1030:          
1030:          _ = :D-(*+2)
1030:          
1030:          _ = (_ < $80) . (!_ < $80)
1030:          .if _
1030:f0 48     beq :D
1032:          .fi
1032:c9 4d        cmp #'m
1034:             BEQ :M
1034:          ISREL :M
1034:          
1034:          _ = :M-(*+2)
1034:          
1034:          _ = (_ < $80) . (!_ < $80)
1034:          .if _
1034:f0 55     beq :M
1036:          .fi
1036:         
1036:             ; fall thru
1036:         
1036:         :dotOpError
1036:a9 0c        lda #errors:dotOp
1038:85 46        sta error
103a:60           rts
103b:         
103b:         :E
103b:c0 49        cpy #'i
103d:             BEQ :EI
103d:          ISREL :EI
103d:          
103d:          _ = :EI-(*+2)
103d:          
103d:          _ = (_ < $80) . (!_ < $80)
103d:          .if _
103d:f0 69     beq :EI
103f:          .fi
103f:c0 4c        cpy #'l
1041:             BEQ :EL
1041:          ISREL :EL
1041:          
1041:          _ = :EL-(*+2)
1041:          
1041:          _ = (_ < $80) . (!_ < $80)
1041:          .if _
1041:f0 51     beq :EL
1043:          .fi
1043:         
1043:24 44        bit lineIfs
1045:             BMI :opdone     ; if'd out
1045:          ISREL :opdone     
1045:          
1045:          _ = :opdone     -(*+2)
1045:          
1045:          _ = (_ < $80) . (!_ < $80)
1045:          .if _
1045:30 c8     bmi :opdone     
1047:          .fi
1047:         
1047:c0 4d        cpy #'m
1049:             BEQ :EM
1049:          ISREL :EM
1049:          
1049:          _ = :EM-(*+2)
1049:          
1049:          _ = (_ < $80) . (!_ < $80)
1049:          .el
1049:d0 03     bne :@:not
104b:4c d3 11  jmp :EM
104e:         :@:not:
104e:          .fi
104e:             JMP :dotOpError
104e:          ISREL :dotOpError
104e:          
104e:          _ = :dotOpError-(*+2)
104e:          
104e:          _ = (_ < $80) . (!_ < $80)
104e:          .if _
104e:80 e6     bra :dotOpError
1050:          .fi
1050:         
1050:         :F
1050:c0 49        cpy #'i
1052:             BEQ :FI
1052:          ISREL :FI
1052:          
1052:          _ = :FI-(*+2)
1052:          
1052:          _ = (_ < $80) . (!_ < $80)
1052:          .if _
1052:f0 76     beq :FI
1054:          .fi
1054:             JMP :dotOpError
1054:          ISREL :dotOpError
1054:          
1054:          _ = :dotOpError-(*+2)
1054:          
1054:          _ = (_ < $80) . (!_ < $80)
1054:          .if _
1054:80 e0     bra :dotOpError
1056:          .fi
1056:         
1056:         :O
1056:c0 52        cpy #'r
1058:             BEQ :OR
1058:          ISREL :OR
1058:          
1058:          _ = :OR-(*+2)
1058:          
1058:          _ = (_ < $80) . (!_ < $80)
1058:          .el
1058:d0 03     bne :@:not
105a:4c 52 11  jmp :OR
105d:         :@:not:
105d:          .fi
105d:             JMP :dotOpError
105d:          ISREL :dotOpError
105d:          
105d:          _ = :dotOpError-(*+2)
105d:          
105d:          _ = (_ < $80) . (!_ < $80)
105d:          .if _
105d:80 d7     bra :dotOpError
105f:          .fi
105f:         
105f:         :I
105f:c0 46        cpy #'f
1061:             BEQ :IF
1061:          ISREL :IF
1061:          
1061:          _ = :IF-(*+2)
1061:          
1061:          _ = (_ < $80) . (!_ < $80)
1061:          .el
1061:d0 03     bne :@:not
1063:4c 72 11  jmp :IF
1066:         :@:not:
1066:          .fi
1066:         
1066:24 44        bit lineIfs
1068:             BMI :opdone     ; if'd out
1068:          ISREL :opdone     
1068:          
1068:          _ = :opdone     -(*+2)
1068:          
1068:          _ = (_ < $80) . (!_ < $80)
1068:          .if _
1068:30 a5     bmi :opdone     
106a:          .fi
106a:         
106a:c0 4e        cpy #'n
106c:             BEQ :IN
106c:          ISREL :IN
106c:          
106c:          _ = :IN-(*+2)
106c:          
106c:          _ = (_ < $80) . (!_ < $80)
106c:          .el
106c:d0 03     bne :@:not
106e:4c 63 11  jmp :IN
1071:         :@:not:
1071:          .fi
1071:c0 42        cpy #'b
1073:             BEQ :IB
1073:          ISREL :IB
1073:          
1073:          _ = :IB-(*+2)
1073:          
1073:          _ = (_ < $80) . (!_ < $80)
1073:          .el
1073:d0 03     bne :@:not
1075:4c 69 11  jmp :IB
1078:         :@:not:
1078:          .fi
1078:             JMP :dotOpError
1078:          ISREL :dotOpError
1078:          
1078:          _ = :dotOpError-(*+2)
1078:          
1078:          _ = (_ < $80) . (!_ < $80)
1078:          .if _
1078:80 bc     bra :dotOpError
107a:          .fi
107a:           
107a:         :D
107a:c0 42        cpy #'b
107c:             BEQ :DB
107c:          ISREL :DB
107c:          
107c:          _ = :DB-(*+2)
107c:          
107c:          _ = (_ < $80) . (!_ < $80)
107c:          .if _
107c:f0 53     beq :DB
107e:          .fi
107e:c0 57        cpy #'w
1080:             BEQ :DW
1080:          ISREL :DW
1080:          
1080:          _ = :DW-(*+2)
1080:          
1080:          _ = (_ < $80) . (!_ < $80)
1080:          .if _
1080:f0 79     beq :DW
1082:          .fi
1082:c0 46        cpy #'f
1084:             BEQ :DF
1084:          ISREL :DF
1084:          
1084:          _ = :DF-(*+2)
1084:          
1084:          _ = (_ < $80) . (!_ < $80)
1084:          .el
1084:d0 03     bne :@:not
1086:4c 14 11  jmp :DF
1089:         :@:not:
1089:          .fi
1089:             JMP :dotOpError
1089:          ISREL :dotOpError
1089:          
1089:          _ = :dotOpError-(*+2)
1089:          
1089:          _ = (_ < $80) . (!_ < $80)
1089:          .if _
1089:80 ab     bra :dotOpError
108b:          .fi
108b:         
108b:         :M
108b:c0 41        cpy #'a
108d:             BEQ :MA
108d:          ISREL :MA
108d:          
108d:          _ = :MA-(*+2)
108d:          
108d:          _ = (_ < $80) . (!_ < $80)
108d:          .el
108d:d0 03     bne :@:not
108f:4c 9f 11  jmp :MA
1092:         :@:not:
1092:          .fi
1092:             JMP :dotOpError
1092:          ISREL :dotOpError
1092:          
1092:          _ = :dotOpError-(*+2)
1092:          
1092:          _ = (_ < $80) . (!_ < $80)
1092:          .if _
1092:80 a2     bra :dotOpError
1094:          .fi
1094:         
1094:         :EL
1094:24 45        bit lineIfd     ; have we chosen our destiny
1096:10 07        bpl :else
1098:a9 80        lda #$80        ; prior destiny has already been set
109a:04 44        tsb lineIfs
109c:4c 23 14     jmp lineAssertEnd
109f:         
109f:         :else
109f:a5 44        lda lineIfs     ; flip top if bit
10a1:49 80        eor #$80
10a3:85 44        sta lineIfs
10a5:4c 23 14     jmp lineAssertEnd
10a8:         
10a8:         :EI
10a8:20 2f 14     jsr lineAssertToken
10ab:         
10ab:24 45        bit lineIfd     ; have we chosen our destiny
10ad:10 05        bpl :elseif
10af:a9 80        lda #$80        ; stay false
10b1:04 44        tsb lineIfs     ; prior destiny has already been set
10b3:60           rts
10b4:         
10b4:         :elseif
10b4:20 3b 14     jsr lineEval
10b7:20 47 12     jsr lineTruth
10ba:06 44        asl lineIfs
10bc:a5 36        lda arg+1       ; top of ifs stack becomes condition
10be:29 80        and #$80
10c0:04 45        tsb lineIfd     ; destiny set
10c2:49 80        eor #$80
10c4:0a           asl
10c5:66 44        ror lineIfs
10c7:4c 23 14     jmp lineAssertEnd
10ca:         
10ca:         :FI
10ca:06 44        asl lineIfs     ; pop if stack
10cc:06 45        asl lineIfd     ; pop destiny stack
10ce:4c 23 14     jmp lineAssertEnd
10d1:         
10d1:         :DB
10d1:64 35        stz arg
10d3:20 11 14     jsr lineNextTokenExit
10d6:c9 27        cmp #''
10d8:f0 11        beq :string
10da:c9 2c        cmp #',
10dc:f0 0a        beq :DBcomma
10de:         
10de:20 3b 14     jsr lineEval
10e1:a5 35        lda arg         ; send it
10e3:20 53 12     jsr lineEmit
10e6:         
10e6:80 e9        bra :DB
10e8:         
10e8:         :DBcomma
10e8:e8           inx             ; consume ',' ready for next
10e9:80 e6        bra :DB
10eb:         
10eb:         :string
10eb:e8           inx
10ec:bd 00 25     lda lineBuf,x
10ef:f0 09        beq :stringEOF
10f1:c9 27        cmp #''
10f3:f0 f3        beq :DBcomma
10f5:         
10f5:20 53 12     jsr lineEmit    ; send it
10f8:80 f1        bra :string
10fa:         :stringEOF
10fa:60           rts
10fb:         
10fb:         :DW
10fb:20 11 14     jsr lineNextTokenExit
10fe:c9 2c        cmp #',
1100:f0 0f        beq :DWcomma
1102:         
1102:20 3b 14     jsr lineEval
1105:         
1105:a5 35        lda arg         ; send it
1107:20 53 12     jsr lineEmit
110a:a5 36        lda arg+1
110c:20 53 12     jsr lineEmit
110f:         
110f:80 ea        bra :DW
1111:         
1111:         :DWcomma
1111:e8           inx             ; consume ',' ready for next word
1112:80 e7        bra :DW
1114:         
1114:         :DF
1114:20 11 14     jsr lineNextTokenExit
1117:         
1117:86 2a        stx emitX
1119:         :DFscan
1119:20 f4 13     jsr lineEnd
111c:f0 07        beq :DFscanned
111e:c9 2c        cmp #',
1120:f0 03        beq :DFscanned
1122:e8           inx
1123:d0 f4        bne :DFscan
1125:         
1125:         :DFscanned
1125:86 22        stx scratch
1127:8a           txa
1128:38           sec
1129:e5 2a        sbc emitX       ; A: length
112b:a6 2a        ldx emitX       ; X/Y: string
112d:a0 25        ldy #>lineBuf
112f:20 09 fe     jsr VAL1
1132:a2 e0        ldx #<fpack
1134:a0 20        ldy #>fpack
1136:20 66 fe     jsr MOVMF       ; pack FACC->constant
1139:         
1139:a6 22        ldx scratch     ; get X back
113b:a0 00        ldy #0
113d:         
113d:         :DFemit
113d:b9 e0 20     lda fpack,y     ; write 5 byte packed output
1140:20 53 12     jsr lineEmit
1143:c8           iny
1144:c0 05        cpy #5
1146:d0 f5        bne :DFemit
1148:         
1148:         :DFnext
1148:bd 00 25     lda lineBuf,x
114b:c9 2c        cmp #',
114d:d0 c5        bne :DF
114f:e8           inx             ; consume ,
1150:80 c2        bra :DF
1152:         
1152:         :OR
1152:20 2f 14     jsr lineAssertToken
1155:         
1155:20 3b 14     jsr lineEval
1158:         
1158:a5 35        lda arg
115a:8d fe 20     sta pc
115d:a5 36        lda arg+1
115f:8d ff 20     sta pc+1
1162:60           rts
1163:         
1163:         :IN
1163:20 cf 13     jsr lineGetName
1166:4c 94 15     jmp ioPushFile
1169:         
1169:         :IB
1169:20 cf 13     jsr lineGetName
116c:20 94 15     jsr ioPushFile
116f:4c 13 17     jmp ioCopy
1172:         
1172:         :IF
1172:20 2f 14     jsr lineAssertToken
1175:         
1175:24 44        bit lineIfs
1177:30 17        bmi :falseIf
1179:         
1179:20 3b 14     jsr lineEval
117c:20 47 12     jsr lineTruth
117f:a5 36        lda arg+1
1181:29 80        and #$80
1183:0a           asl
1184:66 45        ror lineIfd     ; desinty set
1186:a5 36        lda arg+1
1188:49 80        eor #$80
118a:0a           asl             ; truth->C
118b:66 44        ror lineIfs     ; push if stack
118d:4c 23 14     jmp lineAssertEnd
1190:         
1190:         :falseIf
1190:38           sec
1191:66 44        ror lineIfs     ; stay in false state
1193:38           sec
1194:66 45        ror lineIfd     ; and this is our destiny at this level
1196:60           rts
1197:         
1197:         :assignErrorB
1197:4c c5 0f     jmp :assignError
119a:         
119a:         :inMacError
119a:a9 22        lda #errors:inMac
119c:85 46        sta error
119e:60           rts
119f:         
119f:         :MA
119f:20 23 14     jsr lineAssertEnd
11a2:a5 28        lda ptr+1       ; check we have a label
11a4:             BEQ :assignError
11a4:          ISREL :assignError
11a4:          
11a4:          _ = :assignError-(*+2)
11a4:          
11a4:          _ = (_ < $80) . (!_ < $80)
11a4:          .el
11a4:d0 03     bne :@:not
11a6:4c c5 0f  jmp :assignError
11a9:         :@:not:
11a9:          .fi
11a9:ad 10 21     lda inMac       ; are we already doing a macro?
11ac:             BNE :inMacError
11ac:          ISREL :inMacError
11ac:          
11ac:          _ = :inMacError-(*+2)
11ac:          
11ac:          _ = (_ < $80) . (!_ < $80)
11ac:          .if _
11ac:d0 ec     bne :inMacError
11ae:          .fi
11ae:a5 40        lda pass
11b0:d0 18        bne :MApass     ; pass 0 only
11b2:a0 04        ldy #4
11b4:a9 02        lda #$02        ; indicate macro
11b6:91 27        sta (ptr),y
11b8:c8           iny
11b9:ad 0d 21     lda bank
11bc:91 27        sta (ptr),y     ; note the bank and himem area we start
11be:c8           iny
11bf:ad 0e 21     lda himem
11c2:91 27        sta (ptr),y
11c4:c8           iny
11c5:ad 0f 21     lda himem+1
11c8:91 27        sta (ptr),y
11ca:         :MApass
11ca:ee 10 21     inc inMac       ; and we're now recording
11cd:60           rts
11ce:         
11ce:         :noMacError
11ce:a9 24        lda #errors:noMac
11d0:85 46        sta error
11d2:60           rts
11d3:         
11d3:         :EM
11d3:20 23 14     jsr lineAssertEnd
11d6:ad 10 21     lda inMac       ; are we doing a macro?
11d9:             BEQ :noMacError
11d9:          ISREL :noMacError
11d9:          
11d9:          _ = :noMacError-(*+2)
11d9:          
11d9:          _ = (_ < $80) . (!_ < $80)
11d9:          .if _
11d9:f0 f3     beq :noMacError
11db:          .fi
11db:a5 40        lda pass
11dd:d0 05        bne :out        ; pass 0 only
11df:a9 00        lda #0          ; write our terminating 0
11e1:20 77 18     jsr hiWrite
11e4:         :out
11e4:9c 10 21     stz inMac
11e7:60           rts
11e8:         
11e8:         ;
11e8:         ; resolve label field into ptr, adjusting symScope if necessary
11e8:         linePinLabel:
11e8:64 3d        stz labelPtr
11ea:20 cf 0e     jsr eResolveSym
11ed:ad 00 25     lda lineBuf
11f0:c9 3a        cmp #':
11f2:f0 08        beq :local
11f4:a5 27        lda ptr
11f6:85 2e        sta symScope    ; this becomes our new scope
11f8:a5 28        lda ptr+1
11fa:85 2f        sta symScope+1
11fc:         :local
11fc:24 44        bit lineIfs
11fe:30 16        bmi :out        ; if'd out, just return it
1200:a0 04        ldy #4
1202:b1 27        lda (ptr),y
1204:d0 13        bne :check
1206:a9 01        lda #$01        ; indicate label
1208:91 27        sta (ptr),y
120a:c8           iny
120b:         :setpc
120b:ad fe 20     lda pc
120e:91 27        sta (ptr),y     ; initially store pc
1210:c8           iny
1211:ad ff 20     lda pc+1
1214:91 27        sta (ptr),y     ; may be set later with =expr
1216:         
1216:         :out
1216:a6 29        ldx labelEnd    ; restore x
1218:60           rts
1219:         
1219:         :check
1219:a6 40        ldx pass        ; pass 0 should see these all first time
121b:             BEQ lineDupLabel
121b:          ISREL lineDupLabel
121b:          
121b:          _ = lineDupLabel-(*+2)
121b:          
121b:          _ = (_ < $80) . (!_ < $80)
121b:          .if _
121b:f0 1c     beq lineDupLabel
121d:          .fi
121d:c9 01        cmp #$01        ; label (not macro or assigment) moved?
121f:d0 f5        bne :out
1221:         
1221:c8           iny
1222:b1 27        lda (ptr),y
1224:cd fe 20     cmp pc
1227:d0 08        bne :moved      ; yes
1229:c8           iny
122a:b1 27        lda (ptr),y
122c:cd ff 20     cmp pc+1
122f:f0 e5        beq :out        ; no
1231:         
1231:         :moved
1231:a9 40        lda #$40        ; flag we need another pass
1233:04 40        tsb pass
1235:a0 05        ldy #5
1237:80 d2        bra :setpc      ; and update
1239:         
1239:         lineDupLabel:
1239:a9 02        lda #errors:dupLabel
123b:85 46        sta error
123d:4c 16 14     jmp lineExit
1240:         
1240:         lineEmitError:
1240:a9 18        lda #errors:emit
1242:85 46        sta error
1244:4c 16 14     jmp lineExit
1247:         
1247:         ;
1247:         ; normalize non-0 to $8xxx for if checking
1247:         lineTruth:
1247:a5 35        lda arg
1249:05 36        ora arg+1
124b:d0 01        bne :true
124d:60           rts
124e:         :true
124e:a9 ff        lda #$ff
1250:85 36        sta arg+1
1252:60           rts
1253:         
1253:         ;
1253:         ; emit byte
1253:         ; pc incremented, (emit) called
1253:         lineEmit:
1253:20 79 14     jsr ioEmit
1256:b0 e8        bcs lineEmitError
1258:60           rts
1259:         
1259:         lineOpError:
1259:a9 0e        lda #errors:op
125b:85 46        sta error
125d:60           rts
125e:         
125e:         ;
125e:         ; isn (arg) part
125e:         lineIsn:
125e:20 d5 1b     jsr isnGet
1261:             BCC :isn
1261:          ISREL :isn
1261:          
1261:          _ = :isn-(*+2)
1261:          
1261:          _ = (_ < $80) . (!_ < $80)
1261:          .if _
1261:90 1e     bcc :isn
1263:          .fi
1263:         
1263:86 3d        stx labelPtr
1265:         :macend
1265:20 bb 0e     jsr eIsSym
1268:d0 03        bne :macended
126a:e8           inx
126b:d0 f8        bne :macend
126d:         :macended
126d:86 29        stx labelEnd
126f:20 cf 0e     jsr eResolveSym ; see if it exists as macro name
1272:b0 e5        bcs lineOpError ; not a macro name
1274:a0 04        ldy #4
1276:b1 27        lda (ptr),y
1278:c9 02        cmp #$02
127a:d0 dd        bne lineOpError ; not a macro name
127c:a6 29        ldx labelEnd
127e:4c 59 19     jmp macPlay     ; replay the macro data
1281:         
1281:         :isn
1281:a9 07        lda #modeImp
1283:85 34        sta isnMode     ; assume implied
1285:64 2c        stz isnBit      ; start not assuming bit instruction
1287:e8           inx             ; skip isn
1288:e8           inx
1289:e8           inx
128a:20 7e 0e     jsr eIsOct      ; test for bit number
128d:90 03        bcc :notbitn
128f:85 2c        sta isnBit      ; '0'-'7' if this is a bitn
1291:e8           inx
1292:         
1292:         :notbitn
1292:20 fc 13     jsr lineNextToken
1295:             BEQ :go         ; implied
1295:          ISREL :go         
1295:          
1295:          _ = :go         -(*+2)
1295:          
1295:          _ = (_ < $80) . (!_ < $80)
1295:          .el
1295:d0 03     bne :@:not
1297:4c 3a 13  jmp :go         
129a:         :@:not:
129a:          .fi
129a:c9 23        cmp #'#
129c:             BEQ :imm
129c:          ISREL :imm
129c:          
129c:          _ = :imm-(*+2)
129c:          
129c:          _ = (_ < $80) . (!_ < $80)
129c:          .if _
129c:f0 47     beq :imm
129e:          .fi
129e:c9 28        cmp #'(
12a0:             BEQ :ind
12a0:          ISREL :ind
12a0:          
12a0:          _ = :ind-(*+2)
12a0:          
12a0:          _ = (_ < $80) . (!_ < $80)
12a0:          .if _
12a0:f0 4d     beq :ind
12a2:          .fi
12a2:         
12a2:20 3b 14     jsr lineEval
12a5:         
12a5:a9 00        lda #modeAbs    ; abs (so far)
12a7:85 34        sta isnMode
12a9:         
12a9:bd 00 25     lda lineBuf,x
12ac:c9 2c        cmp #',
12ae:             BNE :go
12ae:          ISREL :go
12ae:          
12ae:          _ = :go-(*+2)
12ae:          
12ae:          _ = (_ < $80) . (!_ < $80)
12ae:          .el
12ae:f0 03     beq :@:not
12b0:4c 3a 13  jmp :go
12b3:         :@:not:
12b3:          .fi
12b3:e8           inx             ; consume ,
12b4:bd 00 25     lda lineBuf,x
12b7:20 8a 0b     jsr ePet
12ba:29 7f        and #$7f        ; normalize case
12bc:c9 58        cmp #'x
12be:             BEQ :absx
12be:          ISREL :absx
12be:          
12be:          _ = :absx-(*+2)
12be:          
12be:          _ = (_ < $80) . (!_ < $80)
12be:          .if _
12be:f0 17     beq :absx
12c0:          .fi
12c0:c9 59        cmp #'y
12c2:             BEQ :absy
12c2:          ISREL :absy
12c2:          
12c2:          _ = :absy-(*+2)
12c2:          
12c2:          _ = (_ < $80) . (!_ < $80)
12c2:          .if _
12c2:f0 1a     beq :absy
12c4:          .fi
12c4:         
12c4:a5 35        lda arg
12c6:8d fc 20     sta argZ        ; zp,rel
12c9:20 3b 14     jsr lineEval
12cc:         
12cc:a9 09        lda #modeBitRel
12ce:85 34        sta isnMode
12d0:             JMP :go
12d0:          ISREL :go
12d0:          
12d0:          _ = :go-(*+2)
12d0:          
12d0:          _ = (_ < $80) . (!_ < $80)
12d0:          .if _
12d0:80 68     bra :go
12d2:          .fi
12d2:         
12d2:         :modeError:
12d2:a9 10        lda #errors:mode
12d4:85 46        sta error
12d6:60           rts
12d7:         
12d7:         :absx
12d7:e8           inx             ; consume 'x'
12d8:a9 02        lda #modeAbsX   ; abs,x
12da:85 34        sta isnMode
12dc:             JMP :go
12dc:          ISREL :go
12dc:          
12dc:          _ = :go-(*+2)
12dc:          
12dc:          _ = (_ < $80) . (!_ < $80)
12dc:          .if _
12dc:80 5c     bra :go
12de:          .fi
12de:         
12de:         :absy
12de:e8           inx             ; consume 'y'
12df:a9 03        lda #modeAbsY   ; abs,y
12e1:85 34        sta isnMode
12e3:             JMP :go
12e3:          ISREL :go
12e3:          
12e3:          _ = :go-(*+2)
12e3:          
12e3:          _ = (_ < $80) . (!_ < $80)
12e3:          .if _
12e3:80 55     bra :go
12e5:          .fi
12e5:         
12e5:         :imm
12e5:e8           inx             ; skip #
12e6:20 3b 14     jsr lineEval
12e9:         
12e9:a9 06        lda #modeImm    ; imm
12eb:85 34        sta isnMode
12ed:             JMP :go
12ed:          ISREL :go
12ed:          
12ed:          _ = :go-(*+2)
12ed:          
12ed:          _ = (_ < $80) . (!_ < $80)
12ed:          .if _
12ed:80 4b     bra :go
12ef:          .fi
12ef:         
12ef:         :ind
12ef:e8           inx             ; skip (
12f0:20 3b 14     jsr lineEval
12f3:             
12f3:a9 04        lda #modeAbsInd ; indirect
12f5:85 34        sta isnMode
12f7:             
12f7:bd 00 25     lda lineBuf,x
12fa:c9 2c        cmp #',
12fc:             BEQ :indx
12fc:          ISREL :indx
12fc:          
12fc:          _ = :indx-(*+2)
12fc:          
12fc:          _ = (_ < $80) . (!_ < $80)
12fc:          .if _
12fc:f0 06     beq :indx
12fe:          .fi
12fe:c9 29        cmp #')
1300:             BEQ :indy
1300:          ISREL :indy
1300:          
1300:          _ = :indy-(*+2)
1300:          
1300:          _ = (_ < $80) . (!_ < $80)
1300:          .if _
1300:f0 1e     beq :indy
1302:          .fi
1302:             
1302:             JMP :modeError
1302:          ISREL :modeError
1302:          
1302:          _ = :modeError-(*+2)
1302:          
1302:          _ = (_ < $80) . (!_ < $80)
1302:          .if _
1302:80 ce     bra :modeError
1304:          .fi
1304:             
1304:         :indx
1304:e8           inx             ; skip ,
1305:bd 00 25     lda lineBuf,x
1308:20 8a 0b     jsr ePet
130b:29 7f        and #$7f
130d:c9 58        cmp #'x
130f:             BNE :modeError
130f:          ISREL :modeError
130f:          
130f:          _ = :modeError-(*+2)
130f:          
130f:          _ = (_ < $80) . (!_ < $80)
130f:          .if _
130f:d0 c1     bne :modeError
1311:          .fi
1311:e8           inx
1312:bd 00 25     lda lineBuf,x
1315:c9 29        cmp #')
1317:             BNE :modeError
1317:          ISREL :modeError
1317:          
1317:          _ = :modeError-(*+2)
1317:          
1317:          _ = (_ < $80) . (!_ < $80)
1317:          .if _
1317:d0 b9     bne :modeError
1319:          .fi
1319:e8           inx
131a:         
131a:a9 01        lda #modeAbsIndX ; (ind,x)
131c:85 34        sta isnMode
131e:             JMP :go
131e:          ISREL :go
131e:          
131e:          _ = :go-(*+2)
131e:          
131e:          _ = (_ < $80) . (!_ < $80)
131e:          .if _
131e:80 1a     bra :go
1320:          .fi
1320:         
1320:         :indy
1320:e8           inx             ; skip )
1321:bd 00 25     lda lineBuf,x
1324:c9 2c        cmp #',
1326:             BNE :go         ; presume (ind)
1326:          ISREL :go         
1326:          
1326:          _ = :go         -(*+2)
1326:          
1326:          _ = (_ < $80) . (!_ < $80)
1326:          .if _
1326:d0 12     bne :go         
1328:          .fi
1328:e8           inx
1329:bd 00 25     lda lineBuf,x
132c:20 8a 0b     jsr ePet
132f:29 7f        and #$7f
1331:c9 59        cmp #'y
1333:             BNE :modeError
1333:          ISREL :modeError
1333:          
1333:          _ = :modeError-(*+2)
1333:          
1333:          _ = (_ < $80) . (!_ < $80)
1333:          .if _
1333:d0 9d     bne :modeError
1335:          .fi
1335:e8           inx
1336:         
1336:a9 0f        lda #modeZeroIndY
1338:85 34        sta isnMode     ; (ind),y
133a:             ; fall thru
133a:         
133a:             ; resolved address mode
133a:         :go
133a:20 23 14     jsr lineAssertEnd
133d:a5 2c        lda isnBit      ; check for bitn
133f:f0 13        beq :notbit
1341:38           sec
1342:e9 30        sbc #'0
1344:0a           asl
1345:0a           asl
1346:0a           asl
1347:0a           asl
1348:85 2c        sta isnBit
134a:a5 34        lda isnMode
134c:c9 00        cmp #modeAbs
134e:d0 04        bne :notbit
1350:a9 05        lda #modeBitZero
1352:85 34        sta isnMode
1354:         
1354:         :notbit
1354:a5 33        lda isnOp
1356:c9 54        cmp #$54        ; BRK is special
1358:             BEQ :brk
1358:          ISREL :brk
1358:          
1358:          _ = :brk-(*+2)
1358:          
1358:          _ = (_ < $80) . (!_ < $80)
1358:          .if _
1358:f0 4e     beq :brk
135a:          .fi
135a:         
135a:20 2a 1c     jsr opResolve   ; opcode in a
135d:             BCS :modeError
135d:          ISREL :modeError
135d:          
135d:          _ = :modeError-(*+2)
135d:          
135d:          _ = (_ < $80) . (!_ < $80)
135d:          .el
135d:90 03     bcc :@:not
135f:4c d2 12  jmp :modeError
1362:         :@:not:
1362:          .fi
1362:         
1362:65 2c        adc isnBit      ; if bitn, adjust
1364:20 53 12     jsr lineEmit    ; opcode
1367:         
1367:a5 34        lda isnMode
1369:c9 08        cmp #modeRel
136b:             BEQ :rel
136b:          ISREL :rel
136b:          
136b:          _ = :rel-(*+2)
136b:          
136b:          _ = (_ < $80) . (!_ < $80)
136b:          .if _
136b:f0 0a     beq :rel
136d:          .fi
136d:c9 09        cmp #modeBitRel
136f:             BNE :notrel
136f:          ISREL :notrel
136f:          
136f:          _ = :notrel-(*+2)
136f:          
136f:          _ = (_ < $80) . (!_ < $80)
136f:          .if _
136f:d0 45     bne :notrel
1371:          .fi
1371:         
1371:ad fc 20     lda argZ
1374:20 53 12     jsr lineEmit    ; zp arg of bitRel
1377:         
1377:         :rel
1377:a5 40        lda pass
1379:89 a0        bit #$a0
137b:             BEQ :pass0      ; no check until final pass
137b:          ISREL :pass0      
137b:          
137b:          _ = :pass0      -(*+2)
137b:          
137b:          _ = (_ < $80) . (!_ < $80)
137b:          .if _
137b:f0 28     beq :pass0      
137d:          .fi
137d:         
137d:ad fe 20     lda pc          ; relative
1380:18           clc
1381:69 01        adc #1          ; scratch=pc+1
1383:85 22        sta scratch
1385:ad ff 20     lda pc+1
1388:69 00        adc #0
138a:85 23        sta scratch+1
138c:         
138c:a5 35        lda arg         ; arg-=scratch
138e:38           sec
138f:e5 22        sbc scratch
1391:85 35        sta arg
1393:a5 36        lda arg+1
1395:e5 23        sbc scratch+1
1397:85 36        sta arg+1
1399:         
1399:a2 ff        ldx #$ff
139b:a5 35        lda arg         ; test for valid range
139d:30 02        bmi :checkBack
139f:a2 00        ldx #$00
13a1:         :checkBack
13a1:e4 36        cpx arg+1
13a3:             BNE :relError
13a3:          ISREL :relError
13a3:          
13a3:          _ = :relError-(*+2)
13a3:          
13a3:          _ = (_ < $80) . (!_ < $80)
13a3:          .if _
13a3:d0 25     bne :relError
13a5:          .fi
13a5:         
13a5:         :pass0
13a5:4c 53 12     jmp lineEmit    ; send it
13a8:         
13a8:         :brk
13a8:a5 34        lda isnMode
13aa:c9 07        cmp #modeImp
13ac:             BNE :modeError
13ac:          ISREL :modeError
13ac:          
13ac:          _ = :modeError-(*+2)
13ac:          
13ac:          _ = (_ < $80) . (!_ < $80)
13ac:          .el
13ac:f0 03     beq :@:not
13ae:4c d2 12  jmp :modeError
13b1:         :@:not:
13b1:          .fi
13b1:a9 00        lda #0
13b3:4c 53 12     jmp lineEmit    ; emit the single $00
13b6:         
13b6:         :notrel
13b6:c9 07        cmp #modeImp
13b8:             BEQ :done
13b8:          ISREL :done
13b8:          
13b8:          _ = :done-(*+2)
13b8:          
13b8:          _ = (_ < $80) . (!_ < $80)
13b8:          .if _
13b8:f0 14     beq :done
13ba:          .fi
13ba:         
13ba:a5 35        lda arg         ; low byte or zp
13bc:20 53 12     jsr lineEmit
13bf:         
13bf:a5 34        lda isnMode
13c1:c9 05        cmp #5
13c3:             BCS :done
13c3:          ISREL :done
13c3:          
13c3:          _ = :done-(*+2)
13c3:          
13c3:          _ = (_ < $80) . (!_ < $80)
13c3:          .if _
13c3:b0 09     bcs :done
13c5:          .fi
13c5:         
13c5:a5 36        lda arg+1       ; high byte
13c7:4c 53 12     jmp lineEmit
13ca:         
13ca:         :relError
13ca:a9 12        lda #errors:rel
13cc:85 46        sta error
13ce:         :done
13ce:60           rts
13cf:         
13cf:         ;
13cf:         ; expect 'quoted string' and return in a/x/y
13cf:         lineGetName:
13cf:20 2f 14     jsr lineAssertToken
13d2:e8           inx
13d3:c9 27        cmp #''
13d5:d0 17        bne lineErrorDotArg
13d7:86 22        stx scratch
13d9:a0 00        ldy #0
13db:         :count
13db:20 1b 14     jsr lineEndExit
13de:c9 27        cmp #''
13e0:f0 04        beq :got
13e2:c8           iny
13e3:e8           inx
13e4:d0 f5        bne :count
13e6:         :got
13e6:98           tya             ; length -> A
13e7:a6 22        ldx scratch
13e9:a0 25        ldy #>lineBuf
13eb:4c 2b 15     jmp ioCopySourceName
13ee:         
13ee:         lineErrorDotArg:
13ee:a9 1a        lda #errors:dotArg
13f0:85 46        sta error
13f2:80 22        bra lineExit
13f4:         
13f4:         ;
13f4:         ; Z=1 if at end
13f4:         lineEnd:
13f4:bd 00 25     lda lineBuf,x
13f7:f0 02        beq :out        ; eof
13f9:c9 3b        cmp #';
13fb:         :out
13fb:60           rts
13fc:         
13fc:         ;
13fc:         ; Z=1 if at end (; or eof)
13fc:         lineNextToken:
13fc:20 f4 13     jsr lineEnd
13ff:f0 0c        beq :out
1401:c9 21        cmp #33
1403:90 09        bcc :white
1405:c9 a0        cmp #160
1407:f0 05        beq :white
1409:c9 e0        cmp #224
140b:f0 01        beq :white
140d:         :out
140d:60           rts
140e:         :white
140e:e8           inx
140f:80 eb        bra lineNextToken
1411:         
1411:         ;
1411:         ; lineNextToken with a fast exit at end
1411:         lineNextTokenExit:
1411:20 fc 13     jsr lineNextToken
1414:d0 04        bne lineExit:out
1416:         lineExit:
1416:ae fb 20     ldx lineSP      ; rewind stack for fast exit
1419:9a           txs
141a:         :out
141a:60           rts
141b:         
141b:         ;
141b:         ; lineEnd with fast exit
141b:         lineEndExit:
141b:20 f4 13     jsr lineEnd
141e:d0 02        bne :out
1420:80 f4        bra lineExit
1422:         :out
1422:60           rts
1423:         
1423:         ;
1423:         ; lineNextToken with an error and fast exit if not at end
1423:         lineAssertEnd:
1423:20 fc 13     jsr lineNextToken
1426:f0 06        beq :out
1428:a9 14        lda #errors:parse
142a:85 46        sta error
142c:80 e8        bra lineExit
142e:         :out
142e:60           rts
142f:         
142f:         ;
142f:         ; lineNextToken with an error and fast exit if at end
142f:         lineAssertToken:
142f:20 fc 13     jsr lineNextToken
1432:d0 06        bne :out
1434:a9 16        lda #errors:noArg
1436:85 46        sta error
1438:80 dc        bra lineExit
143a:         :out
143a:60           rts
143b:         
143b:         ;
143b:         ; call eEval and fast exit on error
143b:         lineEval:
143b:20 9d 0b     jsr eEval
143e:90 06        bcc :out
1440:a9 08        lda #errors:eval
1442:85 46        sta error
1444:80 d0        bra lineExit
1446:         :out
1446:60           rts
1447:             .in 'io.asm'
1447:             .in 'zp.asm'
1447:             .fi ; zpAsm
1447:             .in 'kernal.asm'
1447:             .fi ; kernalAsm
1447:         
1447:         
1447:         ;
1447:         ; initialize
1447:         ioInit:
1447:20 e7 ff     jsr CLALL
144a:a2 10        ldx #input:size-1
144c:         :inloop
144c:9e e8 20     stz input,x
144f:ca           dex
1450:10 fa        bpl :inloop
1452:64 46        stz error
1454:64 4a        stz ioOutPtr
1456:9c f9 20     stz ioFDS
1459:64 4b        stz ioIn
145b:64 4c        stz ioIn+1
145d:9c e7 20     stz ioPtr
1460:a9 08        lda #8          ; default to device 8
1462:8d e9 20     sta input:dev
1465:a9 77        lda #<:null
1467:8d e5 20     sta emit
146a:a9 14        lda #>:null
146c:8d e6 20     sta emit+1
146f:a2 0f        ldx #$0f        ; initialize io buffers
1471:         :bufloop
1471:9e 12 21     stz ioBufs,x
1474:ca           dex
1475:10 fa        bpl :bufloop
1477:         :null
1477:18           clc
1478:60           rts
1479:         
1479:         ;
1479:         ; write a byte via the emit vector
1479:         ioEmit:
1479:ee fe 20     inc pc
147c:d0 03        bne :lo
147e:ee ff 20     inc pc+1
1481:         :lo
1481:6c e5 20     jmp (emit)
1484:         
1484:         ;
1484:         ; close all files and display error
1484:         ioError:
1484:20 af 17     jsr ioCloseAll
1487:a9 0d        lda #13         ; cr
1489:20 d2 ff     jsr CHROUT
148c:20 9c 14     jsr ioFileLine
148f:a9 20        lda #32
1491:20 d2 ff     jsr CHROUT
1494:20 6d 1a     jsr errPrint
1497:a9 0d        lda #13         ; cr
1499:4c d2 ff     jmp CHROUT
149c:         
149c:         ;
149c:         ; print filename and line number
149c:         ioFileLine:
149c:ad f2 20     lda input:name
149f:ac f3 20     ldy input:name+1
14a2:85 27        sta ptr
14a4:84 28        sty ptr+1
14a6:a0 00        ldy #0
14a8:         :print
14a8:cc f4 20     cpy input:nameLen
14ab:f0 08        beq :printed
14ad:b1 27        lda (ptr),y     ; print "filename:"
14af:20 d2 ff     jsr CHROUT
14b2:c8           iny
14b3:d0 f3        bne :print
14b5:         :printed
14b5:a9 3a        lda #':
14b7:20 d2 ff     jsr CHROUT
14ba:ad f6 20     lda input:line+1
14bd:20 28 18     jsr ioPrintHex
14c0:ad f5 20     lda input:line
14c3:20 28 18     jsr ioPrintHex
14c6:60           rts
14c7:         
14c7:         ioSuffix:
14c7:2c 50 2c 57 
             :pw .db ',p,w'
14cb:2c 53 2c 57 
             :sw .db ',s,w'
14cf:2c 53 2c 52 
             :sr .db ',s,r'
14d3:         
14d3:         ;
14d3:         ; copy a/x/y to eStack
14d3:         ioBufferName:
14d3:86 31        stx symLabel
14d5:84 32        sty symLabel+1
14d7:85 30        sta symLength
14d9:a0 00        ldy #0
14db:         :copy
14db:b1 31        lda (symLabel),y
14dd:99 00 24     sta eStack,y
14e0:c8           iny
14e1:c4 30        cpy symLength
14e3:d0 f6        bne :copy
14e5:64 31        stz symLabel        ; point symLabel at eStack
14e7:a9 24        lda #>eStack
14e9:85 32        sta symLabel+1
14eb:60           rts
14ec:         
14ec:         ;
14ec:         ; append 4 byte suffix from x/y to buffered name
14ec:         ioSuffixName:
14ec:86 27        stx ptr
14ee:84 28        sty ptr+1
14f0:a0 00        ldy #0
14f2:a6 30        ldx symLength
14f4:         :loop
14f4:b1 27        lda (ptr),y
14f6:9d 00 24     sta eStack,x
14f9:e8           inx
14fa:c8           iny
14fb:c0 04        cpy #4
14fd:d0 f5        bne :loop
14ff:86 30        stx symLength
1501:60           rts
1502:         
1502:         ;
1502:         ; intern eStack/symLength to same copy
1502:         ; result in a/x/y
1502:         ioStoreName:
1502:20 b2 0a     jsr strGet
1505:a5 27        lda ptr
1507:18           clc
1508:69 05        adc #5
150a:aa           tax
150b:a5 28        lda ptr+1
150d:69 00        adc #0
150f:a8           tay
1510:a5 30        lda symLength
1512:60           rts
1513:         
1513:         ;
1513:         ; make a copy of a/x/y with ,p,w appended
1513:         ; result in a/x/y
1513:         ioCopyDestName:
1513:20 d3 14     jsr ioBufferName
1516:a2 c7        ldx #<ioSuffix:pw
1518:a0 14        ldy #>ioSuffix:pw
151a:20 ec 14     jsr ioSuffixName
151d:80 e3        bra ioStoreName
151f:         
151f:         ;
151f:         ; make a copy of a/x/y with ,s,w appended
151f:         ioCopyListName:
151f:20 d3 14     jsr ioBufferName
1522:a2 cb        ldx #<ioSuffix:sw
1524:a0 14        ldy #>ioSuffix:sw
1526:20 ec 14     jsr ioSuffixName
1529:80 d7        bra ioStoreName
152b:         
152b:         ;
152b:         ; make a copy of a/x/y with ,s,r appended
152b:         ; result in a/(ptr)
152b:         ioCopySourceName:
152b:20 3a 15     jsr ioStringOut
152e:20 d3 14     jsr ioBufferName
1531:a2 cf        ldx #<ioSuffix:sr
1533:a0 14        ldy #>ioSuffix:sr
1535:20 ec 14     jsr ioSuffixName
1538:80 c8        bra ioStoreName
153a:         
153a:         ;
153a:         ; print string a/x/y with CR
153a:         ; all preserved
153a:         ioStringOut:
153a:85 22        sta scratch
153c:86 23        stx string
153e:84 24        sty string+1
1540:a0 00        ldy #0
1542:         :loop
1542:c4 22        cpy scratch
1544:f0 08        beq :done
1546:b1 23        lda (string),y
1548:20 d2 ff     jsr CHROUT
154b:c8           iny
154c:d0 f4        bne :loop
154e:         :done
154e:a9 0d        lda #13
1550:20 d2 ff     jsr CHROUT
1553:a5 22        lda scratch
1555:a6 23        ldx string
1557:a4 24        ldy string+1
1559:60           rts
155a:         
155a:         ;
155a:         ; open output file named in a/x/y with LFN 2
155a:         ioOpenDest:
155a:20 bd ff     jsr SETNAM
155d:a9 02        lda #2
155f:ae e9 20     ldx input:dev
1562:a0 02        ldy #2
1564:20 ba ff     jsr SETLFS
1567:20 c0 ff     jsr OPEN
156a:90 04        bcc :opened
156c:a9 1c        lda #errors:io
156e:85 46        sta error
1570:         :opened
1570:60           rts
1571:         
1571:         ;
1571:         ; push current input state
1571:         ioPush:
1571:a5 4b        lda ioIn        ; copy zp shadow
1573:a4 4c        ldy ioIn+1
1575:8d ec 20     sta input:in
1578:8c ed 20     sty input:in+1
157b:         
157b:ac e7 20     ldy ioPtr       ; push input state block
157e:a2 10        ldx #input:size-1
1580:         :loop
1580:bd e8 20     lda input,x
1583:88           dey
1584:99 00 23     sta ioStack,y
1587:ca           dex
1588:10 f6        bpl :loop
158a:         
158a:8c e7 20     sty ioPtr       ; mark new stack location
158d:9c eb 20     stz input:inPtr ; reset buffered input
1590:9c ee 20     stz input:bufLen
1593:60           rts
1594:         
1594:         ;
1594:         ; push input file a/x/y
1594:         ioPushFile:
1594:85 22        sta scratch
1596:86 27        stx ptr
1598:84 28        sty ptr+1
159a:20 cc ff     jsr CLRCHN
159d:20 71 15     jsr ioPush
15a0:         
15a0:a9 bb        lda #<ioReadFile
15a2:a0 16        ldy #>ioReadFile
15a4:8d f7 20     sta input:read
15a7:8c f8 20     sty input:read+1
15aa:         
15aa:         
15aa:             ; TODO: parse for @device:
15aa:         
15aa:a5 22        lda scratch     ; scratch/ptr -> nameL/name
15ac:8d f4 20     sta input:nameLen
15af:a6 27        ldx ptr
15b1:a4 28        ldy ptr+1
15b3:8e f2 20     stx input:name
15b6:8c f3 20     sty input:name+1
15b9:20 bd ff     jsr SETNAM      ; filename
15bc:         
15bc:20 2b 16     jsr ioAlloc     ; device secondary in Y
15bf:b0 28        bcs :toomany
15c1:c8           iny
15c2:c8           iny
15c3:c8           iny             ; ..and add 3 to it (we use 2 for the output)
15c4:ae e9 20     ldx input:dev
15c7:98           tya             ; use LFN=device secondary
15c8:8d e8 20     sta input:lfn
15cb:20 ba ff     jsr SETLFS
15ce:         
15ce:20 c0 ff     jsr OPEN        ; open the file
15d1:b0 11        bcs :error
15d3:ae e8 20     ldx input:lfn
15d6:20 c6 ff     jsr CHKIN
15d9:b0 09        bcs :error      ; now current file for reading
15db:         
15db:9c f5 20     stz input:line  ; reset to line 0
15de:9c f6 20     stz input:line+1
15e1:         
15e1:4c a7 16     jmp ioReadStatus
15e4:         
15e4:         :error
15e4:a9 1c        lda #errors:io
15e6:85 46        sta error
15e8:60           rts
15e9:         
15e9:         :toomany
15e9:a9 1e        lda #errors:tooMany
15eb:85 46        sta error
15ed:60           rts
15ee:         
15ee:         ;
15ee:         ; pop current file state
15ee:         ioPop:
15ee:20 cc ff     jsr CLRCHN      ; disconnect existing
15f1:ad e8 20     lda input:lfn
15f4:c9 02        cmp #2          ; 0: eof, 1: macro playback
15f6:90 0c        bcc :noclose
15f8:20 c3 ff     jsr CLOSE       ; close current logical file (if using a file)
15fb:ac e8 20     ldy input:lfn
15fe:88           dey
15ff:88           dey
1600:88           dey
1601:20 5d 16     jsr ioDealloc   ; deallocate device secondary
1604:         :noclose
1604:         
1604:ac e7 20     ldy ioPtr       ; copy input block from stack
1607:a2 00        ldx #0
1609:         :loop
1609:b9 00 23     lda ioStack,y
160c:c8           iny
160d:9d e8 20     sta input,x
1610:e8           inx
1611:e0 11        cpx #input:size
1613:d0 f4        bne :loop
1615:8c e7 20     sty ioPtr       ; stack info popped
1618:         
1618:ad ec 20     lda input:in    ; copy shadow zp
161b:ac ed 20     ldy input:in+1
161e:85 4b        sta ioIn
1620:84 4c        sty ioIn+1
1622:         
1622:ae e8 20     ldx input:lfn
1625:f0 03        beq :zero       ; do not redirect from 0
1627:4c c6 ff     jmp CHKIN       ; this also becomes our current input
162a:         :zero
162a:60           rts
162b:         
162b:         ;
162b:         ; allocate device secondary
162b:         ; result in Y
162b:         ioAlloc:
162b:a9 01        lda #$01
162d:a0 00        ldy #0
162f:18           clc
1630:         :scan
1630:2c f9 20     bit ioFDS
1633:f0 05        beq :done
1635:c8           iny
1636:0a           asl
1637:90 f7        bcc :scan
1639:60           rts
163a:         :done
163a:0c f9 20     tsb ioFDS
163d:98           tya             ; potentially allocate input buffer
163e:0a           asl
163f:aa           tax
1640:bd 13 21     lda ioBufs+1,x
1643:d0 0f        bne :alloced
1645:         
1645:a9 80        lda #$80        ; allocate a buffer
1647:20 41 0b     jsr symPush
164a:a5 27        lda ptr
164c:9d 12 21     sta ioBufs,x
164f:a5 28        lda ptr+1
1651:9d 13 21     sta ioBufs+1,x
1654:         
1654:         :alloced            ; allocated
1654:85 4c        sta ioIn+1
1656:bd 12 21     lda ioBufs,x
1659:85 4b        sta ioIn
165b:18           clc
165c:60           rts
165d:         
165d:         ;
165d:         ; deallocate device secondary in Y
165d:         ioDealloc:
165d:a9 01        lda #$01
165f:         :shift
165f:c0 00        cpy #0
1661:f0 04        beq :done
1663:0a           asl
1664:88           dey
1665:d0 f8        bne :shift
1667:         :done
1667:1c f9 20     trb ioFDS
166a:60           rts
166b:         
166b:         ;
166b:         ; read a line of input from current file
166b:         ; if ioLFN is 0 on return, at end of all files and nothing read
166b:         ioReadLine:
166b:f8           sed             ; increment bcd line number
166c:18           clc
166d:ad f5 20     lda input:line
1670:69 01        adc #$01
1672:8d f5 20     sta input:line
1675:ad f6 20     lda input:line+1
1678:69 00        adc #0
167a:8d f6 20     sta input:line+1
167d:d8           cld
167e:         
167e:64 22        stz scratch
1680:         :loop
1680:20 b8 16     jsr ioRead      ; read from input buffer until CR or EOF
1683:a6 22        ldx scratch
1685:b0 0b        bcs :readerr
1687:e6 22        inc scratch
1689:c9 0d        cmp #13         ; CR?
168b:f0 16        beq :linedone
168d:9d 00 25     sta lineBuf,x
1690:80 ee        bra :loop
1692:         :readerr
1692:a5 22        lda scratch     ; if we read something, deal with it
1694:d0 0d        bne :linedone
1696:         
1696:a5 46        lda error       ; non eof error?
1698:d0 08        bne :done
169a:         
169a:20 ee 15     jsr ioPop       ; eof; pop this input
169d:ad e8 20     lda input:lfn
16a0:d0 c9        bne ioReadLine  ; continue previous input
16a2:         :done
16a2:60           rts
16a3:         
16a3:         :linedone
16a3:9e 00 25     stz lineBuf,x   ; mark end of line
16a6:60           rts
16a7:         
16a7:         ;
16a7:         ; call READST, set error if not EOF
16a7:         ; Z=1 if all clear
16a7:         ioReadStatus:
16a7:20 b7 ff     jsr READST
16aa:8d ea 20     sta input:status
16ad:89 bf        bit #$bf        ; everything except eof
16af:f0 04        beq :done
16b1:a9 1c        lda #errors:io
16b3:85 46        sta error
16b5:         :done
16b5:89 ff        bit #$ff        ; leave Z=0 if EOF
16b7:60           rts
16b8:         
16b8:         ;
16b8:         ; read byte
16b8:         ioRead:
16b8:6c f7 20     jmp (input:read)
16bb:         
16bb:         ;
16bb:         ; read byte from input buffer, refilling if needed
16bb:         ioReadFile:
16bb:ac eb 20     ldy input:inPtr
16be:cc ee 20     cpy input:bufLen
16c1:f0 07        beq :refill
16c3:ee eb 20     inc input:inPtr
16c6:b1 4b        lda (ioIn),y
16c8:18           clc
16c9:60           rts
16ca:         :refill
16ca:9c eb 20     stz input:inPtr ; reset input
16cd:9c ee 20     stz input:bufLen
16d0:ad ea 20     lda input:status ; check for end of file
16d3:d0 35        bne :end
16d5:a9 80        lda #$80        ; read max 128 bytes into buffer
16d7:a6 4b        ldx ioIn
16d9:a4 4c        ldy ioIn+1
16db:18           clc
16dc:20 44 ff     jsr MACPTR
16df:b0 0c        bcs :bytes      ; unsupported or error
16e1:e0 00        cpx #0
16e3:f0 27        beq :eof        ; end of file
16e5:8e ee 20     stx input:bufLen
16e8:20 a7 16     jsr ioReadStatus
16eb:80 cb        bra ioRead
16ed:         :bytes
16ed:20 a7 16     jsr ioReadStatus
16f0:d0 18        bne :end
16f2:a0 00        ldy #0
16f4:         :loop
16f4:20 cf ff     jsr CHRIN
16f7:91 4b        sta (ioIn),y
16f9:20 a7 16     jsr ioReadStatus
16fc:d0 08        bne :bytesdone  ; error or eof
16fe:c8           iny
16ff:10 f3        bpl :loop       ; read max 128 bytes
1701:         :partial
1701:8c ee 20     sty input:bufLen
1704:80 b2        bra ioRead
1706:         :bytesdone
1706:c0 00        cpy #0
1708:d0 f7        bne :partial    ; if we made progress, use partial read
170a:         :end
170a:38           sec
170b:60           rts
170c:         :eof
170c:a9 40        lda #$40
170e:8d ea 20     sta input:status
1711:80 f7        bra :end
1713:         
1713:         ;
1713:         ; copy current input file to output until end or error
1713:         ioCopy:
1713:a5 46        lda error
1715:d0 0a        bne :done
1717:20 b8 16     jsr ioRead
171a:b0 05        bcs :done
171c:20 79 14     jsr ioEmit
171f:90 f2        bcc ioCopy
1721:         :done
1721:a5 46        lda error
1723:f0 03        beq :out
1725:4c ee 15     jmp ioPop
1728:         :out
1728:60           rts
1729:         
1729:         ;
1729:         ; emit byte to output (binary or listing char)
1729:         ioEmitBin:
1729:86 2a        stx emitX
172b:84 2b        sty emitY
172d:a4 4a        ldy ioOutPtr
172f:99 00 22     sta ioBuf,y
1732:c8           iny
1733:84 4a        sty ioOutPtr
1735:18           clc             ; no error
1736:d0 03        bne :out
1738:20 63 17     jsr ioFlushAlways
173b:         :out
173b:a6 2a        ldx emitX
173d:a4 2b        ldy emitY
173f:60           rts
1740:         
1740:         ;
1740:         ; emit listing output
1740:         ioEmitListing:
1740:20 40 18     jsr ioHex
1743:a9 20        lda #32
1745:20 29 17     jsr ioEmitBin
1748:b0 14        bcs :out
174a:ee fd 20     inc ioColumn
174d:ad fd 20     lda ioColumn
1750:c9 08        cmp #8
1752:90 0a        bcc :out
1754:a9 0d        lda #13
1756:20 29 17     jsr ioEmitBin
1759:b0 03        bcs :out
175b:20 de 17     jsr ioListing
175e:         :out
175e:60           rts
175f:         
175f:         
175f:         ;
175f:         ; flush any unwritten output
175f:         ioFlush:
175f:a5 4a        lda ioOutPtr
1761:f0 42        beq ioSuccess
1763:         ioFlushAlways:
1763:20 cc ff     jsr CLRCHN
1766:a2 02        ldx #2
1768:20 c9 ff     jsr CHKOUT
176b:b0 1e        bcs :done
176d:         
176d:a5 4a        lda ioOutPtr    ; try to write entire buffer
176f:a2 00        ldx #<ioBuf     ; invariant: 0; this is page aligned
1771:a0 22        ldy #>ioBuf
1773:20 b1 fe     jsr MCIOUT
1776:b0 06        bcs :slow       ; not supported
1778:         
1778:e4 4a        cpx ioOutPtr    ; did we write everything?
177a:f0 0f        beq :done
177c:80 02        bra :loop       ; byte bang the rest
177e:         
177e:         :slow
177e:a2 00        ldx #0          ; byte bang
1780:         :loop
1780:bd 00 22     lda ioBuf,x
1783:20 d2 ff     jsr CHROUT
1786:e8           inx
1787:e4 4a        cpx ioOutPtr
1789:d0 f5        bne :loop
178b:         :done
178b:64 4a        stz ioOutPtr
178d:20 cc ff     jsr CLRCHN
1790:ae e8 20     ldx input:lfn
1793:f0 03        beq :noread
1795:20 c6 ff     jsr CHKIN
1798:         :noread
1798:20 b7 ff     jsr READST
179b:c9 00        cmp #0
179d:f0 06        beq ioSuccess
179f:a9 1c        lda #errors:io
17a1:85 46        sta error
17a3:38           sec
17a4:60           rts
17a5:         ioSuccess:
17a5:18           clc
17a6:60           rts
17a7:         
17a7:         ;
17a7:         ; flush output buffer and close
17a7:         ioClose:
17a7:20 5f 17     jsr ioFlush
17aa:a9 02        lda #2
17ac:4c c3 ff     jmp CLOSE
17af:         
17af:         ;
17af:         ; close all disk before exiting abnormally
17af:         ioCloseAll:
17af:             ; preserve filename and line number for error
17af:a2 04        ldx #4
17b1:         :save
17b1:bd f2 20     lda input:name,x
17b4:9d 00 25     sta lineBuf,x
17b7:ca           dex
17b8:10 f7        bpl :save
17ba:         
17ba:20 a7 17     jsr ioClose
17bd:20 cc ff     jsr CLRCHN
17c0:         
17c0:         :loop
17c0:ad e8 20     lda input:lfn
17c3:f0 0d        beq :done
17c5:         
17c5:20 9c 14     jsr ioFileLine  ; print file and line stack
17c8:a9 0d        lda #13
17ca:20 d2 ff     jsr CHROUT
17cd:         
17cd:20 ee 15     jsr ioPop
17d0:80 ee        bra :loop
17d2:         :done
17d2:         
17d2:a2 04        ldx #4
17d4:         :restore
17d4:bd 00 25     lda lineBuf,x
17d7:9d f2 20     sta input:name,x
17da:ca           dex
17db:10 f7        bpl :restore
17dd:         
17dd:60           rts
17de:         
17de:         ;
17de:         ; emit listing address, reset column count
17de:         ioListing:
17de:a5 40        lda pass
17e0:10 18        bpl :silent     ; $80 must be set in pass for this output
17e2:a5 44        lda lineIfs
17e4:30 14        bmi :silent     ; do not list if'd out
17e6:ad ff 20     lda pc+1        ; PC:
17e9:20 40 18     jsr ioHex
17ec:ad fe 20     lda pc
17ef:20 40 18     jsr ioHex
17f2:a9 3a        lda #':
17f4:20 29 17     jsr ioEmitBin
17f7:9c fd 20     stz ioColumn
17fa:         :silent
17fa:60           rts
17fb:         
17fb:         ;
17fb:         ; pad trailing spaced per ioColumn
17fb:         ioPadListing:
17fb:a9 03        lda #3
17fd:38           sec
17fe:ed fd 20     sbc ioColumn
1801:90 0c        bcc :nextLine
1803:aa           tax
1804:18           clc
1805:         :loop
1805:ca           dex
1806:30 1f        bmi :done
1808:a0 03        ldy #3
180a:20 1d 18     jsr :spaces
180d:80 f6        bra :loop
180f:         :nextLine
180f:a9 0d        lda #13         ; cr
1811:20 29 17     jsr ioEmitBin
1814:b0 11        bcs :done
1816:a0 0d        ldy #13         ; xxxx:aa bb cc
1818:20 1d 18     jsr :spaces
181b:80 e8        bra :loop
181d:         :spaces
181d:a9 20        lda #32         ; space
181f:20 29 17     jsr ioEmitBin
1822:b0 03        bcs :done
1824:88           dey
1825:d0 f6        bne :spaces
1827:         :done
1827:60           rts
1828:         
1828:         ;
1828:         ; print hex byte in A
1828:         ioPrintHex:
1828:85 22        sta scratch
182a:4a           lsr
182b:4a           lsr
182c:4a           lsr
182d:4a           lsr
182e:20 35 18     jsr :digit
1831:a5 22        lda scratch
1833:29 0f        and #$0f
1835:         :digit
1835:c9 0a        cmp #10
1837:90 02        bcc :num
1839:69 06        adc #6          ; add 7 (C=1)
183b:         :num
183b:69 30        adc #'0
183d:4c d2 ff     jmp CHROUT
1840:         
1840:         ;
1840:         ; emit hex byte in A
1840:         ioHex:
1840:85 22        sta scratch
1842:4a           lsr
1843:4a           lsr
1844:4a           lsr
1845:4a           lsr
1846:20 4d 18     jsr :digit
1849:a5 22        lda scratch
184b:29 0f        and #$0f
184d:         :digit
184d:c9 0a        cmp #10
184f:90 02        bcc :num
1851:69 06        adc #6
1853:         :num
1853:69 30        adc #'0
1855:4c 29 17     jmp ioEmitBin
1858:         
1858:         ;
1858:         ; print 0 terminated string in X/Y
1858:         ; uses ptr
1858:         ioPrint:
1858:86 27        stx ptr
185a:84 28        sty ptr+1
185c:a0 00        ldy #0
185e:         :loop
185e:b1 27        lda (ptr),y
1860:f0 06        beq :done
1862:20 d2 ff     jsr CHROUT
1865:c8           iny
1866:d0 f6        bne :loop
1868:         :done
1868:60           rts
1869:         
1869:             .in 'himem.asm'
1869:             .in 'zp.asm'
1869:             .fi ; zpAsm
1869:             .in 'kernal.asm'
1869:             .fi ; kernalAsm
1869:         
1869:         
1869:         ;
1869:         ; initialize himem system
1869:         hiInit
1869:a9 01        lda #1          ; user bank 1
186b:8d 0d 21     sta bank
186e:9c 0e 21     stz himem
1871:a9 a0        lda #$a0        ; start at $a000
1873:8d 0f 21     sta himem+1
1876:60           rts
1877:         
1877:         ;
1877:         ; write text to himem
1877:         ; error set if out of memory
1877:         hiWrite
1877:ac 0e 21     ldy himem
187a:ae 0f 21     ldx himem+1
187d:e0 c0        cpx #$c0        ; have we incremented to top of window?
187f:f0 15        beq :nextbank   ; advance to next bank
1881:64 27        stz ptr         ; ptr=himem & $ff00
1883:86 28        stx ptr+1
1885:ae 0d 21     ldx bank
1888:86 00        stx $00         ; set active bank
188a:91 27        sta (ptr),y     ; write
188c:c8           iny
188d:8c 0e 21     sty himem       ; increment lo pointer
1890:d0 03        bne :lo
1892:ee 0f 21     inc himem+1     ; increment hi pointer if wrapped
1895:         :lo
1895:60           rts
1896:         :nextbank
1896:85 22        sta scratch     ; save the byte we are trying to write
1898:ee 0d 21     inc bank        ; increment bank
189b:38           sec
189c:20 99 ff     jsr MEMTOP      ; query number of banks we have
189f:cd 0d 21     cmp bank
18a2:f0 0c        beq :err        ; full
18a4:a9 a0        lda #$a0        ; reset pointer in new bank
18a6:9c 0e 21     stz himem
18a9:8d 0f 21     sta himem+1
18ac:a5 22        lda scratch     ; restore byte we are trying to write
18ae:80 c7        bra hiWrite     ; try again in new bank
18b0:         
18b0:         :err
18b0:a9 20        lda #errors:noMem
18b2:85 46        sta error
18b4:60           rts
18b5:         
18b5:         ;
18b5:         ; read from himem
18b5:         ; caller is responsible to know when to stop reading
18b5:         hiRead
18b5:ac f0 20     ldy input:himem
18b8:ae f1 20     ldx input:himem+1
18bb:e0 c0        cpx #$c0        ; have we increment to top of window?
18bd:f0 17        beq :nextbank   ; advance
18bf:64 27        stz ptr
18c1:86 28        stx ptr+1
18c3:ae ef 20     ldx input:bank
18c6:86 00        stx $00         ; set active bank
18c8:b1 27        lda (ptr),y     ; read
18ca:c8           iny
18cb:8c f0 20     sty input:himem ; increment lo pointer
18ce:d0 03        bne :lo
18d0:ee f1 20     inc input:himem+1 ; increment hi pointer if wrapped
18d3:         :lo
18d3:89 ff        bit #$ff        ; z=1 if zero
18d5:60           rts
18d6:         :nextbank
18d6:ee ef 20     inc input:bank  ; increment bank
18d9:a9 a0        lda #$a0
18db:9c f0 20     stz input:himem
18de:8d f1 20     sta input:himem+1
18e1:80 d2        bra hiRead      ; try again in new bank
18e3:         
18e3:         ;
18e3:         ; unread last hiRead
18e3:         ; call only once after hiRead
18e3:         hiUnread
18e3:ad f0 20     lda input:himem
18e6:d0 03        bne :hi
18e8:ce f1 20     dec input:himem+1
18eb:         :hi
18eb:ce f0 20     dec input:himem
18ee:60           rts
18ef:             .in 'macro.asm'
18ef:             .in 'zp.asm'
18ef:             .fi ; zpAsm
18ef:         
18ef:         ;
18ef:         ; initialize macros
18ef:         macInit:
18ef:64 4d        stz argPtr      ; arg stack starts at the top from (not including) $9f00
18f1:a9 9f        lda #$9f
18f3:85 4e        sta argPtr+1
18f5:60           rts
18f6:         
18f6:         ;
18f6:         ; copy lineBuf to macro line
18f6:         ; if line's op is .em then sent back to lineAsm
18f6:         macLine:
18f6:a2 00        ldx #0
18f8:         :sym
18f8:20 bb 0e     jsr eIsSym      ; hop over possible symbol
18fb:d0 03        bne :field
18fd:e8           inx
18fe:d0 f8        bne :sym
1900:         :field
1900:20 fc 13     jsr lineNextToken
1903:f0 23        beq :write      ; and into the pseudo-op field
1905:c9 2e        cmp #'.         ; look for .em
1907:d0 1f        bne :write
1909:bd 01 25     lda lineBuf+1,x
190c:c9 45        cmp #'e
190e:d0 0a        bne :ma
1910:bd 02 25     lda lineBuf+2,x
1913:c9 4d        cmp #'m
1915:d0 11        bne :write
1917:4c 61 0f     jmp lineAsm2    ; feed this back to lineAsm instead
191a:         
191a:         :ma
191a:c9 4d        cmp #'m         ; look for .ma
191c:d0 0a        bne :write
191e:bd 02 25     lda lineBuf+2,x
1921:c9 41        cmp #'a
1923:d0 03        bne :write
1925:4c 61 0f     jmp lineAsm2    ; feed this back to lineAsm
1928:         
1928:         
1928:         :write
1928:a5 40        lda pass        ; pass 0 only
192a:d0 2c        bne :out
192c:         
192c:64 23        stz string
192e:         :loop
192e:a6 23        ldx string      ; copy line until EOL
1930:bd 00 25     lda lineBuf,x
1933:f0 1e        beq :cr         ; EOL
1935:c9 3b        cmp #';         ; comment line (be careful not to put ; in a .db string)
1937:f0 1a        beq :cr
1939:c9 21        cmp #33         ; check for consecutive whitespace
193b:b0 0b        bcs :writec
193d:bc 01 25     ldy lineBuf+1,x
1940:c0 21        cpy #33
1942:b0 04        bcs :writec
1944:e6 23        inc string      ; both us and next are whitespace, so skip this one
1946:d0 e6        bne :loop
1948:         :writec
1948:20 77 18     jsr hiWrite     ; write
194b:a5 46        lda error       ; check error
194d:d0 09        bne :out
194f:e6 23        inc string      ; next line char
1951:d0 db        bne :loop
1953:         :cr
1953:a9 0d        lda #13         ; cr
1955:4c 77 18     jmp hiWrite
1958:         :out
1958:60           rts
1959:         
1959:         ;
1959:         ; replay a macro
1959:         ; ptr contains the symbol entry
1959:         ; x points in lineBuf at first byte after symbol
1959:         macPlay:
1959:86 29        stx commaPtr
195b:20 71 15     jsr ioPush      ; push input state
195e:a2 07        ldx #7          ; copy 8 bytes from (ptr),5 to input:bank
1960:a0 0c        ldy #5+7        ; this covers bank, ptr, name, len, line
1962:         :input
1962:b1 27        lda (ptr),y
1964:9d ef 20     sta input:bank,x
1967:88           dey
1968:ca           dex
1969:10 f7        bpl :input
196b:         
196b:a9 01        lda #1          ; pseudo-lfn for macro replay
196d:8d e8 20     sta input:lfn
1970:a9 18        lda #<macRead
1972:8d f7 20     sta input:read
1975:a9 1a        lda #>macRead
1977:8d f8 20     sta input:read+1
197a:         
197a:a5 4d        lda argPtr      ; make note of arg stack
197c:a4 4e        ldy argPtr+1
197e:85 25        sta nptr
1980:84 26        sty nptr+1
1982:64 4f        stz argN        ; count positional args supplied
1984:         
1984:a6 29        ldx commaPtr
1986:         :args
1986:20 fc 13     jsr lineNextToken
1989:f0 15        beq :done
198b:86 29        stx commaPtr
198d:         :search
198d:c9 2c        cmp #',
198f:f0 06        beq :arg
1991:e8           inx
1992:20 f4 13     jsr lineEnd
1995:d0 f6        bne :search
1997:         :arg
1997:8a           txa
1998:38           sec
1999:e5 29        sbc commaPtr
199b:20 ba 19     jsr macPushArg  ; push the actual arg data
199e:80 e6        bra :args
19a0:         :done
19a0:         
19a0:         :pushN
19a0:a4 4f        ldy argN        ; push positional args in reverse order
19a2:f0 0f        beq :pushed
19a4:88           dey
19a5:88           dey
19a6:84 4f        sty argN
19a8:b9 22 21     lda macArgs,y
19ab:be 23 21     ldx macArgs+1,y
19ae:20 eb 19     jsr macPushN
19b1:80 ed        bra :pushN
19b3:         
19b3:         :pushed
19b3:a5 25        lda nptr
19b5:a6 26        ldx nptr+1
19b7:4c eb 19     jmp macPushN
19ba:         
19ba:         ;
19ba:         ; copy a bytes from lineBuf,commaPtr to stack
19ba:         ; x is left at 0 or one past comma
19ba:         macPushArg:
19ba:85 22        sta scratch
19bc:1a           inc
19bd:20 fc 19     jsr macPush     ; allocate the space
19c0:a4 4f        ldy argN        ; make note in positional args list
19c2:a5 4d        lda argPtr
19c4:99 22 21     sta macArgs,y
19c7:a5 4e        lda argPtr+1
19c9:99 23 21     sta macArgs+1,y
19cc:c8           iny
19cd:c8           iny
19ce:84 4f        sty argN        ; argN += 2 (indexes 16 bit values)
19d0:         
19d0:a6 29        ldx commaPtr    ; start copying
19d2:a0 00        ldy #0
19d4:         :loop
19d4:bd 00 25     lda lineBuf,x
19d7:f0 0d        beq :zero
19d9:c9 3b        cmp #';
19db:f0 09        beq :zero
19dd:e8           inx
19de:91 4d        sta (argPtr),y
19e0:c8           iny
19e1:c6 22        dec scratch
19e3:10 ef        bpl :loop
19e5:88           dey             ; back up over the comma
19e6:         :zero
19e6:a9 00        lda #0          ; write our terminating 0 to the arg data
19e8:91 4d        sta (argPtr),y
19ea:60           rts
19eb:         
19eb:         ;
19eb:         ; push 16 bit ax to macro stack
19eb:         macPushN:
19eb:85 22        sta scratch
19ed:a9 02        lda #2
19ef:20 fc 19     jsr macPush
19f2:a5 22        lda scratch
19f4:92 4d        sta (argPtr)
19f6:a0 01        ldy #1
19f8:8a           txa
19f9:91 4d        sta (argPtr),y
19fb:60           rts
19fc:         
19fc:         ;
19fc:         ; take a bytes from top of macro stack
19fc:         macPush:
19fc:85 23        sta scratch+1
19fe:a5 4d        lda argPtr
1a00:38           sec
1a01:e5 23        sbc scratch+1
1a03:85 4d        sta argPtr
1a05:a5 4e        lda argPtr+1
1a07:e9 00        sbc #0
1a09:85 4e        sta argPtr+1
1a0b:60           rts
1a0c:         
1a0c:         ;
1a0c:         ; pop original argPtr
1a0c:         macPop:
1a0c:b2 4d        lda (argPtr)
1a0e:aa           tax
1a0f:a0 01        ldy #1
1a11:b1 4d        lda (argPtr),y
1a13:85 4e        sta argPtr+1
1a15:86 4d        stx argPtr
1a17:60           rts
1a18:         
1a18:         ;
1a18:         ; character input for macro replay
1a18:         macRead:
1a18:20 b5 18     jsr hiRead      ; read macro text
1a1b:f0 33        beq :eof        ; eof
1a1d:         
1a1d:c9 40        cmp #'@         ; arg
1a1f:d0 2d        bne :out
1a21:         
1a21:20 b5 18     jsr hiRead      ; peek next
1a24:         
1a24:c9 3a        cmp #'9+1
1a26:b0 21        bcs :notArg
1a28:         
1a28:c9 30        cmp #'0
1a2a:90 1d        bcc :notArg
1a2c:         
1a2c:38           sec
1a2d:e9 2f        sbc #'0-1       ; get argN where @0 -> 1, @9 -> 10
1a2f:0a           asl
1a30:a8           tay             ; index into stack
1a31:b1 4d        lda (argPtr),y  ; set us up to read arg buffer
1a33:85 4b        sta ioIn
1a35:c8           iny
1a36:b1 4d        lda (argPtr),y
1a38:85 4c        sta ioIn+1
1a3a:9c eb 20     stz input:inPtr
1a3d:         
1a3d:a9 55        lda #<macArg
1a3f:a0 1a        ldy #>macArg
1a41:8d f7 20     sta input:read
1a44:8c f8 20     sty input:read+1
1a47:80 0c        bra macArg      ; and execute first go
1a49:         
1a49:         :notArg             ; not arg, unread and return the @
1a49:20 e3 18     jsr hiUnread
1a4c:a9 40        lda #'@
1a4e:         
1a4e:         :out
1a4e:18           clc             ; normal byte
1a4f:60           rts
1a50:         
1a50:         :eof
1a50:20 0c 1a     jsr macPop
1a53:38           sec
1a54:60           rts
1a55:         
1a55:         ;
1a55:         ; character input for macro arg
1a55:         macArg:
1a55:ac eb 20     ldy input:inPtr
1a58:b1 4b        lda (ioIn),y
1a5a:f0 05        beq :eoa        ; end of arg
1a5c:         
1a5c:ee eb 20     inc input:inPtr
1a5f:18           clc
1a60:60           rts
1a61:         
1a61:         :eoa
1a61:a9 18        lda #<macRead   ; resume input back from macro
1a63:a0 1a        ldy #>macRead
1a65:8d f7 20     sta input:read
1a68:8c f8 20     sty input:read+1
1a6b:80 ab        bra macRead
1a6d:             .in 'error.asm'
1a6d:             .in 'zp.asm'
1a6d:             .fi ; zpAsm
1a6d:             .in 'kernal.asm'
1a6d:             .fi ; kernalAsm
1a6d:         
1a6d:         
1a6d:         ;
1a6d:         ; print errror message
1a6d:         errPrint:
1a6d:a6 46        ldx error
1a6f:bd 79 1a     lda :table,x
1a72:bc 7a 1a     ldy :table+1,x
1a75:aa           tax
1a76:4c 58 18     jmp ioPrint
1a79:         :table
1a79:         errors:
1a79:         :fine   =*-errors
1a79:a1 1a        .dw :strings:fine
1a7b:         :dupLabel=*-errors
1a7b:a6 1a        .dw :strings:dupLabel
1a7d:         :star   =*-errors
1a7d:b0 1a        .dw :strings:star
1a7f:         :backward=*-errors
1a7f:ba 1a        .dw :strings:backward
1a81:         :eval   =*-errors
1a81:c8 1a        .dw :strings:eval
1a83:         :assign =*-errors
1a83:d7 1a        .dw :strings:assign
1a85:         :dotOp  =*-errors
1a85:e6 1a        .dw :strings:dotOp
1a87:         :op =*-errors
1a87:f8 1a        .dw :strings:op
1a89:         :mode   =*-errors
1a89:03 1b        .dw :strings:mode
1a8b:         :rel    =*-errors
1a8b:14 1b        .dw :strings:rel
1a8d:         :parse  =*-errors
1a8d:28 1b        .dw :strings:parse
1a8f:         :noArg  =*-errors
1a8f:35 1b        .dw :strings:noArg
1a91:         :emit   =*-errors
1a91:42 1b        .dw :strings:emit
1a93:         :dotArg =*-errors
1a93:51 1b        .dw :strings:dotArg
1a95:         :io =*-errors
1a95:63 1b        .dw :strings:io
1a97:         :tooMany=*-errors
1a97:6c 1b        .dw :strings:tooMany
1a99:         :noMem=*-errors
1a99:80 1b        .dw :strings:noMem
1a9b:         :inMac=*-errors
1a9b:93 1b        .dw :strings:inMac
1a9d:         :noMac=*-errors
1a9d:ae 1b        .dw :strings:noMac
1a9f:         :looping=*-errors
1a9f:c5 1b        .dw :strings:looping
1aa1:         
1aa1:         errors:strings:
1aa1:         :fine
1aa1:46 49 4e 45 00 
                 .db 'fine',0
1aa6:         :dupLabel
1aa6:44 55 50 20 4c 41 42 45 
1aae:4c 00        .db 'dup label',0
1ab0:         :star
1ab0:53 54 41 52 20 45 58 50 
1ab8:52 00        .db 'star expr',0
1aba:         :backward
1aba:50 43 20 4d 4f 56 45 44 
1ac2:20 42 41 43 4b 00 
                 .db 'pc moved back',0
1ac8:         :eval
1ac8:42 41 44 20 45 58 50 52 
1ad0:45 53 53 49 4f 4e 00 
                 .db 'bad expression',0
1ad7:         :assign
1ad7:4c 41 42 45 4c 20 45 58 
1adf:50 45 43 54 45 44 00 
                 .db 'label expected',0
1ae6:         :dotOp
1ae6:55 4e 4b 4e 4f 57 4e 20 
1aee:50 53 45 55 44 4f 20 4f 
1af6:50 00        .db 'unknown pseudo op',0
1af8:         :op
1af8:55 4e 4b 4e 4f 57 4e 20 
1b00:4f 50 00     .db 'unknown op',0
1b03:         :mode
1b03:42 41 44 20 41 44 44 52 
1b0b:45 53 53 20 4d 4f 44 45 
1b13:00           .db 'bad address mode',0
1b14:         :rel
1b14:42 52 41 4e 43 48 20 4f 
1b1c:55 54 20 4f 46 20 52 41 
1b24:4e 47 45 00 
                 .db 'branch out of range',0
1b28:         :parse
1b28:53 59 4e 54 41 58 20 45 
1b30:52 52 4f 52 00 
                 .db 'syntax error',0
1b35:         :noArg
1b35:41 52 47 20 45 58 50 45 
1b3d:43 54 45 44 00 
                 .db 'arg expected',0
1b42:         :emit
1b42:49 4f 20 57 52 49 54 45 
1b4a:20 45 52 52 4f 52 00 
                 .db 'io write error',0
1b51:         :dotArg
1b51:42 41 44 20 50 53 45 55 
1b59:44 4f 20 4f 50 20 41 52 
1b61:47 00        .db 'bad pseudo op arg',0
1b63:         :io
1b63:49 4f 20 45 52 52 4f 52 
1b6b:00           .db 'io error',0
1b6c:         :tooMany
1b6c:54 4f 4f 20 4d 41 4e 59 
1b74:20 4f 50 45 4e 20 46 49 
1b7c:4c 45 53 00 
                 .db 'too many open files',0
1b80:         :noMem
1b80:4f 55 54 20 4f 46 20 4d 
1b88:41 43 52 4f 20 53 50 41 
1b90:43 45 00     .db 'out of macro space',0
1b93:         :inMac
1b93:41 4c 52 45 41 44 59 20 
1b9b:49 4e 53 49 44 45 20 41 
1ba3:20 4d 41 43 52 4f 20 44 
1bab:45 46 00     .db 'already inside a macro def',0
1bae:         :noMac
1bae:4e 4f 54 20 49 4e 53 49 
1bb6:44 45 20 41 20 4d 41 43 
1bbe:52 4f 20 44 45 46 00 
                 .db 'not inside a macro def',0
1bc5:         :looping
1bc5:54 4f 4f 20 4d 41 4e 59 
1bcd:20 50 41 53 53 45 53 00 
1bd5:             .db 'too many passes',0
1bd5:             .in 'isns.asm'
1bd5:             .in 'zp.asm'
1bd5:             .fi ; zpAsm
1bd5:             .in 'mode.asm'
1bd5:             .fi ; modeAsm
1bd5:         
1bd5:         
1bd5:         
1bd5:         ;
1bd5:         ; return isn token at lineBuf,x
1bd5:         ; isnOp: result
1bd5:         ; C: not found
1bd5:         isnGet:
1bd5:             ; A,B,C = a-'A', b-'A', c-'A'
1bd5:             ; 
1bd5:             ; bit fedcba9876543210
1bd5:             ;     0AAAAABBBBBCCCCC
1bd5:             ; ex "LDA" is $2c60
1bd5:             ;
1bd5:bd 00 25     lda lineBuf,x
1bd8:38           sec
1bd9:e9 41        sbc #'a
1bdb:0a           asl
1bdc:0a           asl
1bdd:85 23        sta isn2
1bdf:bd 01 25     lda lineBuf+1,x
1be2:38           sec
1be3:e9 41        sbc #'a
1be5:85 22        sta isn1
1be7:4a           lsr
1be8:4a           lsr
1be9:4a           lsr
1bea:04 23        tsb isn2
1bec:a5 22        lda isn1
1bee:0a           asl
1bef:0a           asl
1bf0:0a           asl
1bf1:0a           asl
1bf2:0a           asl
1bf3:85 22        sta isn1
1bf5:bd 02 25     lda lineBuf+2,x
1bf8:38           sec
1bf9:e9 41        sbc #'a
1bfb:04 22        tsb isn1
1bfd:         
1bfd:             ; incr=1 element (2 bytes per entry)
1bfd:a0 02        ldy #2
1bff:84 24        sty incr
1c01:         
1c01:         :loop
1c01:a5 23        lda isn2        ; hi cmp
1c03:d9 71 1c     cmp isns+1,y
1c06:d0 07        bne :cmp        ; if =, continue with lo cmp
1c08:         
1c08:a5 22        lda isn1        ; lo cmp
1c0a:d9 70 1c     cmp isns,y
1c0d:f0 11        beq :found      ; if =, found
1c0f:         
1c0f:         :cmp
1c0f:90 05        bcc :lo         ; needle < haystack location?
1c11:20 24 1c     jsr :next       ; no: extra advance to do it twice
1c14:b0 09        bcs :not
1c16:         
1c16:         :lo
1c16:20 24 1c     jsr :next       ; advance
1c19:b0 04        bcs :not
1c1b:         
1c1b:06 24        asl incr        ; double incr for next advance
1c1d:90 e2        bcc :loop
1c1f:         :not
1c1f:60           rts             ; invariant: C=1
1c20:         
1c20:         :found
1c20:18           clc             ; C=0 to indicate found
1c21:84 33        sty isnOp
1c23:60           rts
1c24:         
1c24:         :next
1c24:98           tya             ; y += incr
1c25:18           clc
1c26:65 24        adc incr        ; C=1 if over
1c28:a8           tay
1c29:60           rts
1c2a:         
1c2a:         ;
1c2a:         ; resolve deduced address mode and instruction
1c2a:         opResolve:
1c2a:a6 33        ldx isnOp
1c2c:bd 71 1d     lda ops+1,x
1c2f:f0 2e        beq :imp
1c31:85 28        sta ptr+1
1c33:bd 70 1d     lda ops,x
1c36:85 27        sta ptr
1c38:         
1c38:             ; can we zp this?
1c38:a5 36        lda arg+1       ; no, it is a 16 bit arg
1c3a:d0 15        bne :try
1c3c:         
1c3c:a5 34        lda isnMode     ; does this have a potential zp version?
1c3e:c9 05        cmp #5
1c40:b0 0f        bcs :try        ; no
1c42:         
1c42:69 0a        adc #10         ; try the zp form
1c44:85 34        sta isnMode
1c46:20 51 1c     jsr :try
1c49:90 20        bcc :out        ; we win (or it was relative)
1c4b:         
1c4b:a5 34        lda isnMode
1c4d:e9 0a        sbc #10
1c4f:85 34        sta isnMode     ; continue with original absolute
1c51:         
1c51:         :try
1c51:a4 34        ldy isnMode
1c53:b1 27        lda (ptr),y
1c55:d0 11        bne :found      ; found it
1c57:         
1c57:a0 08        ldy #modeRel
1c59:b1 27        lda (ptr),y
1c5b:d0 0b        bne :found
1c5d:         
1c5d:80 0d        bra :err
1c5f:             
1c5f:         :imp
1c5f:a4 34        ldy isnMode     ; has to be modeImp
1c61:c0 07        cpy #modeImp
1c63:d0 07        bne :err
1c65:bd 70 1d     lda ops,x
1c68:             ; fall thru
1c68:         
1c68:         :found
1c68:84 34        sty isnMode
1c6a:18           clc
1c6b:         :out
1c6b:60           rts
1c6c:         
1c6c:         :err
1c6c:38           sec
1c6d:60           rts
1c6e:         
1c6e:             .in 'isns-table.asm'
1c6e:00 00    *=*%100
1c70:         isns:
1c70:00 00        .dw $0000
1c72:51 2e        .dw $2e51 ; 02 lsr
1c74:32 04        .dw $0432 ; 04 bbs
1c76:f2 4e        .dw $4ef2 ; 06 txs
1c78:00 00        .dw $0000
1c7a:22 48        .dw $4822 ; 0a sbc
1c7c:75 09        .dw $0975 ; 0c clv
1c7e:ff 7f        .dw $7fff
1c80:00 00        .dw $0000
1c82:6f 3d        .dw $3d6f ; 12 plp
1c84:eb 05        .dw $05eb ; 14 bpl
1c86:ff 7f        .dw $7fff
1c88:00 00        .dw $0000
1c8a:78 4a        .dw $4a78 ; 1a sty
1c8c:a2 21        .dw $21a2 ; 1c inc
1c8e:ff 7f        .dw $7fff
1c90:00 00        .dw $0000
1c92:ef 3c        .dw $3cef ; 22 php
1c94:90 04        .dw $0490 ; 24 beq
1c96:ff 7f        .dw $7fff
1c98:00 00        .dw $0000
1c9a:81 49        .dw $4981 ; 2a smb
1c9c:82 0c        .dw $0c82 ; 2c dec
1c9e:ff 7f        .dw $7fff
1ca0:00 00        .dw $0000
1ca2:cb 45        .dw $45cb ; 32 rol
1ca4:b2 06        .dw $06b2 ; 34 bvs
1ca6:ff 7f        .dw $7fff
1ca8:62 00        .dw $0062 ; 38 adc
1caa:21 4e        .dw $4e21 ; 3a trb
1cac:51 26        .dw $2651 ; 3c jsr
1cae:ff 7f        .dw $7fff
1cb0:00 00        .dw $0000
1cb2:20 3a        .dw $3a20 ; 42 ora
1cb4:42 04        .dw $0442 ; 44 bcc
1cb6:08 58        .dw $5808 ; 46 wai
1cb8:00 00        .dw $0000
1cba:83 48        .dw $4883 ; 4a sed
1cbc:f7 09        .dw $09f7 ; 4c cpx
1cbe:ff 7f        .dw $7fff
1cc0:00 00        .dw $0000
1cc2:78 3d        .dw $3d78 ; 52 ply
1cc4:2a 06        .dw $062a ; 54 brk
1cc6:ff 7f        .dw $7fff
1cc8:00 00        .dw $0000
1cca:17 4c        .dw $4c17 ; 5a tax
1ccc:b8 21        .dw $21b8 ; 5c iny
1cce:ff 7f        .dw $7fff
1cd0:00 00        .dw $0000
1cd2:f8 3c        .dw $3cf8 ; 62 phy
1cd4:88 05        .dw $0588 ; 64 bmi
1cd6:ff 7f        .dw $7fff
1cd8:00 00        .dw $0000
1cda:6f 4a        .dw $4a6f ; 6a stp
1cdc:98 0c        .dw $0c98 ; 6c dey
1cde:ff 7f        .dw $7fff
1ce0:00 00        .dw $0000
1ce2:68 46        .dw $4668 ; 72 rti
1ce4:63 09        .dw $0963 ; 74 cld
1ce6:ff 7f        .dw $7fff
1ce8:4b 02        .dw $024b ; 78 asl
1cea:57 4e        .dw $4e57 ; 7a tsx
1cec:77 2c        .dw $2c77 ; 7c ldx
1cee:ff 7f        .dw $7fff
1cf0:00 00        .dw $0000
1cf2:cf 35        .dw $35cf ; 82 nop
1cf4:42 04        .dw $0442 ; 84 bcc
1cf6:00 4f        .dw $4f00 ; 86 tya
1cf8:00 00        .dw $0000
1cfa:82 48        .dw $4882 ; 8a sec
1cfc:8f 09        .dw $098f ; 8c cmp
1cfe:ff 7f        .dw $7fff
1d00:00 00        .dw $0000
1d02:77 3d        .dw $3d77 ; 92 plx
1d04:20 06        .dw $0620 ; 94 bra
1d06:ff 7f        .dw $7fff
1d08:00 00        .dw $0000
1d0a:79 4a        .dw $4a79 ; 9a stz
1d0c:b7 21        .dw $21b7 ; 9c inx
1d0e:ff 7f        .dw $7fff
1d10:00 00        .dw $0000
1d12:f7 3c        .dw $3cf7 ; a2 phx
1d14:13 05        .dw $0513 ; a4 bit
1d16:ff 7f        .dw $7fff
1d18:00 00        .dw $0000
1d1a:60 4a        .dw $4a60 ; aa sta
1d1c:97 0c        .dw $0c97 ; ac dex
1d1e:ff 7f        .dw $7fff
1d20:00 00        .dw $0000
1d22:d1 45        .dw $45d1 ; b2 ror
1d24:62 09        .dw $0962 ; b4 clc
1d26:ff 7f        .dw $7fff
1d28:a3 01        .dw $01a3 ; b8 and
1d2a:41 4e        .dw $4e41 ; ba tsb
1d2c:60 2c        .dw $2c60 ; bc lda
1d2e:ff 7f        .dw $7fff
1d30:00 00        .dw $0000
1d32:e0 3c        .dw $3ce0 ; c2 pha
1d34:52 04        .dw $0452 ; c4 bcs
1d36:ff 7f        .dw $7fff
1d38:00 00        .dw $0000
1d3a:88 48        .dw $4888 ; ca sei
1d3c:f8 09        .dw $09f8 ; cc cpy
1d3e:ff 7f        .dw $7fff
1d40:00 00        .dw $0000
1d42:81 45        .dw $4581 ; d2 rmb
1d44:a2 06        .dw $06a2 ; d4 bvc
1d46:ff 7f        .dw $7fff
1d48:00 00        .dw $0000
1d4a:18 4c        .dw $4c18 ; da tay
1d4c:8f 25        .dw $258f ; dc jmp
1d4e:ff 7f        .dw $7fff
1d50:00 00        .dw $0000
1d52:60 3d        .dw $3d60 ; e2 pla
1d54:a4 05        .dw $05a4 ; e4 bne
1d56:ff 7f        .dw $7fff
1d58:00 00        .dw $0000
1d5a:77 4a        .dw $4a77 ; ea stx
1d5c:d1 11        .dw $11d1 ; ec eor
1d5e:ff 7f        .dw $7fff
1d60:00 00        .dw $0000
1d62:72 46        .dw $4672 ; f2 rts
1d64:68 09        .dw $0968 ; f4 cli
1d66:ff 7f        .dw $7fff
1d68:31 04        .dw $0431 ; f8 bbr
1d6a:e0 4e        .dw $4ee0 ; fa txa
1d6c:78 2c        .dw $2c78 ; fc ldy
1d6e:ff 7f        .dw $7fff
1d70:         
1d70:         ops:
1d70:00 00     .dw 0
1d72:10 20     .dw :lsr
1d74:b0 1e     .dw :bbs
1d76:9a 00     .dw $9a ; txs
1d78:00 00     .dw 0
1d7a:60 20     .dw :sbc
1d7c:b8 00     .dw $b8 ; clv
1d7e:00 00     .dw 0
1d80:00 00     .dw 0
1d82:28 00     .dw $28 ; plp
1d84:20 1f     .dw :bpl
1d86:00 00     .dw 0
1d88:00 00     .dw 0
1d8a:a0 20     .dw :sty
1d8c:b0 1f     .dw :inc
1d8e:00 00     .dw 0
1d90:00 00     .dw 0
1d92:08 00     .dw $08 ; php
1d94:e0 1e     .dw :beq
1d96:00 00     .dw 0
1d98:00 00     .dw 0
1d9a:70 20     .dw :smb
1d9c:90 1f     .dw :dec
1d9e:00 00     .dw 0
1da0:00 00     .dw 0
1da2:40 20     .dw :rol
1da4:50 1f     .dw :bvs
1da6:00 00     .dw 0
1da8:70 1e     .dw :adc
1daa:c0 20     .dw :trb
1dac:d0 1f     .dw :jsr
1dae:00 00     .dw 0
1db0:00 00     .dw 0
1db2:20 20     .dw :ora
1db4:c0 1e     .dw :bcc
1db6:cb 00     .dw $cb ; wai
1db8:00 00     .dw 0
1dba:f8 00     .dw $f8 ; sed
1dbc:70 1f     .dw :cpx
1dbe:00 00     .dw 0
1dc0:00 00     .dw 0
1dc2:7a 00     .dw $7a ; ply
1dc4:00 00     .dw $00 ; brk
1dc6:00 00     .dw 0
1dc8:00 00     .dw 0
1dca:aa 00     .dw $aa ; tax
1dcc:c8 00     .dw $c8 ; iny
1dce:00 00     .dw 0
1dd0:00 00     .dw 0
1dd2:5a 00     .dw $5a ; phy
1dd4:00 1f     .dw :bmi
1dd6:00 00     .dw 0
1dd8:00 00     .dw 0
1dda:db 00     .dw $db ; stp
1ddc:88 00     .dw $88 ; dey
1dde:00 00     .dw 0
1de0:00 00     .dw 0
1de2:40 00     .dw $40 ; rti
1de4:d8 00     .dw $d8 ; cld
1de6:00 00     .dw 0
1de8:90 1e     .dw :asl
1dea:ba 00     .dw $ba ; tsx
1dec:f0 1f     .dw :ldx
1dee:00 00     .dw 0
1df0:00 00     .dw 0
1df2:ea 00     .dw $ea ; nop
1df4:c0 1e     .dw :bcc
1df6:98 00     .dw $98 ; tya
1df8:00 00     .dw 0
1dfa:38 00     .dw $38 ; sec
1dfc:60 1f     .dw :cmp
1dfe:00 00     .dw 0
1e00:00 00     .dw 0
1e02:fa 00     .dw $fa ; plx
1e04:30 1f     .dw :bra
1e06:00 00     .dw 0
1e08:00 00     .dw 0
1e0a:b0 20     .dw :stz
1e0c:e8 00     .dw $e8 ; inx
1e0e:00 00     .dw 0
1e10:00 00     .dw 0
1e12:da 00     .dw $da ; phx
1e14:f0 1e     .dw :bit
1e16:00 00     .dw 0
1e18:00 00     .dw 0
1e1a:80 20     .dw :sta
1e1c:ca 00     .dw $ca ; dex
1e1e:00 00     .dw 0
1e20:00 00     .dw 0
1e22:50 20     .dw :ror
1e24:18 00     .dw $18 ; clc
1e26:00 00     .dw 0
1e28:80 1e     .dw :and
1e2a:d0 20     .dw :tsb
1e2c:e0 1f     .dw :lda
1e2e:00 00     .dw 0
1e30:00 00     .dw 0
1e32:48 00     .dw $48 ; pha
1e34:d0 1e     .dw :bcs
1e36:00 00     .dw 0
1e38:00 00     .dw 0
1e3a:78 00     .dw $78 ; sei
1e3c:80 1f     .dw :cpy
1e3e:00 00     .dw 0
1e40:00 00     .dw 0
1e42:30 20     .dw :rmb
1e44:40 1f     .dw :bvc
1e46:00 00     .dw 0
1e48:00 00     .dw 0
1e4a:a8 00     .dw $a8 ; tay
1e4c:c0 1f     .dw :jmp
1e4e:00 00     .dw 0
1e50:00 00     .dw 0
1e52:68 00     .dw $68 ; pla
1e54:10 1f     .dw :bne
1e56:00 00     .dw 0
1e58:00 00     .dw 0
1e5a:90 20     .dw :stx
1e5c:a0 1f     .dw :eor
1e5e:00 00     .dw 0
1e60:00 00     .dw 0
1e62:60 00     .dw $60 ; rts
1e64:58 00     .dw $58 ; cli
1e66:00 00     .dw 0
1e68:a0 1e     .dw :bbr
1e6a:8a 00     .dw $8a ; txa
1e6c:00 20     .dw :ldy
1e6e:00 00     .dw 0
1e70:         :adc
1e70:6d 00 7d 79 00 00 69 00 
1e78:00 00 65 61 75 00 72 71 
1e80:          .db $6d,$00,$7d,$79,$00,$00,$69,$00,$00,$00,$65,$61,$75,$00,$72,$71
1e80:         :and
1e80:2d 00 3d 39 00 00 29 00 
1e88:00 00 25 21 35 00 32 31 
1e90:          .db $2d,$00,$3d,$39,$00,$00,$29,$00,$00,$00,$25,$21,$35,$00,$32,$31
1e90:         :asl
1e90:0e 00 1e 00 00 00 00 0a 
1e98:00 00 06 00 16 00 00 00 
1ea0:          .db $0e,$00,$1e,$00,$00,$00,$00,$0a,$00,$00,$06,$00,$16,$00,$00,$00
1ea0:         :bbr
1ea0:00 00 00 00 00 00 00 00 
1ea8:00 0f 00 00 00 00 00 00 
1eb0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$0f,$00,$00,$00,$00,$00,$00
1eb0:         :bbs
1eb0:00 00 00 00 00 00 00 00 
1eb8:00 8f 00 00 00 00 00 00 
1ec0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$8f,$00,$00,$00,$00,$00,$00
1ec0:         :bcc
1ec0:00 00 00 00 00 00 00 00 
1ec8:90 00 00 00 00 00 00 00 
1ed0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$90,$00,$00,$00,$00,$00,$00,$00
1ed0:         :bcs
1ed0:00 00 00 00 00 00 00 00 
1ed8:b0 00 00 00 00 00 00 00 
1ee0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$b0,$00,$00,$00,$00,$00,$00,$00
1ee0:         :beq
1ee0:00 00 00 00 00 00 00 00 
1ee8:f0 00 00 00 00 00 00 00 
1ef0:          .db $00,$00,$00,$00,$00,$00,$00,$00,$f0,$00,$00,$00,$00,$00,$00,$00
1ef0:         :bit
1ef0:2c 00 3c 00 00 00 89 00 
1ef8:00 00 24 00 34 00 00 00 
1f00:          .db $2c,$00,$3c,$00,$00,$00,$89,$00,$00,$00,$24,$00,$34,$00,$00,$00
1f00:         :bmi
1f00:00 00 00 00 00 00 00 00 
1f08:30 00 00 00 00 00 00 00 
1f10:          .db $00,$00,$00,$00,$00,$00,$00,$00,$30,$00,$00,$00,$00,$00,$00,$00
1f10:         :bne
1f10:00 00 00 00 00 00 00 00 
1f18:d0 00 00 00 00 00 00 00 
1f20:          .db $00,$00,$00,$00,$00,$00,$00,$00,$d0,$00,$00,$00,$00,$00,$00,$00
1f20:         :bpl
1f20:00 00 00 00 00 00 00 00 
1f28:10 00 00 00 00 00 00 00 
1f30:          .db $00,$00,$00,$00,$00,$00,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00
1f30:         :bra
1f30:00 00 00 00 00 00 00 00 
1f38:80 00 00 00 00 00 00 00 
1f40:          .db $00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00
1f40:         :bvc
1f40:00 00 00 00 00 00 00 00 
1f48:50 00 00 00 00 00 00 00 
1f50:          .db $00,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00,$00,$00,$00,$00,$00
1f50:         :bvs
1f50:00 00 00 00 00 00 00 00 
1f58:70 00 00 00 00 00 00 00 
1f60:          .db $00,$00,$00,$00,$00,$00,$00,$00,$70,$00,$00,$00,$00,$00,$00,$00
1f60:         :cmp
1f60:cd 00 dd d9 00 00 c9 00 
1f68:00 00 c5 c1 d5 00 d2 d1 
1f70:          .db $cd,$00,$dd,$d9,$00,$00,$c9,$00,$00,$00,$c5,$c1,$d5,$00,$d2,$d1
1f70:         :cpx
1f70:ec 00 00 00 00 00 e0 00 
1f78:00 00 e4 00 00 00 00 00 
1f80:          .db $ec,$00,$00,$00,$00,$00,$e0,$00,$00,$00,$e4,$00,$00,$00,$00,$00
1f80:         :cpy
1f80:cc 00 00 00 00 00 c0 00 
1f88:00 00 c4 00 00 00 00 00 
1f90:          .db $cc,$00,$00,$00,$00,$00,$c0,$00,$00,$00,$c4,$00,$00,$00,$00,$00
1f90:         :dec
1f90:ce 00 de 00 00 00 00 3a 
1f98:00 00 c6 00 d6 00 00 00 
1fa0:          .db $ce,$00,$de,$00,$00,$00,$00,$3a,$00,$00,$c6,$00,$d6,$00,$00,$00
1fa0:         :eor
1fa0:4d 00 5d 59 00 00 49 00 
1fa8:00 00 45 41 55 00 52 51 
1fb0:          .db $4d,$00,$5d,$59,$00,$00,$49,$00,$00,$00,$45,$41,$55,$00,$52,$51
1fb0:         :inc
1fb0:ee 00 fe 00 00 00 00 1a 
1fb8:00 00 e6 00 f6 00 00 00 
1fc0:          .db $ee,$00,$fe,$00,$00,$00,$00,$1a,$00,$00,$e6,$00,$f6,$00,$00,$00
1fc0:         :jmp
1fc0:4c 7c 00 00 6c 00 00 00 
1fc8:00 00 00 00 00 00 00 00 
1fd0:          .db $4c,$7c,$00,$00,$6c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1fd0:         :jsr
1fd0:20 00 00 00 00 00 00 00 
1fd8:00 00 00 00 00 00 00 00 
1fe0:          .db $20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1fe0:         :lda
1fe0:ad 00 bd b9 00 00 a9 00 
1fe8:00 00 a5 a1 b5 00 b2 b1 
1ff0:          .db $ad,$00,$bd,$b9,$00,$00,$a9,$00,$00,$00,$a5,$a1,$b5,$00,$b2,$b1
1ff0:         :ldx
1ff0:ae 00 00 be 00 00 a2 00 
1ff8:00 00 a6 00 00 b6 00 00 
2000:          .db $ae,$00,$00,$be,$00,$00,$a2,$00,$00,$00,$a6,$00,$00,$b6,$00,$00
2000:         :ldy
2000:ac 00 bc 00 00 00 a0 00 
2008:00 00 a4 00 b4 00 00 00 
2010:          .db $ac,$00,$bc,$00,$00,$00,$a0,$00,$00,$00,$a4,$00,$b4,$00,$00,$00
2010:         :lsr
2010:4e 00 5e 00 00 00 00 4a 
2018:00 00 46 00 56 00 00 00 
2020:          .db $4e,$00,$5e,$00,$00,$00,$00,$4a,$00,$00,$46,$00,$56,$00,$00,$00
2020:         :ora
2020:0d 00 1d 19 00 00 09 00 
2028:00 00 05 01 15 00 12 11 
2030:          .db $0d,$00,$1d,$19,$00,$00,$09,$00,$00,$00,$05,$01,$15,$00,$12,$11
2030:         :rmb
2030:00 00 00 00 00 07 00 00 
2038:00 00 00 00 00 00 00 00 
2040:          .db $00,$00,$00,$00,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
2040:         :rol
2040:2e 00 3e 00 00 00 00 2a 
2048:00 00 26 00 36 00 00 00 
2050:          .db $2e,$00,$3e,$00,$00,$00,$00,$2a,$00,$00,$26,$00,$36,$00,$00,$00
2050:         :ror
2050:6e 00 7e 00 00 00 00 6a 
2058:00 00 66 00 76 00 00 00 
2060:          .db $6e,$00,$7e,$00,$00,$00,$00,$6a,$00,$00,$66,$00,$76,$00,$00,$00
2060:         :sbc
2060:ed 00 fd f9 00 00 e9 00 
2068:00 00 e5 e1 f5 00 f2 f1 
2070:          .db $ed,$00,$fd,$f9,$00,$00,$e9,$00,$00,$00,$e5,$e1,$f5,$00,$f2,$f1
2070:         :smb
2070:00 00 00 00 00 87 00 00 
2078:00 00 00 00 00 00 00 00 
2080:          .db $00,$00,$00,$00,$00,$87,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
2080:         :sta
2080:8d 00 9d 99 00 00 00 00 
2088:00 00 85 81 95 00 92 91 
2090:          .db $8d,$00,$9d,$99,$00,$00,$00,$00,$00,$00,$85,$81,$95,$00,$92,$91
2090:         :stx
2090:8e 00 00 00 00 00 00 00 
2098:00 00 86 00 00 96 00 00 
20a0:          .db $8e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$86,$00,$00,$96,$00,$00
20a0:         :sty
20a0:8c 00 00 00 00 00 00 00 
20a8:00 00 84 00 94 00 00 00 
20b0:          .db $8c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$84,$00,$94,$00,$00,$00
20b0:         :stz
20b0:9c 00 9e 00 00 00 00 00 
20b8:00 00 64 00 74 00 00 00 
20c0:          .db $9c,$00,$9e,$00,$00,$00,$00,$00,$00,$00,$64,$00,$74,$00,$00,$00
20c0:         :trb
20c0:1c 00 00 00 00 00 00 00 
20c8:00 00 14 00 00 00 00 00 
20d0:          .db $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$14,$00,$00,$00,$00,$00
20d0:         :tsb
20d0:0c 00 00 00 00 00 00 00 
20d8:00 00 04 00 00 00 00 00 
20e0:          .db $0c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$00,$00,$00,$00,$00
20e0:         ; size=$0470
20e0:         
20e0:         
20e0:             .in 'memory.asm'
20e0:         ;
20e0:         ; runtime data
20e0:         ; include LAST
20e0:         
20e0:         fpack:          ; 5 bytes of space for packed floating point number
20e0:             .or *+5
20e5:         emit:           ; emit vector
20e5:             .or *+2
20e7:         ioPtr:          ; io stack pointer
20e7:             .or *+1
20e8:         input:          ; current input state
20e8:         :lfn            ; logical file number
20e8:             .or *+1
20e9:         :dev            ; device
20e9:             .or *+1
20ea:         :status         ; eof/eol status of input buffer
20ea:             .or *+1
20eb:         :inPtr          ; pointer into input buffer
20eb:             .or *+1
20ec:         :in             ; input buffer
20ec:             .or *+2
20ee:         :bufLen         ; input buffer length
20ee:             .or *+1
20ef:         :bank           ; macro replay
20ef:             .or *+1
20f0:         :himem          ; macro replay
20f0:             .or *+2
20f2:         :name           ; filename
20f2:             .or *+2
20f4:         :nameLen        ; filename length
20f4:             .or *+1
20f5:         :line           ; line number
20f5:             .or *+2
20f7:         :read           ; read another byte vector
20f7:             .or *+2
20f9:         :size = *-input
20f9:         
20f9:         ioFDS:          ; allocation bitmap of channels
20f9:             .or *+1
20fa:         asmSP:          ; stack frame we started with
20fa:             .or *+1
20fb:         lineSP:         ; stack frame for calls into per line assembly for error return
20fb:             .or *+1
20fc:         argZ:           ; first zp of zp,arg
20fc:             .or *+1
20fd:         ioColumn:       ; listing output column
20fd:             .or *+1
20fe:         pc:             ; pc
20fe:             .or *+2
2100:         accum:          ; expression register
2100:             .or *+2
2102:         inputOpt:       ; input filename length
2102:             .or *+1
2103:         inputName:      ; input filename
2103:             .or *+2
2105:         listOpt:        ; listing filename length
2105:             .or *+1
2106:         listName:       ; listing filename
2106:             .or *+2
2108:         outOpt:         ; output filename length
2108:             .or *+1
2109:         outName:        ; output filename
2109:             .or *+2
210b:         tScope:         ; save scope
210b:             .or *+2
210d:         bank:           ; himem bank in use
210d:             .or *+1
210e:         himem:          ; himem pointer ($a000-$bfff)
210e:             .or *+2
2110:         inMac:          ; recording a macro (the only directive we see is .em)
2110:             .or *+1
2111:         inArg:          ; @ state of reader
2111:             .or *+1
2112:         ioBufs:         ; allocated io buffers
2112:             .or *+$10
2122:         macArgs:        ; argument temp workspace
2122:             .or *+20
2136:         
2136:             .or *%$100  ; page align
2200:         ioBuf:          ; binary output buffer
2200:             .or *+$100
2300:         ioStack:        ; source file stack
2300:             .or *+$100
2400:         eStack:         ; numeric evaluation stack
2400:             .or *+$100
2500:         lineBuf:        ; line to parse
2500:             .or *+$100
2600:         hashTable:      ; symbol hash table page
2600:             .or *+$100
2700:         symbols:        ; start of symbol table
2700:         
2700:         
2700:         
2700: