1000:01 08        .dw $801
1002:             .or $801
0801:         
0801:             ; 10 SYS 2062
0801:0c 08 0a 00 
                 .dw zero, 10
0805:9e 20 32 30 36 32 00 
                 .db $9e,' 2062',0
080c:         zero:
080c:00 00        .dw 0
080e:         
080e:             *=2062
080e:         
080e:             .in 'zp.asm'
080e:             .fi ; zpAsm
080e:         
080e:             .in 'kernal.asm'
080e:             .fi ; kernalAsm
080e:         
080e:         
080e:         options=$bf00
080e:         
080e:ba           tsx
080f:8e 0d 22     stx asmSP
0812:20 f1 12     jsr ioInit
0815:20 e5 09     jsr symInit
0818:64 40        stz pass
081a:9c 14 22     stz listOpt
081d:9c 15 22     stz outOpt
0820:64 44        stz lineIfs
0822:64 45        stz lineIfd
0824:a9 ff        lda #$ff
0826:85 43        sta ePtr
0828:80 0a        bra begin
082a:         
082a:         usage:
082a:a2 86        ldx #<usageStr
082c:a0 09        ldy #>usageStr
082e:20 b0 16     jsr ioPrint
0831:4c 6f 09     jmp exit
0834:         
0834:         begin:
0834:64 00        stz $00             ; select system bank for params
0836:a9 04        lda #4
0838:85 01        sta $01             ; select rom bank 4
083a:20 c6 09     jsr getOpt
083d:c9 00        cmp #0
083f:d0 07        bne :got
0841:20 23 09     jsr askArgs         ; get interactively
0844:c9 00        cmp #0
0846:f0 e2        beq usage
0848:         :got
0848:20 9f 13     jsr ioCopySourceName
084b:8d 13 22     sta inputOpt        ; source filename length
084e:86 4c        stx inputName
0850:84 4d        sty inputName+1
0852:         
0852:20 c6 09     jsr getOpt          ; output
0855:c9 00        cmp #0
0857:f0 0a        beq :nooutOpt
0859:20 69 13     jsr ioCopyDestName
085c:8d 15 22     sta outOpt          ; dest filename length
085f:86 4e        stx outName
0861:84 4f        sty outName+1
0863:         :nooutOpt
0863:         
0863:20 c6 09     jsr getOpt          ; listing
0866:c9 00        cmp #0
0868:f0 0a        beq :nolistOpt
086a:20 84 13     jsr ioCopyListName
086d:8d 14 22     sta listOpt
0870:86 4a        stx listName
0872:84 4b        sty listName+1
0874:         :nolistOpt
0874:         
0874:         asmPass:
0874:64 2d        stz symScope
0876:64 2e        stz symScope+1
0878:         
0878:a6 4c        ldx inputName
087a:a4 4d        ldy inputName+1
087c:ad 13 22     lda inputOpt
087f:20 14 14     jsr ioPush
0882:         
0882:9c 11 22     stz pc
0885:a9 10        lda #$10
0887:8d 12 22     sta pc+1            ; default pc=$1000
088a:         
088a:a2 af        ldx #<passStr       ; "pass:n"
088c:a0 09        ldy #>passStr
088e:20 b0 16     jsr ioPrint
0891:a5 40        lda pass            ; pass #
0893:29 07        and #$07
0895:1a           inc
0896:20 80 16     jsr ioPrintHex
0899:a9 0d        lda #13             ; cr
089b:20 d2 ff     jsr CHROUT
089e:         
089e:         :line
089e:20 36 16     jsr ioListing       ; possibly show pc for listing
08a1:20 13 15     jsr ioReadLine      ; read next line
08a4:20 7c 09     jsr asmError        ; poll for error
08a7:ad 0b 22     lda ioLFN           ; check for EOF
08aa:f0 29        beq :next
08ac:         
08ac:20 c5 0e     jsr lineAsm         ; assemble line
08af:20 7c 09     jsr asmError        ; poll for error
08b2:         
08b2:a5 40        lda pass
08b4:10 e8        bpl :line           ; listing output in second pass, if enabled
08b6:a5 44        lda lineIfs
08b8:30 e4        bmi :line           ; do not list if'd out 
08ba:         
08ba:20 53 16     jsr ioPadListing
08bd:         
08bd:a2 00        ldx #0
08bf:         :listLine
08bf:bd 00 20     lda lineBuf,x
08c2:f0 0a        beq :listed         ; eof
08c4:c9 0d        cmp #13
08c6:f0 06        beq :listed         ; cr
08c8:20 69 15     jsr ioEmit
08cb:e8           inx
08cc:d0 f1        bne :listLine
08ce:         :listed
08ce:a9 0d        lda #13
08d0:20 69 15     jsr ioEmit
08d3:80 c9        bra :line
08d5:         
08d5:         :next
08d5:a5 40        lda pass            ; maybe done if non-z pass
08d7:d0 1f        bne :listing
08d9:1a           inc                 ; pass++
08da:85 40        sta pass
08dc:         
08dc:ad 15 22     lda outOpt          ; do we have output?
08df:f0 17        beq :listing        ; no, skip to listing (if enabled)
08e1:         
08e1:a6 4e        ldx outName         ; set up output filename
08e3:a4 4f        ldy outName+1
08e5:20 fa 13     jsr ioOpenDest      ; open
08e8:20 7c 09     jsr asmError        ; poll for error
08eb:         
08eb:a9 69        lda #<ioEmit        ; connect the output hose
08ed:8d 05 22     sta emit
08f0:a9 15        lda #>ioEmit
08f2:8d 06 22     sta emit+1
08f5:4c 74 08     jmp asmPass         ; go around again
08f8:         
08f8:         :listing
08f8:20 ea 15     jsr ioClose         ; flush and close output or listing
08fb:20 7c 09     jsr asmError
08fe:         
08fe:a5 40        lda pass
0900:30 44        bmi asmDone         ; listed, we are done
0902:1a           inc
0903:09 80        ora #$80
0905:85 40        sta pass
0907:         
0907:ad 14 22     lda listOpt
090a:f0 3a        beq asmDone         ; no listing, we are done
090c:         
090c:a6 4a        ldx listName        ; open the listing file  
090e:a4 4b        ldy listName+1
0910:         
0910:20 fa 13     jsr ioOpenDest      ; open
0913:20 7c 09     jsr asmError        ; poll for error
0916:         
0916:a9 80        lda #<ioEmitListing
0918:8d 05 22     sta emit
091b:a9 15        lda #>ioEmitListing
091d:8d 06 22     sta emit+1
0920:4c 74 08     jmp asmPass
0923:         
0923:         askArgs:
0923:a9 3f        lda #'?
0925:20 d2 ff     jsr CHROUT
0928:a2 00        ldx #0
092a:86 25        stx optPtr
092c:         :loop
092c:20 cf ff     jsr CHRIN
092f:c9 0d        cmp #13
0931:f0 06        beq :done
0933:9d 00 bf     sta options,x
0936:e8           inx
0937:d0 f3        bne :loop
0939:         :done
0939:9e 00 bf     stz options,x
093c:a9 0d        lda #13             ; cr
093e:20 d2 ff     jsr CHROUT
0941:64 25        stz optPtr
0943:4c c6 09     jmp getOpt
0946:         
0946:         asmDone:
0946:a2 b6        ldx #<symendStr     ; "symend="
0948:a0 09        ldy #>symendStr
094a:20 b0 16     jsr ioPrint
094d:a5 42        lda symEnd+1
094f:20 80 16     jsr ioPrintHex
0952:a5 41        lda symEnd
0954:20 80 16     jsr ioPrintHex
0957:a2 c0        ldx #<pcStr         ; "pc="
0959:a0 09        ldy #>pcStr
095b:20 b0 16     jsr ioPrint
095e:ad 12 22     lda pc+1
0961:20 80 16     jsr ioPrintHex
0964:ad 11 22     lda pc
0967:20 80 16     jsr ioPrintHex
096a:a9 0d        lda #13
096c:20 d2 ff     jsr CHROUT
096f:         
096f:         exit:
096f:a2 00        ldx #0              ; zero out options buf on our way out
0971:         :fill
0971:9e 00 bf     stz options,x
0974:e8           inx
0975:d0 fa        bne :fill
0977:ae 0d 22     ldx asmSP           ; get top level stack pointer
097a:9a           txs
097b:60           rts                 ; exit out completely    
097c:         
097c:         asmError:
097c:a5 46        lda error           ; error non-z?
097e:f0 05        beq :fine
0980:20 1e 13     jsr ioError         ; print error
0983:80 ea        bra exit            ; abort
0985:         :fine
0985:60           rts
0986:         
0986:         usageStr:
0986:55 53 41 47 45 3a 20 58 
098e:41 53 4d 20 49 4e 50 55 
0996:54 2e 41 53 4d 5b 3b 4f 
099e:55 54 50 55 54 5d 5b 3b 
09a6:4c 49 53 54 49 4e 47 5d 
09ae:00           .db 'usage: xasm input.asm[;output][;listing]',0
09af:         passStr:
09af:0d 50 41 53 53 3a 00 
                 .db 13,'pass:',0
09b6:         symendStr:
09b6:0d 53 59 4d c5 4e 44 3d 
09be:24 00        .db 13,'symEnd=$',0
09c0:         pcStr:
09c0:0d 50 43 3d 24 00 
                 .db 13,'pc=$',0
09c6:         
09c6:         ;
09c6:         ; returns next option in a/x/y
09c6:         getOpt:
09c6:a6 25        ldx optPtr
09c8:86 22        stx scratch
09ca:a0 00        ldy #0
09cc:         :loop
09cc:bd 00 bf     lda options,x
09cf:f0 0c        beq :got
09d1:c9 0d        cmp #13         ; cr (shouldn't see this, but be defensive)
09d3:f0 08        beq :got
09d5:e8           inx
09d6:c9 3b        cmp #';
09d8:f0 03        beq :got
09da:c8           iny
09db:d0 ef        bne :loop
09dd:         :got
09dd:98           tya
09de:86 25        stx optPtr
09e0:a6 22        ldx scratch
09e2:a0 bf        ldy #>options
09e4:60           rts
09e5:          
09e5:             .in 'symtab.asm'
09e5:             .in 'zp.asm'
09e5:             .fi ; zpAsm
09e5:         
09e5:         
09e5:         ;
09e5:         ; initialize hash table
09e5:         symInit:
09e5:a9 18        lda #<symbols
09e7:85 41        sta symEnd
09e9:a9 22        lda #>symbols
09eb:85 42        sta symEnd+1
09ed:a2 00        ldx #0
09ef:         
09ef:         :fill
09ef:9e 00 21     stz hashTable,x
09f2:e8           inx
09f3:d0 fa        bne :fill
09f5:         
09f5:60           rts
09f6:         
09f6:         ; layout of a symbol entry:
09f6:         ; 00-01:    next (0 if end)
09f6:         ; 02-03:    scope (parent entry, or 0)
09f6:         ; 04:       caller status
09f6:         ; 05-06:    value
09f6:         
09f6:         ;
09f6:         ; enter or return existing symbol entry
09f6:         ; result in ptr
09f6:         symGet:
09f6:             ; string = strGet
09f6:             ; nptr = (string).symbols
09f6:20 57 0a     jsr strGet
09f9:a0 02        ldy #2
09fb:b1 27        lda (ptr),y
09fd:85 25        sta nptr
09ff:a5 27        lda ptr
0a01:85 23        sta string
0a03:c8           iny
0a04:b1 27        lda (ptr),y
0a06:85 26        sta nptr+1
0a08:a5 28        lda ptr+1
0a0a:85 24        sta string+1
0a0c:         
0a0c:         :next
0a0c:20 fb 0a     jsr ptrNext
0a0f:f0 0e        beq :notFound
0a11:         
0a11:             ; compare scope
0a11:b1 27        lda (ptr),y
0a13:c5 2d        cmp symScope
0a15:d0 f5        bne :next
0a17:c8           iny
0a18:b1 27        lda (ptr),y
0a1a:c5 2e        cmp symScope+1
0a1c:d0 ee        bne :next
0a1e:         
0a1e:             ; found!
0a1e:60           rts
0a1f:         
0a1f:         :notFound
0a1f:             ; push our scoped entry
0a1f:             ; ptr = symEnd
0a1f:             ; symEnd += 7
0a1f:a9 07        lda #7
0a21:20 e7 0a     jsr symPush
0a24:         
0a24:         
0a24:             ; nptr = (string).symbols
0a24:             ; (string).symbols = ptr
0a24:a0 02        ldy #2
0a26:b1 23        lda (string),y
0a28:85 25        sta nptr
0a2a:a5 27        lda ptr
0a2c:91 23        sta (string),y
0a2e:c8           iny
0a2f:         
0a2f:b1 23        lda (string),y
0a31:85 26        sta nptr+1
0a33:a5 28        lda ptr+1
0a35:91 23        sta (string),y
0a37:         
0a37:             ; (ptr++)=nptr
0a37:             ; next linkage
0a37:a0 00        ldy #0
0a39:a5 25        lda nptr
0a3b:91 27        sta (ptr),y
0a3d:c8           iny
0a3e:         
0a3e:a5 26        lda nptr+1
0a40:91 27        sta (ptr),y
0a42:c8           iny
0a43:         
0a43:             ; (ptr++)=scope
0a43:a5 2d        lda symScope
0a45:91 27        sta (ptr),y
0a47:c8           iny
0a48:         
0a48:a5 2e        lda symScope+1
0a4a:91 27        sta (ptr),y
0a4c:c8           iny
0a4d:         
0a4d:             ; (ptr++)=0
0a4d:             ; zero out flags when creating
0a4d:a9 00        lda #0
0a4f:91 27        sta (ptr),y
0a51:c8           iny
0a52:         
0a52:             ; (++ptr)=non-zero
0a52:             ; default value (forward decl) not presumed to be zero page
0a52:c8           iny
0a53:98           tya
0a54:91 27        sta (ptr),y
0a56:         
0a56:60           rts
0a57:         
0a57:         
0a57:         ; layout of a string entry:
0a57:         ; 00-01:    next (0 if end)
0a57:         ; 02-03:    symbols having this label
0a57:         ; 04-??:    counted string
0a57:         
0a57:         ;
0a57:         ; enter or return existing counted string
0a57:         ; result in ptr
0a57:         strGet:
0a57:             ; nptr = hash(symLabel)
0a57:20 d6 0a     jsr strHash
0a5a:bd 00 21     lda hashTable,x
0a5d:85 25        sta nptr
0a5f:bd 01 21     lda hashTable+1,x
0a62:85 26        sta nptr+1
0a64:         
0a64:         :next
0a64:20 fb 0a     jsr ptrNext
0a67:f0 13        beq :notFound
0a69:         
0a69:             ; compare string
0a69:             ; string = ptr+4
0a69:a5 27        lda ptr
0a6b:18           clc
0a6c:69 04        adc #4
0a6e:85 23        sta string
0a70:a5 28        lda ptr+1
0a72:69 00        adc #0
0a74:85 24        sta string+1
0a76:20 12 0b     jsr strEqual
0a79:d0 e9        bne :next
0a7b:         
0a7b:             ; found/created, result in ptr
0a7b:         :done
0a7b:60           rts
0a7c:         
0a7c:         :notFound
0a7c:             ; write new entry to head of list
0a7c:             ; nptr = hashEntry
0a7c:bd 00 21     lda hashTable,x
0a7f:85 25        sta nptr
0a81:bd 01 21     lda hashTable+1,x
0a84:85 26        sta nptr+1
0a86:         
0a86:             ; hash = symEnd
0a86:             ; ptr = symEnd
0a86:             ; symEnd += 5 + symLength
0a86:a9 05        lda #5
0a88:20 e7 0a     jsr symPush
0a8b:         
0a8b:a5 27        lda ptr
0a8d:9d 00 21     sta hashTable,x
0a90:a5 28        lda ptr+1
0a92:9d 01 21     sta hashTable+1,x
0a95:         
0a95:a5 2f        lda symLength
0a97:20 e7 0a     jsr symPush
0a9a:         
0a9a:             ; (ptr++) = nptr
0a9a:bd 00 21     lda hashTable,x
0a9d:85 27        sta ptr
0a9f:bd 01 21     lda hashTable+1,x
0aa2:85 28        sta ptr+1
0aa4:             
0aa4:a0 00        ldy #0
0aa6:a5 25        lda nptr
0aa8:91 27        sta (ptr),y
0aaa:c8           iny
0aab:a5 26        lda nptr+1
0aad:91 27        sta (ptr),y
0aaf:c8           iny
0ab0:         
0ab0:             ; (ptr++) = $0000
0ab0:             ; (symbol entries pointer)
0ab0:a9 00        lda #0
0ab2:91 27        sta (ptr),y
0ab4:c8           iny
0ab5:91 27        sta (ptr),y
0ab7:c8           iny
0ab8:         
0ab8:             ; (ptr) = symLength
0ab8:a5 2f        lda symLength
0aba:91 27        sta (ptr),y
0abc:         
0abc:             ; string = ptr+5
0abc:a5 27        lda ptr
0abe:18           clc
0abf:69 05        adc #5
0ac1:85 23        sta string
0ac3:a5 28        lda ptr+1
0ac5:69 00        adc #0
0ac7:85 24        sta string+1
0ac9:         
0ac9:a0 00        ldy #0
0acb:         :copy
0acb:c4 2f        cpy symLength
0acd:f0 ac        beq :done
0acf:b1 31        lda (symLabel),y
0ad1:91 23        sta (string),y
0ad3:c8           iny
0ad4:d0 f5        bne :copy
0ad6:         
0ad6:         ;
0ad6:         ; compute hash value for counted string
0ad6:         strHash:
0ad6:a5 2f        lda symLength
0ad8:a8           tay
0ad9:18           clc
0ada:         :loop
0ada:f0 08        beq :done
0adc:88           dey
0add:2a           rol                 ; c << output << c
0ade:51 31        eor (symLabel),y    ; output = output xor byte
0ae0:c8           iny
0ae1:88           dey
0ae2:d0 f6        bne :loop
0ae4:         
0ae4:             ; truncate to 7 bit
0ae4:         :done
0ae4:0a           asl
0ae5:aa           tax                 ; result in index form
0ae6:60           rts
0ae7:         
0ae7:         ;
0ae7:         ; push symEnd by A bytes
0ae7:         ; ptr=symEnd before increment
0ae7:         symPush:
0ae7:85 22        sta scratch
0ae9:a5 41        lda symEnd
0aeb:85 27        sta ptr
0aed:18           clc
0aee:65 22        adc scratch
0af0:85 41        sta symEnd
0af2:a5 42        lda symEnd+1
0af4:85 28        sta ptr+1
0af6:69 00        adc #0
0af8:85 42        sta symEnd+1
0afa:60           rts
0afb:         
0afb:         ;
0afb:         ; ptr=nptr, nptr=(ptr)
0afb:         ; Z if nptrH=0
0afb:         ; Y=2 otherwise
0afb:         ptrNext:
0afb:a5 26        lda nptr+1
0afd:f0 12        beq :out            ; nptrH=0
0aff:85 28        sta ptr+1
0b01:a5 25        lda nptr
0b03:85 27        sta ptr
0b05:a0 00        ldy #0
0b07:b1 27        lda (ptr),y
0b09:85 25        sta nptr
0b0b:c8           iny
0b0c:b1 27        lda (ptr),y         ; Z=0
0b0e:85 26        sta nptr+1
0b10:c8           iny
0b11:         :out
0b11:60           rts
0b12:         
0b12:         ;
0b12:         ; compare counted string at (string) against symLength/symLabel
0b12:         ; for equality, Z=1 if so
0b12:         strEqual:
0b12:a0 00        ldy #0
0b14:b1 23        lda (string),y
0b16:c5 2f        cmp symLength
0b18:d0 0d        bne :out
0b1a:         :loop
0b1a:c4 2f        cpy symLength
0b1c:f0 09        beq :out
0b1e:b1 31        lda (symLabel),y
0b20:c8           iny
0b21:d1 23        cmp (string),y
0b23:d0 02        bne :out
0b25:f0 f3        beq :loop
0b27:         :out
0b27:60           rts
0b28:         
0b28:             .in 'eval.asm'
0b28:             .in 'zp.asm'
0b28:             .fi ; zpAsm
0b28:         
0b28:         
0b28:         esInit  = 0
0b28:         esOp    = 1
0b28:         
0b28:         
0b28:         eDone:
0b28:             ; err if not in esOp state
0b28:18           clc
0b29:a5 3c        lda eState
0b2b:f0 01        beq :error
0b2d:60           rts
0b2e:         :error
0b2e:38           sec
0b2f:60           rts
0b30:         
0b30:         ;
0b30:         ; normalize petscii in A into lineBuf,x
0b30:         ePet:
0b30:85 22        sta scratch
0b32:29 e0        and #$e0
0b34:c9 60        cmp #$60        ; %011xxxxx -> %110xxxxx
0b36:d0 08        bne :nopet
0b38:a5 22        lda scratch
0b3a:49 a0        eor #$a0
0b3c:9d 00 20     sta lineBuf,x
0b3f:60           rts
0b40:         :nopet
0b40:a5 22        lda scratch
0b42:60           rts
0b43:         
0b43:         ;
0b43:         ; evaluate expression at lineBuf,x
0b43:         eEval:
0b43:64 3c        stz eState
0b45:64 3b        stz eOp
0b47:64 35        stz arg
0b49:64 36        stz arg+1
0b4b:20 cb 0d     jsr ePush
0b4e:         
0b4e:         :loop
0b4e:bd 00 20     lda lineBuf,x
0b51:f0 d5        beq eDone       ; eof
0b53:c9 2c        cmp #',
0b55:f0 d1        beq eDone
0b57:c9 3b        cmp #';
0b59:f0 cd        beq eDone
0b5b:c9 29        cmp #')
0b5d:f0 c9        beq eDone
0b5f:         
0b5f:a4 3c        ldy eState
0b61:d0 26        bne :op
0b63:         
0b63:         :init
0b63:20 ff 0d     jsr eIsDec
0b66:b0 4f        bcs :dec
0b68:20 30 0e     jsr eIsAlpha
0b6b:b0 6b        bcs :tosym
0b6d:c9 3a        cmp #':
0b6f:f0 67        beq :tosym
0b71:c9 25        cmp #'%
0b73:f0 58        beq :bin
0b75:c9 24        cmp #'$
0b77:f0 49        beq :hex
0b79:c9 28        cmp #'(
0b7b:f0 65        beq :sub
0b7d:c9 2a        cmp #'*
0b7f:f0 71        beq :pc
0b81:c9 27        cmp #''
0b83:f0 7a        beq :char
0b85:             
0b85:a0 80        ldy #$80        ; indicate unary
0b87:84 3b        sty eOp
0b89:             ; fall thru
0b89:         
0b89:         :op
0b89:e8           inx
0b8a:         
0b8a:29 7f        and #$7f        ; normalize petscii whitespace (shift+space)
0b8c:c9 21        cmp #33         ; whitespace?
0b8e:90 be        bcc :loop
0b90:         
0b90:05 3b        ora eOp         ; push unary or binary op
0b92:85 3b        sta eOp
0b94:         
0b94:c9 3e        cmp #'>
0b96:f0 0a        beq :optwo
0b98:             
0b98:c9 3c        cmp #'<
0b9a:f0 06        beq :optwo
0b9c:         
0b9c:c9 21        cmp #'!
0b9e:f0 02        beq :optwo
0ba0:             
0ba0:80 0e        bra :opone
0ba2:         
0ba2:         :optwo
0ba2:bd 00 20     lda lineBuf,x
0ba5:c9 3d        cmp #'=
0ba7:d0 07        bne :opone 
0ba9:         
0ba9:e8           inx             ; this is >=, <=, or !=
0baa:a9 40        lda #$40        ; add 64 to indicate = suffix
0bac:05 3b        ora eOp
0bae:85 3b        sta eOp
0bb0:         
0bb0:         :opone
0bb0:20 cb 0d     jsr ePush
0bb3:64 3c        stz eState
0bb5:80 97        bra :loop
0bb7:         
0bb7:         :dec
0bb7:20 ff 0d     jsr eIsDec
0bba:90 57        bcc :term       ; not a decimal digit?
0bbc:20 6a 0d     jsr eDec
0bbf:e8           inx
0bc0:d0 f5        bne :dec
0bc2:         
0bc2:         :hex
0bc2:e8           inx
0bc3:20 15 0e     jsr eIsHex
0bc6:90 4b        bcc :term       ; not a hex digit?
0bc8:20 9d 0d     jsr eHex
0bcb:80 f5        bra :hex
0bcd:             
0bcd:         :bin
0bcd:e8           inx
0bce:20 26 0e     jsr eIsBin
0bd1:d0 40        bne :term       ; not a binary digit?
0bd3:20 bf 0d     jsr eBin
0bd6:80 f5        bra :bin
0bd8:         
0bd8:         :tosym
0bd8:86 3d        stx labelPtr    ; note where it starts
0bda:             
0bda:         :sym
0bda:20 48 0e     jsr eIsSym
0bdd:d0 2b        bne :termsym
0bdf:e8           inx
0be0:80 f8        bra :sym
0be2:         
0be2:         :sub
0be2:e8           inx             ; skip '('
0be3:20 43 0b     jsr eEval       ; evaluate subexpression
0be6:b0 39        bcs :out
0be8:bd 00 20     lda lineBuf,x
0beb:c9 29        cmp #')
0bed:d0 24        bne :term
0bef:e8           inx             ; consume ')'
0bf0:80 21        bra :term
0bf2:         
0bf2:         :pc
0bf2:e8           inx             ; skip '*'
0bf3:ad 11 22     lda pc          ; arg=pc
0bf6:85 35        sta arg
0bf8:ad 12 22     lda pc+1
0bfb:85 36        sta arg+1
0bfd:80 14        bra :term
0bff:         
0bff:         :char
0bff:e8           inx             ; skip '
0c00:bd 00 20     lda lineBuf,x   ; arg=literal character
0c03:e8           inx             ; consume
0c04:85 35        sta arg
0c06:64 36        stz arg+1
0c08:80 09        bra :term
0c0a:         
0c0a:         :termsym
0c0a:86 29        stx labelEnd
0c0c:20 58 0e     jsr eResolveSym ; resolve label value into arg
0c0f:b0 10        bcs :out
0c11:a6 29        ldx labelEnd
0c13:             ; fall thru
0c13:         
0c13:         :term
0c13:20 22 0c     jsr eExec       ; pop and execute what we have so far
0c16:b0 09        bcs :out
0c18:a9 01        lda #esOp       ; now in op state
0c1a:85 3c        sta eState
0c1c:64 3b        stz eOp         ; clear op, and not unary
0c1e:4c 4e 0b     jmp :loop
0c21:         
0c21:         :out    
0c21:60           rts
0c22:         
0c22:         ;
0c22:         ; exec term
0c22:         eExec:
0c22:20 2c 0c     jsr eExecOne
0c25:b0 04        bcs :out
0c27:24 3b        bit eOp
0c29:30 f7        bmi eExec
0c2b:         :out
0c2b:60           rts
0c2c:         
0c2c:         eExecOne:
0c2c:20 e8 0d     jsr ePop
0c2f:a5 3b        lda eOp
0c31:f0 63        beq :assign
0c33:c9 2b        cmp #'+
0c35:f0 61        beq :add
0c37:c9 2d        cmp #'-
0c39:f0 6c        beq :sub
0c3b:c9 ad        cmp #$80+'- ; unary -
0c3d:f0 68        beq :sub
0c3f:c9 26        cmp #'&
0c41:f0 73        beq :and
0c43:c9 5e        cmp #'^
0c45:f0 2e        beq :xorb
0c47:c9 2e        cmp #'.
0c49:f0 79        beq :or
0c4b:c9 a1        cmp #$80+'! ; unary '!'
0c4d:f0 29        beq :notb
0c4f:c9 bc        cmp #$80+'< ; unary '<'
0c51:f0 28        beq :lob
0c53:c9 be        cmp #$80+'> ; unary '>'
0c55:f0 27        beq :hib
0c57:c9 3d        cmp #'=
0c59:f0 26        beq :eqb
0c5b:c9 3e        cmp #'>
0c5d:f0 25        beq :gtb
0c5f:c9 3c        cmp #'<
0c61:f0 24        beq :ltb
0c63:c9 7e        cmp #$40+'> ; >=
0c65:f0 23        beq :geb
0c67:c9 7c        cmp #$40+'< ; <=
0c69:f0 22        beq :leb
0c6b:c9 61        cmp #$40+'! ; !=
0c6d:f0 21        beq :neb
0c6f:c9 25        cmp #'%
0c71:f0 20        beq :alignb
0c73:38           sec
0c74:60           rts
0c75:         
0c75:         :xorb
0c75:4c d2 0c     jmp :xor
0c78:         
0c78:         :notb
0c78:4c e0 0c     jmp :not
0c7b:         
0c7b:         :lob
0c7b:4c f2 0c     jmp :lo
0c7e:         
0c7e:         :hib
0c7e:4c ee 0c     jmp :hi
0c81:         
0c81:         :eqb
0c81:4c f6 0c     jmp :eq
0c84:         
0c84:         :gtb
0c84:4c 04 0d     jmp :gt
0c87:         
0c87:         :ltb
0c87:4c 12 0d     jmp :lt
0c8a:         
0c8a:         :geb
0c8a:4c 20 0d     jmp :ge
0c8d:         
0c8d:         :leb
0c8d:4c 2e 0d     jmp :le
0c90:         
0c90:         :neb
0c90:4c 3c 0d     jmp :ne
0c93:         
0c93:         :alignb
0c93:4c 58 0d     jmp :align
0c96:         
0c96:         ;
0c96:         ; arg=arg
0c96:         :assign
0c96:18           clc
0c97:60           rts
0c98:         
0c98:         ;
0c98:         ; arg+=term
0c98:         :add
0c98:a5 35        lda arg
0c9a:18           clc
0c9b:65 37        adc term
0c9d:85 35        sta arg
0c9f:a5 36        lda arg+1
0ca1:65 38        adc term+1
0ca3:85 36        sta arg+1
0ca5:18           clc
0ca6:60           rts
0ca7:         
0ca7:         ;
0ca7:         ; arg=term-arg
0ca7:         :sub
0ca7:a5 37        lda term
0ca9:38           sec
0caa:e5 35        sbc arg
0cac:85 35        sta arg
0cae:a5 38        lda term+1
0cb0:e5 36        sbc arg+1
0cb2:85 36        sta arg+1
0cb4:18           clc
0cb5:60           rts
0cb6:         
0cb6:         ;
0cb6:         ; arg&=term
0cb6:         :and
0cb6:a5 35        lda arg
0cb8:25 37        and term
0cba:85 35        sta arg
0cbc:a5 36        lda arg+1
0cbe:25 38        and term+1
0cc0:85 36        sta arg+1
0cc2:18           clc
0cc3:60           rts
0cc4:         
0cc4:         ;
0cc4:         ; arg.=term
0cc4:         :or
0cc4:a5 35        lda arg
0cc6:05 37        ora term
0cc8:85 35        sta arg
0cca:a5 36        lda arg+1
0ccc:05 38        ora term+1
0cce:85 36        sta arg+1
0cd0:18           clc
0cd1:60           rts
0cd2:         
0cd2:         ;
0cd2:         ; arg^=term
0cd2:         :xor
0cd2:a5 35        lda arg
0cd4:45 37        eor term
0cd6:85 35        sta arg
0cd8:a5 36        lda arg+1
0cda:45 38        eor term+1
0cdc:85 36        sta arg+1
0cde:18           clc
0cdf:60           rts
0ce0:         
0ce0:         ;
0ce0:         ; arg=!arg
0ce0:         :not
0ce0:a5 35        lda arg
0ce2:49 ff        eor #$ff
0ce4:85 35        sta arg
0ce6:a5 36        lda arg+1
0ce8:49 ff        eor #$ff
0cea:85 36        sta arg+1
0cec:18           clc
0ced:60           rts
0cee:         
0cee:         ;
0cee:         ; arg=>arg
0cee:         :hi
0cee:a5 36        lda arg+1
0cf0:85 35        sta arg
0cf2:             ; fall thru
0cf2:         
0cf2:         ;
0cf2:         ; arg=<arg
0cf2:         :lo
0cf2:64 36        stz arg+1
0cf4:18           clc
0cf5:60           rts
0cf6:         
0cf6:         ;
0cf6:         ; arg=term?
0cf6:         :eq
0cf6:a5 35        lda arg
0cf8:c5 37        cmp term
0cfa:d0 56        bne :false
0cfc:a5 36        lda arg+1
0cfe:c5 38        cmp term+1
0d00:d0 50        bne :false
0d02:80 46        bra :true
0d04:         
0d04:         ;
0d04:         ; term>arg?
0d04:         :gt
0d04:a5 36        lda arg+1
0d06:c5 38        cmp term+1
0d08:90 40        bcc :true
0d0a:a5 35        lda arg
0d0c:c5 37        cmp term
0d0e:90 3a        bcc :true
0d10:80 40        bra :false
0d12:         
0d12:         ;
0d12:         ; term<arg?
0d12:         :lt
0d12:a5 38        lda term+1
0d14:c5 36        cmp arg+1
0d16:90 32        bcc :true
0d18:a5 37        lda term
0d1a:c5 35        cmp arg
0d1c:90 2c        bcc :true
0d1e:80 32        bra :false
0d20:         
0d20:         ;
0d20:         ; term>=arg?
0d20:         :ge
0d20:a5 38        lda term+1
0d22:c5 36        cmp arg+1
0d24:90 2c        bcc :false
0d26:a5 37        lda term
0d28:c5 35        cmp arg
0d2a:90 26        bcc :false
0d2c:80 1c        bra :true
0d2e:         
0d2e:         ; term<=arg?
0d2e:         :le
0d2e:a5 36        lda arg+1
0d30:c5 38        cmp term+1
0d32:90 1e        bcc :false
0d34:a5 35        lda arg
0d36:c5 37        cmp term
0d38:90 18        bcc :false
0d3a:80 0e        bra :true
0d3c:         
0d3c:         ; term!=arg?
0d3c:         :ne
0d3c:a5 36        lda arg+1
0d3e:c5 38        cmp term+1
0d40:d0 08        bne :true
0d42:a5 35        lda arg
0d44:c5 37        cmp term
0d46:d0 02        bne :true
0d48:80 08        bra :false
0d4a:         
0d4a:         :true
0d4a:a9 ff        lda #$ff
0d4c:85 35        sta arg
0d4e:85 36        sta arg+1
0d50:18           clc
0d51:60           rts
0d52:         
0d52:         :false
0d52:64 35        stz arg
0d54:64 36        stz arg+1
0d56:18           clc
0d57:60           rts
0d58:         
0d58:         ; arg=term%arg
0d58:         :align              ; limited to $100 max
0d58:c6 35        dec arg
0d5a:a5 35        lda arg
0d5c:25 37        and term
0d5e:45 35        eor arg
0d60:1a           inc
0d61:25 35        and arg
0d63:85 35        sta arg
0d65:64 36        stz arg+1
0d67:4c 98 0c     jmp :add
0d6a:         
0d6a:         ;
0d6a:         ; add decimal digit in lineBuf,x to arg
0d6a:         eDec:
0d6a:a5 35        lda arg         ; scratch=arg*8
0d6c:0a           asl
0d6d:85 22        sta scratch
0d6f:a5 36        lda arg+1
0d71:2a           rol
0d72:85 23        sta scratch+1
0d74:         
0d74:06 22        asl scratch
0d76:26 23        rol scratch+1
0d78:06 22        asl scratch
0d7a:26 23        rol scratch+1
0d7c:         
0d7c:06 35        asl arg         ; arg=arg*2
0d7e:26 36        rol arg+1
0d80:         
0d80:a5 35        lda arg         ; arg=arg+scratch
0d82:18           clc
0d83:65 22        adc scratch
0d85:85 35        sta arg
0d87:a5 36        lda arg+1
0d89:65 23        adc scratch+1
0d8b:85 36        sta arg+1
0d8d:         
0d8d:bd 00 20     lda lineBuf,x
0d90:38           sec
0d91:e9 30        sbc #'0
0d93:18           clc
0d94:65 35        adc arg
0d96:85 35        sta arg
0d98:90 02        bcc :out
0d9a:e6 36        inc arg+1
0d9c:         :out
0d9c:60           rts
0d9d:         
0d9d:         ;
0d9d:         ; add hex digit in lineBuf,x to arg
0d9d:         eHex:
0d9d:06 35        asl arg
0d9f:26 36        rol arg+1
0da1:06 35        asl arg
0da3:26 36        rol arg+1
0da5:06 35        asl arg
0da7:26 36        rol arg+1
0da9:06 35        asl arg
0dab:26 36        rol arg+1
0dad:         
0dad:bd 00 20     lda lineBuf,x
0db0:38           sec
0db1:e9 3a        sbc #'9+1
0db3:90 03        bcc :digit
0db5:e9 07        sbc #7
0db7:18           clc
0db8:         :digit
0db8:69 0a        adc #10
0dba:         
0dba:05 35        ora arg
0dbc:85 35        sta arg
0dbe:60           rts
0dbf:         
0dbf:         ;
0dbf:         ; add binary digit in lineBuf,x to arg
0dbf:         eBin:
0dbf:06 35        asl arg
0dc1:26 36        rol arg+1
0dc3:38           sec
0dc4:e9 30        sbc #'0
0dc6:05 35        ora arg
0dc8:85 35        sta arg
0dca:60           rts
0dcb:         
0dcb:         ;
0dcb:         ; push arg,op,state
0dcb:         ePush:
0dcb:a4 43        ldy ePtr
0dcd:         
0dcd:a5 3b        lda eOp
0dcf:99 00 1f     sta eStack,y
0dd2:88           dey
0dd3:         
0dd3:a5 36        lda arg+1
0dd5:99 00 1f     sta eStack,y
0dd8:88           dey
0dd9:         
0dd9:a5 35        lda arg
0ddb:99 00 1f     sta eStack,y
0dde:88           dey
0ddf:         
0ddf:84 43        sty ePtr
0de1:         
0de1:64 3b        stz eOp
0de3:64 35        stz arg
0de5:64 36        stz arg+1
0de7:60           rts
0de8:         
0de8:         ;
0de8:         ; pop term,op,state
0de8:         ePop:
0de8:a4 43        ldy ePtr
0dea:         
0dea:c8           iny
0deb:b9 00 1f     lda eStack,y
0dee:85 37        sta term
0df0:         
0df0:c8           iny
0df1:b9 00 1f     lda eStack,y
0df4:85 38        sta term+1
0df6:         
0df6:c8           iny
0df7:b9 00 1f     lda eStack,y
0dfa:85 3b        sta eOp
0dfc:         
0dfc:84 43        sty ePtr
0dfe:60           rts
0dff:         
0dff:         ;
0dff:         ; test if lineBuf,x is decimal digit
0dff:         ; C=1 if so
0dff:         eIsDec:
0dff:bd 00 20     lda lineBuf,x
0e02:c9 3a        cmp #'9+1
0e04:b0 03        bcs eIsNot
0e06:         
0e06:c9 30        cmp #'0
0e08:60           rts
0e09:         
0e09:         eIsNot:
0e09:18           clc
0e0a:60           rts
0e0b:         
0e0b:         ;
0e0b:         ; test if lineBuf,x is octal digit
0e0b:         ; C=1 if so, also returns char in A
0e0b:         eIsOct:
0e0b:bd 00 20     lda lineBuf,x
0e0e:c9 38        cmp #'7+1
0e10:b0 f7        bcs eIsNot
0e12:         
0e12:c9 30        cmp #'0
0e14:60           rts
0e15:         
0e15:         ;
0e15:         ; test if lineBuf,x is hex digit
0e15:         ; C=1 if so
0e15:         ; side effect: uppercase normalized
0e15:         eIsHex:
0e15:20 ff 0d     jsr eIsDec
0e18:b0 0b        bcs :out
0e1a:20 30 0b     jsr ePet
0e1d:29 7f        and #$7f
0e1f:         
0e1f:c9 47        cmp #'f+1
0e21:b0 e6        bcs eIsNot
0e23:         
0e23:c9 41        cmp #'a
0e25:         :out
0e25:60           rts
0e26:         
0e26:         ;
0e26:         ; test if lineBuf,x is binary digit
0e26:         ; Z=1 if so
0e26:         eIsBin:
0e26:bd 00 20     lda lineBuf,x
0e29:c9 31        cmp #'1
0e2b:f0 02        beq :out
0e2d:c9 30        cmp #'0
0e2f:         :out
0e2f:60           rts
0e30:         
0e30:         ;
0e30:         ; test if lineBuf,X is alpha
0e30:         ; C=1 if so
0e30:         eIsAlpha:
0e30:bd 00 20     lda lineBuf,x
0e33:20 30 0b     jsr ePet
0e36:         
0e36:c9 db        cmp #'z+128+1   ; 'Z'
0e38:b0 cf        bcs eIsNot      ; > 'Z'
0e3a:         
0e3a:c9 41        cmp #'a
0e3c:90 09        bcc :out        ; < 'a'
0e3e:         
0e3e:c9 c1        cmp #'a+128     ; 'A'
0e40:b0 05        bcs :out        ; >= 'A' and <= 'Z'
0e42:         
0e42:c9 5b        cmp #'z+1
0e44:b0 c3        bcs eIsNot      ; > 'z'
0e46:         
0e46:38           sec
0e47:         :out
0e47:60           rts
0e48:         
0e48:         ;
0e48:         ; test if lineBuf,x is a valid symbol character
0e48:         ; Z=1 if so
0e48:         eIsSym:
0e48:20 30 0e     jsr eIsAlpha
0e4b:b0 08        bcs :yes
0e4d:20 ff 0d     jsr eIsDec
0e50:b0 03        bcs :yes
0e52:c9 3a        cmp #':
0e54:60           rts
0e55:         :yes
0e55:89 00        bit #0          ; set zero
0e57:60           rts
0e58:         
0e58:         ;
0e58:         ; resolve label from lineBuf into arg
0e58:         eResolveSym:
0e58:a5 2d        lda symScope    ; note our current scope
0e5a:8d 16 22     sta tScope
0e5d:a5 2e        lda symScope+1
0e5f:8d 17 22     sta tScope+1
0e62:         
0e62:a4 3d        ldy labelPtr    ; start of label sequence
0e64:b9 00 20     lda lineBuf,y
0e67:c9 3a        cmp #':
0e69:f0 04        beq :loop
0e6b:         
0e6b:64 2d        stz symScope    ; global scope
0e6d:64 2e        stz symScope+1
0e6f:         
0e6f:         :loop
0e6f:20 a8 0e     jsr :next
0e72:a5 2f        lda symLength
0e74:f0 0d        beq :skip       ; empty label in sequence means do not adjust scope
0e76:         
0e76:5a           phy
0e77:20 f6 09     jsr symGet
0e7a:7a           ply
0e7b:         
0e7b:a5 27        lda ptr
0e7d:85 2d        sta symScope
0e7f:a5 28        lda ptr+1
0e81:85 2e        sta symScope+1
0e83:         
0e83:         :skip
0e83:c4 29        cpy labelEnd
0e85:d0 e8        bne :loop
0e87:         
0e87:         :done
0e87:18           clc
0e88:a0 04        ldy #4
0e8a:b1 27        lda (ptr),y     ; no forward reference in pass >0
0e8c:d0 05        bne :fine
0e8e:a5 40        lda pass
0e90:f0 01        beq :fine
0e92:38           sec             ; set error
0e93:         
0e93:         :fine
0e93:c8           iny             ; symbol value in arg
0e94:b1 27        lda (ptr),y
0e96:85 35        sta arg
0e98:c8           iny
0e99:b1 27        lda (ptr),y
0e9b:85 36        sta arg+1
0e9d:         
0e9d:ad 16 22     lda tScope      ; put scope back
0ea0:85 2d        sta symScope
0ea2:ad 17 22     lda tScope+1
0ea5:85 2e        sta symScope+1
0ea7:         
0ea7:60           rts
0ea8:         
0ea8:         :next
0ea8:98           tya             ; point symLabel at lineBuf+y
0ea9:18           clc
0eaa:69 00        adc #<lineBuf
0eac:85 31        sta symLabel
0eae:a9 00        lda #0
0eb0:69 20        adc #>lineBuf
0eb2:85 32        sta symLabel+1
0eb4:64 2f        stz symLength   ; reset length=0
0eb6:         
0eb6:         :search
0eb6:b9 00 20     lda lineBuf,y
0eb9:c8           iny
0eba:c9 3a        cmp #':
0ebc:f0 06        beq :out        ; colon terminate at scope seperator
0ebe:e6 2f        inc symLength
0ec0:c4 29        cpy labelEnd
0ec2:d0 f2        bne :search
0ec4:         :out
0ec4:60           rts
0ec5:         
0ec5:             .in 'line.asm'
0ec5:             .in 'zp.asm'
0ec5:             .fi ; zpAsm
0ec5:         
0ec5:             .in 'mode.asm'
0ec5:             .fi ; modeAsm
0ec5:         
0ec5:         
0ec5:         
0ec5:         ;
0ec5:         ; assembles lineBuf
0ec5:         lineAsm:
0ec5:ba           tsx
0ec6:8e 0e 22     stx lineSP
0ec9:64 35        stz arg
0ecb:64 36        stz arg+1
0ecd:a2 00        ldx #0
0ecf:         
0ecf:         :start
0ecf:bd 00 20     lda lineBuf,x
0ed2:20 30 0b     jsr ePet
0ed5:20 48 0e     jsr eIsSym
0ed8:d0 03        bne :label
0eda:e8           inx
0edb:d0 f2        bne :start
0edd:         :label
0edd:64 27        stz ptr         ; assume no label yet
0edf:64 28        stz ptr+1
0ee1:         
0ee1:86 29        stx labelEnd
0ee3:e0 00        cpx #0          ; no label
0ee5:f0 07        beq :post
0ee7:         
0ee7:24 44        bit lineIfs     ; test if we are if'd out
0ee9:30 03        bmi :post
0eeb:         
0eeb:20 c9 10     jsr linePinLabel
0eee:         
0eee:         :post
0eee:20 bb 12     jsr lineNextTokenExit
0ef1:         
0ef1:c9 3d        cmp #'=
0ef3:d0 1e        bne :op
0ef5:         
0ef5:24 44        bit lineIfs
0ef7:30 5f        bmi :opdone
0ef9:         
0ef9:e8           inx             ; skip '='
0efa:a5 27        lda ptr
0efc:85 39        sta assign      ; assign=ptr
0efe:a5 28        lda ptr+1
0f00:f0 23        beq :assignError
0f02:85 3a        sta assign+1
0f04:         
0f04:20 e5 12     jsr lineEval    ; eval rhs
0f07:         
0f07:a0 05        ldy #5          ; store evaluated result
0f09:a5 35        lda arg
0f0b:91 39        sta (assign),y
0f0d:c8           iny
0f0e:a5 36        lda arg+1
0f10:91 39        sta (assign),y
0f12:60           rts
0f13:         
0f13:         :op
0f13:bd 00 20     lda lineBuf,x
0f16:c9 2a        cmp #'*
0f18:f0 15        beq :star
0f1a:c9 2e        cmp #'.
0f1c:f0 3b        beq :dot
0f1e:         
0f1e:24 44        bit lineIfs
0f20:30 36        bmi :opdone     ; if'd out
0f22:         
0f22:4c 2f 11     jmp lineIsn
0f25:         
0f25:         :assignError
0f25:a9 0a        lda #errors:assign
0f27:85 46        sta error
0f29:60           rts
0f2a:         
0f2a:         :backwardError
0f2a:a9 06        lda #errors:backward
0f2c:85 46        sta error
0f2e:60           rts
0f2f:         
0f2f:         :star
0f2f:e8           inx             ; skip '*'
0f30:20 bb 12     jsr lineNextTokenExit
0f33:c9 3d        cmp #'=
0f35:d0 21        bne :opdone
0f37:e8           inx             ; consume '='
0f38:e6 40        inc pass        ; cannot be forward reference
0f3a:20 e5 12     jsr lineEval
0f3d:c6 40        dec pass
0f3f:         
0f3f:         :starloop
0f3f:a5 36        lda arg+1
0f41:cd 12 22     cmp pc+1
0f44:90 e4        bcc :backwardError
0f46:d0 09        bne :stardo
0f48:a5 35        lda arg
0f4a:cd 11 22     cmp pc
0f4d:90 db        bcc :backwardError
0f4f:f0 07        beq :stardone
0f51:         :stardo
0f51:a9 00        lda #0
0f53:20 19 11     jsr lineEmit    ; emit zeros until desired pc
0f56:80 e7        bra :starloop
0f58:         
0f58:         :stardone
0f58:         :opdone
0f58:60           rts
0f59:         
0f59:         :dot
0f59:e8           inx             ; skip '.'
0f5a:bd 01 20     lda lineBuf+1,x
0f5d:a8           tay             ; second char in Y
0f5e:bd 00 20     lda lineBuf,x   ; first char in A
0f61:e8           inx
0f62:e8           inx             ; skip the two (if not present, we will err anyway)
0f63:         
0f63:c9 45        cmp #'e
0f65:f0 19        beq :E
0f67:c9 46        cmp #'f
0f69:f0 1f        beq :F
0f6b:c9 49        cmp #'i
0f6d:f0 27        beq :I
0f6f:         
0f6f:24 44        bit lineIfs
0f71:30 e5        bmi :opdone     ; if'd out
0f73:         
0f73:c9 4f        cmp #'o
0f75:f0 19        beq :O
0f77:c9 44        cmp #'d
0f79:f0 2d        beq :D
0f7b:             ; fall thru
0f7b:         
0f7b:         :dotOpError
0f7b:a9 0c        lda #errors:dotOp
0f7d:85 46        sta error
0f7f:60           rts
0f80:         
0f80:         :E
0f80:c0 49        cpy #'i
0f82:f0 5b        beq :EI
0f84:c0 4c        cpy #'l
0f86:f0 43        beq :EL
0f88:80 f1        bra :dotOpError
0f8a:         
0f8a:         :F
0f8a:c0 49        cpy #'i
0f8c:f0 73        beq :FI
0f8e:80 eb        bra :dotOpError
0f90:         
0f90:         :O
0f90:c0 52        cpy #'r
0f92:f0 22        beq :ORb
0f94:80 e5        bra :dotOpError
0f96:         
0f96:         :I
0f96:c0 46        cpy #'f
0f98:f0 1f        beq :IFb
0f9a:             
0f9a:24 44        bit lineIfs
0f9c:30 ba        bmi :opdone     ; if'd out
0f9e:             
0f9e:c0 4e        cpy #'n
0fa0:f0 1a        beq :INb
0fa2:c0 42        cpy #'b
0fa4:f0 19        beq :IBb
0fa6:80 d3        bra :dotOpError
0fa8:           
0fa8:         :D
0fa8:c0 42        cpy #'b
0faa:f0 16        beq :DBb
0fac:c0 57        cpy #'w
0fae:f0 15        beq :DWb
0fb0:c0 46        cpy #'f
0fb2:f0 14        beq :DFb
0fb4:80 c5        bra :dotOpError
0fb6:         
0fb6:         :ORb
0fb6:4c 89 10     jmp :OR
0fb9:         
0fb9:         :IFb
0fb9:4c a4 10     jmp :IF
0fbc:         
0fbc:         :INb
0fbc:4c 9a 10     jmp :IN
0fbf:             
0fbf:         :IBb
0fbf:4c a0 10     jmp :IB
0fc2:             
0fc2:         :DBb
0fc2:4c 08 10     jmp :DB
0fc5:             
0fc5:         :DWb
0fc5:4c 32 10     jmp :DW
0fc8:         
0fc8:         :DFb
0fc8:4c 4b 10     jmp :DF
0fcb:         
0fcb:         :EL
0fcb:24 45        bit lineIfd     ; have we chosen our destiny
0fcd:10 07        bpl :else
0fcf:a9 80        lda #$80        ; prior destiny has already been set
0fd1:04 44        tsb lineIfs
0fd3:4c cd 12     jmp lineAssertEnd
0fd6:         
0fd6:         :else
0fd6:a5 44        lda lineIfs     ; flip top if bit
0fd8:49 80        eor #$80
0fda:85 44        sta lineIfs
0fdc:4c cd 12     jmp lineAssertEnd
0fdf:         
0fdf:         :EI
0fdf:20 d9 12     jsr lineAssertToken
0fe2:         
0fe2:24 45        bit lineIfd     ; have we chosen our destiny
0fe4:10 05        bpl :elseif
0fe6:a9 80        lda #$80        ; stay false
0fe8:04 44        tsb lineIfs     ; prior destiny has already been set
0fea:60           rts
0feb:         
0feb:         :elseif
0feb:20 e5 12     jsr lineEval
0fee:20 0c 11     jsr lineTruth
0ff1:06 44        asl lineIfs
0ff3:a5 36        lda arg+1       ; top of ifs stack becomes condition
0ff5:29 80        and #$80
0ff7:04 45        tsb lineIfd     ; destiny set
0ff9:49 80        eor #$80
0ffb:0a           asl
0ffc:66 44        ror lineIfs
0ffe:4c cd 12     jmp lineAssertEnd
1001:         
1001:         :FI
1001:06 44        asl lineIfs     ; pop if stack
1003:06 45        asl lineIfd     ; pop destiny stack
1005:4c cd 12     jmp lineAssertEnd
1008:         
1008:         :DB
1008:64 35        stz arg
100a:20 bb 12     jsr lineNextTokenExit
100d:c9 27        cmp #''
100f:f0 11        beq :string
1011:c9 2c        cmp #',
1013:f0 0a        beq :DBcomma
1015:         
1015:20 e5 12     jsr lineEval
1018:a5 35        lda arg         ; send it
101a:20 19 11     jsr lineEmit
101d:         
101d:80 e9        bra :DB
101f:         
101f:         :DBcomma
101f:e8           inx             ; consume ',' ready for next
1020:80 e6        bra :DB
1022:         
1022:         :string
1022:e8           inx
1023:bd 00 20     lda lineBuf,x
1026:f0 09        beq :stringEOF
1028:c9 27        cmp #''
102a:f0 f3        beq :DBcomma
102c:         
102c:20 19 11     jsr lineEmit    ; send it
102f:80 f1        bra :string
1031:         :stringEOF
1031:60           rts
1032:         
1032:         :DW
1032:20 bb 12     jsr lineNextTokenExit
1035:c9 2c        cmp #',
1037:f0 0f        beq :DWcomma
1039:         
1039:20 e5 12     jsr lineEval
103c:         
103c:a5 35        lda arg         ; send it
103e:20 19 11     jsr lineEmit
1041:a5 36        lda arg+1
1043:20 19 11     jsr lineEmit
1046:         
1046:80 ea        bra :DW
1048:         
1048:         :DWcomma
1048:e8           inx             ; consume ',' ready for next word
1049:80 e7        bra :DW
104b:         
104b:         :DF
104b:20 bb 12     jsr lineNextTokenExit
104e:         
104e:86 2a        stx emitX
1050:         :DFscan
1050:20 9e 12     jsr lineEnd
1053:f0 07        beq :DFscanned
1055:c9 2c        cmp #',
1057:f0 03        beq :DFscanned
1059:e8           inx
105a:d0 f4        bne :DFscan
105c:         
105c:         :DFscanned
105c:86 22        stx scratch
105e:8a           txa
105f:38           sec
1060:e5 2a        sbc emitX       ; A: length
1062:a6 2a        ldx emitX       ; X/Y: string
1064:a0 20        ldy #>lineBuf
1066:20 09 fe     jsr VAL1
1069:a2 00        ldx #<fpack
106b:a0 22        ldy #>fpack
106d:20 66 fe     jsr MOVMF       ; pack FACC->constant
1070:         
1070:a6 22        ldx scratch     ; get X back
1072:a0 00        ldy #0
1074:         
1074:         :DFemit
1074:b9 00 22     lda fpack,y     ; write 5 byte packed output
1077:20 19 11     jsr lineEmit
107a:c8           iny
107b:c0 05        cpy #5
107d:d0 f5        bne :DFemit
107f:         
107f:         :DFnext
107f:bd 00 20     lda lineBuf,x
1082:c9 2c        cmp #',
1084:d0 c5        bne :DF
1086:e8           inx             ; consume ,
1087:80 c2        bra :DF
1089:         
1089:         :OR
1089:20 d9 12     jsr lineAssertToken
108c:         
108c:20 e5 12     jsr lineEval
108f:         
108f:a5 35        lda arg
1091:8d 11 22     sta pc
1094:a5 36        lda arg+1
1096:8d 12 22     sta pc+1
1099:60           rts
109a:         
109a:         :IN
109a:20 79 12     jsr lineGetName
109d:4c 14 14     jmp ioPush
10a0:         
10a0:         :IB
10a0:20 79 12     jsr lineGetName
10a3:60           rts             ; XXX write binary file
10a4:         
10a4:         :IF
10a4:20 d9 12     jsr lineAssertToken
10a7:         
10a7:24 44        bit lineIfs
10a9:30 17        bmi :falseIf
10ab:         
10ab:20 e5 12     jsr lineEval
10ae:20 0c 11     jsr lineTruth
10b1:a5 36        lda arg+1
10b3:29 80        and #$80
10b5:0a           asl
10b6:66 45        ror lineIfd     ; desinty set
10b8:a5 36        lda arg+1
10ba:49 80        eor #$80
10bc:0a           asl             ; truth->C
10bd:66 44        ror lineIfs     ; push if stack
10bf:4c cd 12     jmp lineAssertEnd
10c2:         
10c2:         :falseIf
10c2:38           sec
10c3:66 44        ror lineIfs     ; stay in false state
10c5:38           sec
10c6:66 45        ror lineIfd     ; and this is our destiny at this level
10c8:60           rts
10c9:         
10c9:         ;
10c9:         ; resolve label field into ptr, adjusting symScope if necessary
10c9:         linePinLabel:
10c9:64 3d        stz labelPtr
10cb:20 58 0e     jsr eResolveSym
10ce:ad 00 20     lda lineBuf
10d1:c9 3a        cmp #58         ; ':'
10d3:f0 08        beq :local
10d5:a5 27        lda ptr
10d7:85 2d        sta symScope    ; this becomes our new scope
10d9:a5 28        lda ptr+1
10db:85 2e        sta symScope+1
10dd:         :local
10dd:a5 40        lda pass
10df:d0 1a        bne :out        ; if pass >0, just return it
10e1:24 44        bit lineIfs
10e3:30 16        bmi :out        ; if'd out, just return it
10e5:a0 04        ldy #4
10e7:b1 27        lda (ptr),y
10e9:d0 13        bne :dupLabel
10eb:a9 01        lda #1
10ed:91 27        sta (ptr),y
10ef:c8           iny
10f0:ad 11 22     lda pc
10f3:91 27        sta (ptr),y     ; initially store pc
10f5:c8           iny
10f6:ad 12 22     lda pc+1
10f9:91 27        sta (ptr),y     ; may be set later with =expr
10fb:         :out
10fb:a6 29        ldx labelEnd    ; restore x
10fd:60           rts
10fe:         
10fe:         :dupLabel
10fe:a9 02        lda #errors:dupLabel
1100:85 46        sta error
1102:4c c0 12     jmp lineExit
1105:         
1105:         lineEmitError:
1105:a9 18        lda #errors:emit
1107:85 46        sta error
1109:4c c0 12     jmp lineExit
110c:         
110c:         ;
110c:         ; normalize non-0 to $8xxx for if checking
110c:         lineTruth:
110c:a9 ff        lda #$ff
110e:24 35        bit arg
1110:d0 04        bne :true
1112:24 36        bit arg+1
1114:f0 02        beq :false
1116:         :true
1116:85 36        sta arg+1
1118:         :false
1118:60           rts
1119:         
1119:         ;
1119:         ; emit byte
1119:         ; pc incremented, (emit) called
1119:         lineEmit:
1119:ee 11 22     inc pc          ; pc++
111c:d0 03        bne :lo
111e:ee 12 22     inc pc+1
1121:         :lo
1121:20 27 11     jsr :doEmit
1124:b0 df        bcs lineEmitError
1126:60           rts
1127:         
1127:         :doEmit
1127:6c 05 22     jmp (emit)
112a:         
112a:         lineOpError:
112a:a9 0e        lda #errors:op
112c:85 46        sta error
112e:60           rts
112f:         
112f:         ;
112f:         ; isn (arg) part
112f:         lineIsn:
112f:20 cb 17     jsr isnGet
1132:b0 f6        bcs lineOpError
1134:a9 07        lda #modeImp
1136:85 34        sta isnMode     ; assume implied
1138:64 2c        stz isnBit      ; start not assuming bit instruction
113a:e8           inx             ; skip isn
113b:e8           inx
113c:e8           inx
113d:20 0b 0e     jsr eIsOct      ; test for bit number
1140:90 03        bcc :notbitn
1142:85 2c        sta isnBit      ; '0'-'7' if this is a bitn
1144:e8           inx
1145:         
1145:         :notbitn
1145:20 a6 12     jsr lineNextToken
1148:f0 47        beq :gob        ; implied
114a:c9 23        cmp #'#
114c:f0 46        beq :imm
114e:c9 28        cmp #'(
1150:f0 4c        beq :ind
1152:         
1152:20 e5 12     jsr lineEval
1155:         
1155:a9 00        lda #modeAbs    ; abs (so far)
1157:85 34        sta isnMode
1159:         
1159:bd 00 20     lda lineBuf,x
115c:c9 2c        cmp #',
115e:d0 31        bne :gob
1160:e8           inx             ; consume ,
1161:bd 00 20     lda lineBuf,x
1164:20 30 0b     jsr ePet
1167:29 7f        and #$7f        ; normalize case
1169:c9 58        cmp #'x
116b:f0 18        beq :absx
116d:c9 59        cmp #'y
116f:f0 1b        beq :absy
1171:         
1171:a5 35        lda arg
1173:8d 0f 22     sta argZ        ; zp,rel
1176:20 e5 12     jsr lineEval
1179:         
1179:a9 09        lda #modeBitRel
117b:85 34        sta isnMode
117d:4c e9 11     jmp :go
1180:         
1180:         :modeError:
1180:a9 10        lda #errors:mode
1182:85 46        sta error
1184:60           rts
1185:         
1185:         :absx
1185:e8           inx             ; consume 'x'
1186:a9 02        lda #modeAbsX   ; abs,x
1188:85 34        sta isnMode
118a:80 05        bra :gob
118c:         
118c:         :absy
118c:e8           inx             ; consume 'y'
118d:a9 03        lda #modeAbsY   ; abs,y
118f:85 34        sta isnMode
1191:             ; fall thru
1191:         
1191:         :gob
1191:4c e9 11     jmp :go
1194:         
1194:         :imm
1194:e8           inx             ; skip #
1195:20 e5 12     jsr lineEval
1198:         
1198:a9 06        lda #modeImm    ; imm
119a:85 34        sta isnMode
119c:80 4b        bra :go
119e:         
119e:         :ind
119e:e8           inx             ; skip (
119f:20 e5 12     jsr lineEval
11a2:             
11a2:a9 04        lda #modeAbsInd ; indirect
11a4:85 34        sta isnMode
11a6:             
11a6:bd 00 20     lda lineBuf,x
11a9:c9 2c        cmp #',
11ab:f0 06        beq :indx
11ad:c9 29        cmp #')
11af:f0 1e        beq :indy
11b1:             
11b1:80 cd        bra :modeError
11b3:             
11b3:         :indx
11b3:e8           inx             ; skip ,
11b4:bd 00 20     lda lineBuf,x
11b7:20 30 0b     jsr ePet
11ba:29 7f        and #$7f
11bc:c9 58        cmp #'x
11be:d0 c0        bne :modeError
11c0:e8           inx
11c1:bd 00 20     lda lineBuf,x
11c4:c9 29        cmp #')
11c6:d0 b8        bne :modeError
11c8:e8           inx
11c9:         
11c9:a9 01        lda #modeAbsIndX ; (ind,x)
11cb:85 34        sta isnMode
11cd:80 1a        bra :go
11cf:         
11cf:         :indy
11cf:e8           inx             ; skip )
11d0:bd 00 20     lda lineBuf,x
11d3:c9 2c        cmp #',
11d5:d0 12        bne :go         ; presume (ind)
11d7:e8           inx
11d8:bd 00 20     lda lineBuf,x
11db:20 30 0b     jsr ePet
11de:29 7f        and #$7f
11e0:c9 59        cmp #'y
11e2:d0 9c        bne :modeError
11e4:e8           inx
11e5:         
11e5:a9 0f        lda #modeZeroIndY
11e7:85 34        sta isnMode     ; (ind),y
11e9:             ; fall thru
11e9:         
11e9:             ; resolved address mode
11e9:         :go
11e9:20 cd 12     jsr lineAssertEnd
11ec:a5 2c        lda isnBit      ; check for bitn
11ee:f0 13        beq :notbit
11f0:38           sec
11f1:e9 30        sbc #'0
11f3:0a           asl
11f4:0a           asl
11f5:0a           asl
11f6:0a           asl
11f7:85 2c        sta isnBit
11f9:a5 34        lda isnMode
11fb:c9 00        cmp #modeAbs
11fd:d0 04        bne :notbit
11ff:a9 05        lda #modeBitZero
1201:85 34        sta isnMode
1203:         
1203:         :notbit
1203:a5 33        lda isnOp
1205:c9 54        cmp #$54        ; BRK is special
1207:f0 49        beq :brk
1209:         
1209:20 20 18     jsr opResolve   ; opcode in a
120c:b0 4f        bcs :modeErrorb
120e:         
120e:65 2c        adc isnBit      ; if bitn, adjust
1210:20 19 11     jsr lineEmit    ; opcode
1213:         
1213:a5 34        lda isnMode
1215:c9 08        cmp #modeRel
1217:f0 0a        beq :rel
1219:c9 09        cmp #modeBitRel
121b:d0 43        bne :notrel
121d:         
121d:ad 0f 22     lda argZ
1220:20 19 11     jsr lineEmit    ; zp arg of bitRel
1223:         
1223:         :rel
1223:a5 40        lda pass
1225:f0 28        beq :pass0      ; no check in first pass    
1227:         
1227:ad 11 22     lda pc          ; relative
122a:18           clc
122b:69 01        adc #1          ; scratch=pc+1
122d:85 22        sta scratch
122f:ad 12 22     lda pc+1
1232:69 00        adc #0
1234:85 23        sta scratch+1
1236:         
1236:a5 35        lda arg         ; arg-=scratch
1238:38           sec
1239:e5 22        sbc scratch
123b:85 35        sta arg
123d:a5 36        lda arg+1
123f:e5 23        sbc scratch+1
1241:85 36        sta arg+1
1243:         
1243:a2 ff        ldx #$ff
1245:a5 35        lda arg         ; test for valid range
1247:30 02        bmi :checkBack
1249:a2 00        ldx #$00
124b:         :checkBack
124b:e4 36        cpx arg+1
124d:d0 25        bne :relError
124f:         
124f:         :pass0
124f:4c 19 11     jmp lineEmit    ; send it
1252:         
1252:         :brk
1252:a5 34        lda isnMode
1254:c9 07        cmp #modeImp
1256:d0 05        bne :modeErrorb
1258:a9 00        lda #0
125a:4c 19 11     jmp lineEmit    ; emit the single $00
125d:         
125d:         :modeErrorb
125d:4c 80 11     jmp :modeError
1260:         
1260:         :notrel
1260:c9 07        cmp #modeImp
1262:f0 14        beq :done
1264:         
1264:a5 35        lda arg         ; low byte or zp
1266:20 19 11     jsr lineEmit
1269:         
1269:a5 34        lda isnMode
126b:c9 05        cmp #5
126d:b0 09        bcs :done
126f:         
126f:a5 36        lda arg+1       ; high byte
1271:4c 19 11     jmp lineEmit
1274:         
1274:         :relError
1274:a9 12        lda #errors:rel
1276:85 46        sta error
1278:         :done
1278:60           rts
1279:         
1279:         ;
1279:         ; expect 'quoted string' and return in a/x/y
1279:         lineGetName:
1279:20 d9 12     jsr lineAssertToken
127c:e8           inx
127d:c9 27        cmp #''
127f:d0 17        bne lineErrorDotArg
1281:86 22        stx scratch
1283:a0 00        ldy #0
1285:         :count
1285:20 c5 12     jsr lineEndExit
1288:c9 27        cmp #''
128a:f0 04        beq :got
128c:c8           iny
128d:e8           inx
128e:d0 f5        bne :count
1290:         :got
1290:98           tya             ; length -> A
1291:a6 22        ldx scratch
1293:a0 20        ldy #>lineBuf
1295:4c 9f 13     jmp ioCopySourceName
1298:         
1298:         lineErrorDotArg:
1298:a9 1a        lda #errors:dotArg
129a:85 46        sta error
129c:80 22        bra lineExit
129e:         
129e:         ;
129e:         ; Z=1 if at end
129e:         lineEnd:
129e:bd 00 20     lda lineBuf,x
12a1:f0 02        beq :out        ; eof
12a3:c9 3b        cmp #';
12a5:         :out
12a5:60           rts
12a6:         
12a6:         ;
12a6:         ; Z=1 if at end (; or eof)
12a6:         lineNextToken:
12a6:20 9e 12     jsr lineEnd
12a9:f0 0c        beq :out
12ab:c9 21        cmp #33
12ad:90 09        bcc :white
12af:c9 a0        cmp #160
12b1:f0 05        beq :white
12b3:c9 e0        cmp #224
12b5:f0 01        beq :white
12b7:         :out
12b7:60           rts
12b8:         :white
12b8:e8           inx
12b9:80 eb        bra lineNextToken
12bb:         
12bb:         ;
12bb:         ; lineNextToken with a fast exit at end
12bb:         lineNextTokenExit:
12bb:20 a6 12     jsr lineNextToken
12be:d0 04        bne lineExit:out
12c0:         lineExit:
12c0:ae 0e 22     ldx lineSP      ; rewind stack for fast exit
12c3:9a           txs
12c4:         :out
12c4:60           rts
12c5:         
12c5:         ;
12c5:         ; lineEnd with fast exit
12c5:         lineEndExit:
12c5:20 9e 12     jsr lineEnd
12c8:d0 02        bne :out
12ca:80 f4        bra lineExit
12cc:         :out
12cc:60           rts
12cd:         
12cd:         ;
12cd:         ; lineNextToken with an error and fast exit if not at end
12cd:         lineAssertEnd:
12cd:20 a6 12     jsr lineNextToken
12d0:f0 06        beq :out
12d2:a9 14        lda #errors:parse
12d4:85 46        sta error
12d6:80 e8        bra lineExit
12d8:         :out
12d8:60           rts
12d9:         
12d9:         ;
12d9:         ; lineNextToken with an error and fast exit if at end
12d9:         lineAssertToken:
12d9:20 a6 12     jsr lineNextToken
12dc:d0 06        bne :out
12de:a9 16        lda #errors:noArg
12e0:85 46        sta error
12e2:80 dc        bra lineExit
12e4:         :out
12e4:60           rts
12e5:         
12e5:         ;
12e5:         ; call eEval and fast exit on error
12e5:         lineEval
12e5:20 43 0b     jsr eEval
12e8:90 06        bcc :out
12ea:a9 08        lda #errors:eval
12ec:85 46        sta error
12ee:80 d0        bra lineExit
12f0:         :out
12f0:60           rts
12f1:         
12f1:             .in 'io.asm'
12f1:             .in 'zp.asm'
12f1:             .fi ; zpAsm
12f1:         
12f1:             .in 'kernal.asm'
12f1:             .fi ; kernalAsm
12f1:         
12f1:         
12f1:         ;
12f1:         ; initialize
12f1:         ioInit:
12f1:20 e7 ff     jsr CLALL
12f4:9c 0b 22     stz ioLFN
12f7:64 49        stz ioNameL
12f9:9c 0c 22     stz ioStatus
12fc:64 46        stz error
12fe:9c 08 22     stz ioLine
1301:9c 09 22     stz ioLine+1
1304:64 50        stz ioOutPtr
1306:9c 0a 22     stz ioFDS
1309:a9 ff        lda #$ff
130b:85 3f        sta ioPtr
130d:a9 08        lda #8          ; default to device 8
130f:8d 07 22     sta ioDev
1312:a9 1c        lda #<:null
1314:8d 05 22     sta emit
1317:a9 13        lda #>:null
1319:8d 06 22     sta emit+1
131c:         :null
131c:18           clc
131d:60           rts
131e:         
131e:         ;
131e:         ; close all files and display error
131e:         ioError:
131e:20 f2 15     jsr ioCloseAll
1321:a9 0d        lda #13         ; cr
1323:20 d2 ff     jsr CHROUT
1326:a0 00        ldy #0
1328:         :print
1328:c4 49        cpy ioNameL
132a:f0 08        beq :printed
132c:b1 47        lda (ioName),y  ; print "filename:"
132e:20 d2 ff     jsr CHROUT
1331:c8           iny
1332:d0 f4        bne :print
1334:         :printed
1334:a9 3a        lda #':
1336:20 d2 ff     jsr CHROUT
1339:ad 09 22     lda ioLine+1
133c:20 80 16     jsr ioPrintHex
133f:ad 08 22     lda ioLine
1342:20 80 16     jsr ioPrintHex
1345:a9 20        lda #32
1347:20 d2 ff     jsr CHROUT
134a:20 c1 16     jsr ioPrintErr
134d:a2 5f        ldx #<:status
134f:a0 13        ldy #>:status
1351:20 b0 16     jsr ioPrint
1354:ad 0c 22     lda ioStatus
1357:20 80 16     jsr ioPrintHex
135a:a9 0a        lda #10         ; cr
135c:4c d2 ff     jmp CHROUT
135f:         
135f:         :status
135f:2c 53 54 41 54 55 53 3d 
1367:24 00        .db ',status=$',0
1369:         
1369:         ;
1369:         ; make a copy of a/x/y with ,p,w appended
1369:         ; result in a/x/y
1369:         ioCopyDestName:
1369:20 bd 13     jsr ioCopyName
136c:a9 2c        lda #',
136e:91 27        sta (ptr),y
1370:c8           iny
1371:a9 50        lda #'p
1373:91 27        sta (ptr),y
1375:c8           iny
1376:a9 2c        lda #',
1378:91 27        sta (ptr),y
137a:c8           iny
137b:a9 57        lda #'w
137d:91 27        sta (ptr),y
137f:c8           iny
1380:         
1380:98           tya
1381:a4 28        ldy ptr+1
1383:60           rts
1384:         
1384:         ;
1384:         ; make a copy of a/x/y with ,s,w appended
1384:         ioCopyListName:
1384:20 bd 13     jsr ioCopyName
1387:a9 2c        lda #',
1389:91 27        sta (ptr),y
138b:c8           iny
138c:a9 53        lda #'s
138e:91 27        sta (ptr),y
1390:c8           iny
1391:a9 2c        lda #',
1393:91 27        sta (ptr),y
1395:c8           iny
1396:a9 57        lda #'w
1398:91 27        sta (ptr),y
139a:c8           iny
139b:         
139b:98           tya
139c:a4 28        ldy ptr+1
139e:60           rts
139f:         
139f:         ;
139f:         ; make a copy of a/x/y with ,s,r appended
139f:         ; result in a/(ptr)
139f:         ioCopySourceName:
139f:20 da 13     jsr ioStringOut
13a2:20 bd 13     jsr ioCopyName
13a5:a9 2c        lda #',
13a7:91 27        sta (ptr),y
13a9:c8           iny
13aa:a9 53        lda #'s
13ac:91 27        sta (ptr),y
13ae:c8           iny
13af:a9 2c        lda #',
13b1:91 27        sta (ptr),y
13b3:c8           iny
13b4:a9 52        lda #'r
13b6:91 27        sta (ptr),y
13b8:c8           iny
13b9:         
13b9:98           tya
13ba:a4 28        ldy ptr+1
13bc:60           rts    
13bd:         
13bd:         ioCopyName:
13bd:86 23        stx string
13bf:84 24        sty string+1
13c1:a8           tay
13c2:18           clc
13c3:69 04        adc #4
13c5:20 e7 0a     jsr symPush
13c8:84 22        sty scratch
13ca:a0 00        ldy #0
13cc:         :loop
13cc:c4 22        cpy scratch
13ce:f0 07        beq :done
13d0:b1 23        lda (string),y
13d2:91 27        sta (ptr),y
13d4:c8           iny
13d5:d0 f5        bne :loop
13d7:         :done
13d7:a6 27        ldx ptr
13d9:60           rts
13da:         
13da:         ;
13da:         ; print string a/x/y with CR
13da:         ; all preserved
13da:         ioStringOut:
13da:85 22        sta scratch
13dc:86 23        stx string
13de:84 24        sty string+1
13e0:a0 00        ldy #0
13e2:         :loop
13e2:c4 22        cpy scratch
13e4:f0 08        beq :done
13e6:b1 23        lda (string),y
13e8:20 d2 ff     jsr CHROUT
13eb:c8           iny
13ec:d0 f4        bne :loop
13ee:         :done
13ee:a9 0d        lda #13
13f0:20 d2 ff     jsr CHROUT
13f3:a5 22        lda scratch
13f5:a6 23        ldx string
13f7:a4 24        ldy string+1
13f9:60           rts
13fa:         
13fa:         ;
13fa:         ; open output file named in a/x/y with LFN 2
13fa:         ioOpenDest:
13fa:20 bd ff     jsr SETNAM
13fd:a9 02        lda #2
13ff:ae 07 22     ldx ioDev
1402:a0 02        ldy #2
1404:20 ba ff     jsr SETLFS
1407:20 c0 ff     jsr OPEN
140a:90 07        bcc :opened
140c:8d 0c 22     sta ioStatus
140f:a9 1c        lda #errors:io
1411:85 46        sta error
1413:         :opened
1413:60           rts
1414:         
1414:         ;
1414:         ; push input file a/x/y
1414:         ioPush:
1414:85 22        sta scratch
1416:86 27        stx ptr
1418:84 28        sty ptr+1
141a:20 cc ff     jsr CLRCHN
141d:         
141d:a4 3f        ldy ioPtr       ; push current state
141f:         
141f:ad 0b 22     lda ioLFN       ; push current LFN (zero is done)
1422:99 00 1e     sta ioStack,y
1425:88           dey
1426:         
1426:ad 07 22     lda ioDev       ; device
1429:99 00 1e     sta ioStack,y
142c:88           dey
142d:         
142d:ad 0c 22     lda ioStatus    ; status
1430:99 00 1e     sta ioStack,y
1433:88           dey
1434:         
1434:a5 48        lda ioName+1    ; filename
1436:99 00 1e     sta ioStack,y
1439:88           dey
143a:a5 47        lda ioName
143c:99 00 1e     sta ioStack,y
143f:88           dey
1440:         
1440:a5 49        lda ioNameL     ; filename length
1442:99 00 1e     sta ioStack,y
1445:88           dey
1446:         
1446:ad 09 22     lda ioLine+1    ; line
1449:99 00 1e     sta ioStack,y
144c:88           dey
144d:ad 08 22     lda ioLine
1450:99 00 1e     sta ioStack,y
1453:88           dey
1454:         
1454:84 3f        sty ioPtr       ; current state all pushed
1456:         
1456:             ; TODO: parse for @device:
1456:         
1456:a5 22        lda scratch     ; scratch/ptr -> nameL/name
1458:85 49        sta ioNameL
145a:a6 27        ldx ptr
145c:86 47        stx ioName
145e:a4 28        ldy ptr+1
1460:84 48        sty ioName+1
1462:20 bd ff     jsr SETNAM      ; filename
1465:         
1465:20 eb 14     jsr ioAlloc     ; device secondary in Y
1468:b0 2b        bcs :toomany
146a:c8           iny
146b:c8           iny
146c:c8           iny             ; ..and add 3 to it (we use 2 for the output)
146d:ae 07 22     ldx ioDev
1470:98           tya             ; use LFN=device secondary
1471:8d 0b 22     sta ioLFN
1474:20 ba ff     jsr SETLFS
1477:         
1477:20 c0 ff     jsr OPEN        ; open the file
147a:b0 11        bcs :error
147c:ae 0b 22     ldx ioLFN
147f:20 c6 ff     jsr CHKIN
1482:b0 09        bcs :error      ; now current file for reading
1484:9c 08 22     stz ioLine
1487:9c 09 22     stz ioLine+1
148a:4c 58 15     jmp ioReadStatus
148d:         
148d:         :error
148d:8d 0c 22     sta ioStatus
1490:a9 1c        lda #errors:io
1492:85 46        sta error
1494:60           rts
1495:         
1495:         :toomany
1495:a9 1e        lda #errors:tooMany
1497:85 46        sta error
1499:60           rts
149a:         
149a:         ;
149a:         ; pop current file state
149a:         ioPop:
149a:20 cc ff     jsr CLRCHN      ; disconnect existing
149d:ad 0b 22     lda ioLFN
14a0:20 c3 ff     jsr CLOSE       ; close current logical file
14a3:ac 0b 22     ldy ioLFN
14a6:88           dey
14a7:88           dey
14a8:88           dey
14a9:20 00 15     jsr ioDealloc   ; deallocate device secondary
14ac:         
14ac:a4 3f        ldy ioPtr
14ae:         
14ae:c8           iny             ; line number
14af:b9 00 1e     lda ioStack,y
14b2:8d 08 22     sta ioLine
14b5:c8           iny
14b6:b9 00 1e     lda ioStack,y
14b9:8d 09 22     sta ioLine+1
14bc:         
14bc:c8           iny             ; filename length
14bd:b9 00 1e     lda ioStack,y
14c0:85 49        sta ioNameL
14c2:         
14c2:c8           iny             ; filename
14c3:b9 00 1e     lda ioStack,y
14c6:85 47        sta ioName
14c8:c8           iny
14c9:b9 00 1e     lda ioStack,y
14cc:85 48        sta ioName+1
14ce:         
14ce:c8           iny             ; status
14cf:b9 00 1e     lda ioStack,y
14d2:8d 0c 22     sta ioStatus
14d5:         
14d5:c8           iny
14d6:b9 00 1e     lda ioStack,y   ; device
14d9:8d 07 22     sta ioDev
14dc:         
14dc:c8           iny             ; LFN
14dd:be 00 1e     ldx ioStack,y
14e0:8e 0b 22     stx ioLFN
14e3:             
14e3:84 3f        sty ioPtr
14e5:         
14e5:f0 03        beq :zero       ; do not redirect from 0
14e7:4c c6 ff     jmp CHKIN       ; this also becomes our current input
14ea:         :zero
14ea:60           rts
14eb:         
14eb:         ;
14eb:         ; allocate device secondary
14eb:         ; result in Y
14eb:         ioAlloc:
14eb:a9 01        lda #$01
14ed:a0 00        ldy #0
14ef:18           clc
14f0:         :scan
14f0:2c 0a 22     bit ioFDS
14f3:f0 04        beq :done
14f5:c8           iny
14f6:0a           asl
14f7:90 f7        bcc :scan
14f9:         :done
14f9:0d 0a 22     ora ioFDS
14fc:8d 0a 22     sta ioFDS
14ff:60           rts
1500:         
1500:         ;
1500:         ; deallocate device secondary in Y
1500:         ioDealloc:
1500:a9 01        lda #$01
1502:         :shift
1502:c0 00        cpy #0
1504:f0 04        beq :done
1506:0a           asl
1507:88           dey
1508:d0 f8        bne :shift
150a:         :done
150a:49 ff        eor #$ff        ; clear the bit
150c:2d 0a 22     and ioFDS
150f:8d 0a 22     sta ioFDS
1512:60           rts
1513:         
1513:         ;
1513:         ; read a line of input from current file
1513:         ; if ioLFN is 0 on return, at end of all files and nothing read
1513:         ioReadLine:
1513:ad 0c 22     lda ioStatus    ; check last eof
1516:f0 0b        beq :next       ; no eof, continue
1518:         
1518:20 9a 14     jsr ioPop
151b:ad 0b 22     lda ioLFN
151e:f0 02        beq :done
1520:80 f1        bra ioReadLine
1522:         
1522:         :done
1522:60           rts             ; end of all files
1523:         
1523:         :next
1523:f8           sed             ; increment bcd line number
1524:18           clc
1525:ad 08 22     lda ioLine
1528:69 01        adc #$01
152a:8d 08 22     sta ioLine
152d:ad 09 22     lda ioLine+1
1530:69 00        adc #0
1532:8d 09 22     sta ioLine+1
1535:d8           cld
1536:         
1536:a0 00        ldy #0
1538:20 cf ff     jsr CHRIN       ; read first, check error
153b:8d 00 20     sta lineBuf
153e:20 58 15     jsr ioReadStatus
1541:d0 10        bne :eol
1543:ad 00 20     lda lineBuf
1546:         :loop               ; this means if line does not end in CR, we can fail
1546:c9 0d        cmp #13         ; cr
1548:f0 09        beq :eol
154a:20 cf ff     jsr CHRIN
154d:c8           iny
154e:99 00 20     sta lineBuf,y        
1551:d0 f3        bne :loop
1553:         
1553:         :eol
1553:a9 00        lda #0
1555:99 00 20     sta lineBuf,y
1558:         
1558:         ioReadStatus:
1558:20 b7 ff     jsr READST
155b:8d 0c 22     sta ioStatus
155e:89 bf        bit #$bf        ; everything except eof
1560:f0 04        beq :done
1562:a9 1c        lda #errors:io
1564:85 46        sta error
1566:         :done
1566:89 ff        bit #$ff        ; leave Z=0 if EOF
1568:60           rts
1569:         
1569:         ;
1569:         ; emit binary output
1569:         ioEmit:
1569:86 2a        stx emitX
156b:84 2b        sty emitY
156d:a4 50        ldy ioOutPtr
156f:99 00 1d     sta ioBuf,y
1572:c8           iny
1573:84 50        sty ioOutPtr
1575:18           clc             ; no error
1576:d0 03        bne :out
1578:20 a3 15     jsr ioFlushAlways
157b:         :out
157b:a6 2a        ldx emitX
157d:a4 2b        ldy emitY
157f:60           rts
1580:         
1580:         ;
1580:         ; emit listing output
1580:         ioEmitListing:
1580:20 98 16     jsr ioHex
1583:a9 20        lda #32
1585:20 69 15     jsr ioEmit
1588:b0 14        bcs :out
158a:ee 10 22     inc ioColumn
158d:ad 10 22     lda ioColumn
1590:c9 08        cmp #8
1592:90 0a        bcc :out
1594:a9 0d        lda #13
1596:20 69 15     jsr ioEmit
1599:b0 03        bcs :out
159b:20 36 16     jsr ioListing
159e:         :out
159e:60           rts
159f:         
159f:         
159f:         ;
159f:         ; flush any unwritten output
159f:         ioFlush:
159f:a5 50        lda ioOutPtr
15a1:f0 45        beq ioSuccess
15a3:         ioFlushAlways:
15a3:20 cc ff     jsr CLRCHN
15a6:a2 02        ldx #2
15a8:20 c9 ff     jsr CHKOUT
15ab:b0 1e        bcs :done
15ad:         
15ad:a5 50        lda ioOutPtr    ; try to write entire buffer
15af:a2 00        ldx #<ioBuf     ; invariant: 0; this is page aligned
15b1:a0 1d        ldy #>ioBuf
15b3:20 b1 fe     jsr MCIOUT
15b6:b0 06        bcs :slow       ; not supported
15b8:         
15b8:e4 50        cpx ioOutPtr    ; did we write everything?
15ba:f0 0f        beq :done
15bc:80 02        bra :loop       ; byte bang the rest
15be:         
15be:         :slow
15be:a2 00        ldx #0          ; byte bang
15c0:         :loop
15c0:bd 00 1d     lda ioBuf,x
15c3:20 d2 ff     jsr CHROUT
15c6:e8           inx
15c7:e4 50        cpx ioOutPtr
15c9:d0 f5        bne :loop
15cb:         :done
15cb:64 50        stz ioOutPtr
15cd:20 cc ff     jsr CLRCHN
15d0:ae 0b 22     ldx ioLFN
15d3:f0 03        beq :noread
15d5:20 c6 ff     jsr CHKIN
15d8:         :noread
15d8:20 b7 ff     jsr READST
15db:c9 00        cmp #0
15dd:f0 09        beq ioSuccess
15df:8d 0c 22     sta ioStatus
15e2:a9 1c        lda #errors:io
15e4:85 46        sta error
15e6:38           sec
15e7:60           rts
15e8:         ioSuccess:
15e8:18           clc
15e9:60           rts
15ea:         
15ea:         ;
15ea:         ; flush output buffer and close
15ea:         ioClose:
15ea:20 9f 15     jsr ioFlush
15ed:a9 02        lda #2
15ef:4c c3 ff     jmp CLOSE
15f2:         
15f2:         ;
15f2:         ; close all disk before exiting abnormally
15f2:         ioCloseAll:
15f2:             ; preserve filename and line number for error
15f2:ad 08 22     lda ioLine
15f5:8d 00 20     sta lineBuf
15f8:ad 09 22     lda ioLine+1
15fb:8d 01 20     sta lineBuf+1
15fe:a5 49        lda ioNameL
1600:8d 02 20     sta lineBuf+2
1603:a5 47        lda ioName
1605:8d 03 20     sta lineBuf+3
1608:a5 48        lda ioName+1
160a:8d 04 20     sta lineBuf+4
160d:         
160d:20 ea 15     jsr ioClose
1610:         :loop
1610:ad 0b 22     lda ioLFN
1613:f0 05        beq :done
1615:20 9a 14     jsr ioPop
1618:80 f6        bra :loop
161a:         :done
161a:ad 00 20     lda lineBuf
161d:8d 08 22     sta ioLine
1620:ad 01 20     lda lineBuf+1
1623:8d 09 22     sta ioLine+1
1626:ad 02 20     lda lineBuf+2
1629:85 49        sta ioNameL
162b:ad 03 20     lda lineBuf+3
162e:85 47        sta ioName
1630:ad 04 20     lda lineBuf+4
1633:85 48        sta ioName+1
1635:         
1635:60           rts
1636:         
1636:         ;
1636:         ; emit listing address, reset column count
1636:         ioListing:
1636:a5 40        lda pass
1638:10 18        bpl :silent     ; $80 must be set in pass for this output
163a:a5 44        lda lineIfs
163c:30 14        bmi :silent     ; do not list if'd out
163e:ad 12 22     lda pc+1        ; PC:
1641:20 98 16     jsr ioHex
1644:ad 11 22     lda pc
1647:20 98 16     jsr ioHex
164a:a9 3a        lda #':
164c:20 69 15     jsr ioEmit
164f:9c 10 22     stz ioColumn
1652:         :silent
1652:60           rts
1653:         
1653:         ;
1653:         ; pad trailing spaced per ioColumn
1653:         ioPadListing:
1653:a9 03        lda #3
1655:38           sec
1656:ed 10 22     sbc ioColumn
1659:90 0c        bcc :nextLine
165b:aa           tax
165c:18           clc
165d:         :loop
165d:ca           dex
165e:30 1f        bmi :done
1660:a0 03        ldy #3
1662:20 75 16     jsr :spaces
1665:80 f6        bra :loop
1667:         :nextLine
1667:a9 0d        lda #13         ; cr
1669:20 69 15     jsr ioEmit
166c:b0 11        bcs :done
166e:a0 0d        ldy #13         ; xxxx:aa bb cc
1670:20 75 16     jsr :spaces
1673:80 e8        bra :loop
1675:         :spaces
1675:a9 20        lda #32         ; space
1677:20 69 15     jsr ioEmit
167a:b0 03        bcs :done
167c:88           dey
167d:d0 f6        bne :spaces
167f:         :done
167f:60           rts
1680:         
1680:         ;
1680:         ; print hex byte in A
1680:         ioPrintHex:
1680:85 22        sta scratch
1682:4a           lsr
1683:4a           lsr
1684:4a           lsr
1685:4a           lsr
1686:20 8d 16     jsr :digit
1689:a5 22        lda scratch
168b:29 0f        and #$0f
168d:         :digit
168d:c9 0a        cmp #10
168f:90 02        bcc :num
1691:69 06        adc #6          ; add 7 (C=1)
1693:         :num
1693:69 30        adc #'0
1695:4c d2 ff     jmp CHROUT
1698:         
1698:         ;
1698:         ; emit hex byte in A
1698:         ioHex:
1698:85 22        sta scratch
169a:4a           lsr
169b:4a           lsr
169c:4a           lsr
169d:4a           lsr
169e:20 a5 16     jsr :digit
16a1:a5 22        lda scratch
16a3:29 0f        and #$0f
16a5:         :digit
16a5:c9 0a        cmp #10
16a7:90 02        bcc :num
16a9:69 06        adc #6
16ab:         :num
16ab:69 30        adc #'0
16ad:4c 69 15     jmp ioEmit
16b0:         
16b0:         ;
16b0:         ; print 0 terminated string in X/Y
16b0:         ; uses ptr
16b0:         ioPrint:
16b0:86 27        stx ptr
16b2:84 28        sty ptr+1
16b4:a0 00        ldy #0
16b6:         :loop
16b6:b1 27        lda (ptr),y
16b8:f0 06        beq :done
16ba:20 d2 ff     jsr CHROUT
16bd:c8           iny
16be:d0 f6        bne :loop
16c0:         :done
16c0:60           rts
16c1:         
16c1:         ;
16c1:         ; print errror message
16c1:         ioPrintErr:
16c1:a6 46        ldx error
16c3:bd cd 16     lda :table,x
16c6:bc ce 16     ldy :table+1,x
16c9:aa           tax
16ca:4c b0 16     jmp ioPrint
16cd:         :table
16cd:         errors:
16cd:         :fine	=*-errors
16cd:ed 16        .dw :strings:fine
16cf:         :dupLabel=*-errors
16cf:f2 16        .dw :strings:dupLabel
16d1:         :star	=*-errors
16d1:fc 16        .dw :strings:star
16d3:         :backward=*-errors
16d3:06 17        .dw :strings:backward
16d5:         :eval	=*-errors
16d5:14 17        .dw :strings:eval
16d7:         :assign	=*-errors
16d7:23 17        .dw :strings:assign
16d9:         :dotOp	=*-errors
16d9:31 17        .dw :strings:dotOp
16db:         :op	=*-errors
16db:43 17        .dw :strings:op
16dd:         :mode	=*-errors
16dd:4e 17        .dw :strings:mode
16df:         :rel	=*-errors
16df:5f 17        .dw :strings:rel
16e1:         :parse	=*-errors
16e1:73 17        .dw :strings:parse
16e3:         :noArg	=*-errors
16e3:80 17        .dw :strings:noArg
16e5:         :emit	=*-errors
16e5:8d 17        .dw :strings:emit
16e7:         :dotArg	=*-errors
16e7:9c 17        .dw :strings:dotArg
16e9:         :io	=*-errors
16e9:ae 17        .dw :strings:io
16eb:         :tooMany=*-errors
16eb:b7 17        .dw :strings:tooMany
16ed:         
16ed:         errors:strings:
16ed:         :fine
16ed:46 49 4e 45 00 
                 .db 'fine',0
16f2:         :dupLabel
16f2:44 55 50 20 4c 41 42 45 
16fa:4c 00        .db 'dup label',0
16fc:         :star
16fc:53 54 41 52 20 45 58 50 
1704:52 00        .db 'star expr',0
1706:         :backward
1706:50 43 20 4d 4f 56 45 44 
170e:20 42 41 43 4b 00 
                 .db 'pc moved back',0
1714:         :eval
1714:42 41 44 20 45 58 50 52 
171c:45 53 53 49 4f 4e 00 
                 .db 'bad expression',0
1723:         :assign
1723:42 41 44 20 41 53 53 49 
172b:47 4d 45 4e 54 00 
                 .db 'bad assigment',0
1731:         :dotOp
1731:55 4e 4b 4e 4f 57 4e 20 
1739:50 53 45 55 44 4f 20 4f 
1741:50 00        .db 'unknown pseudo op',0
1743:         :op
1743:55 4e 4b 4e 4f 57 4e 20 
174b:4f 50 00     .db 'unknown op',0
174e:         :mode
174e:42 41 44 20 41 44 44 52 
1756:45 53 53 20 4d 4f 44 45 
175e:00           .db 'bad address mode',0
175f:         :rel
175f:42 52 41 4e 43 48 20 4f 
1767:55 54 20 4f 46 20 52 41 
176f:4e 47 45 00 
                 .db 'branch out of range',0
1773:         :parse
1773:53 59 4e 54 41 58 20 45 
177b:52 52 4f 52 00 
                 .db 'syntax error',0
1780:         :noArg
1780:41 52 47 20 45 58 50 45 
1788:43 54 45 44 00 
                 .db 'arg expected',0
178d:         :emit
178d:49 4f 20 57 52 49 54 45 
1795:20 45 52 52 4f 52 00 
                 .db 'io write error',0
179c:         :dotArg
179c:42 41 44 20 50 53 45 55 
17a4:44 4f 20 4f 50 20 41 52 
17ac:47 00        .db 'bad pseudo op arg',0
17ae:         :io
17ae:49 4f 20 45 52 52 4f 52 
17b6:00           .db 'io error',0
17b7:         :tooMany
17b7:54 4f 4f 20 4d 41 4e 59 
17bf:20 4f 50 45 4e 20 46 49 
17c7:4c 45 53 00 
                 .db 'too many open files',0
17cb:         
17cb:             .in 'isns.asm'
17cb:             .in 'zp.asm'
17cb:             .fi ; zpAsm
17cb:         
17cb:             .in 'mode.asm'
17cb:             .fi ; modeAsm
17cb:         
17cb:         
17cb:         
17cb:         ;
17cb:         ; return isn token at lineBuf,x
17cb:         ; isnOp: result
17cb:         ; C: not found
17cb:         isnGet:
17cb:             ; A,B,C = a-'A', b-'A', c-'A'
17cb:             ; 
17cb:             ; bit fedcba9876543210
17cb:             ;     0AAAAABBBBBCCCCC
17cb:             ; ex "LDA" is $2c60
17cb:             ;
17cb:bd 00 20     lda lineBuf,x
17ce:38           sec
17cf:e9 41        sbc #'a
17d1:0a           asl
17d2:0a           asl
17d3:85 23        sta isn2
17d5:bd 01 20     lda lineBuf+1,x
17d8:38           sec
17d9:e9 41        sbc #'a
17db:85 22        sta isn1
17dd:4a           lsr
17de:4a           lsr
17df:4a           lsr
17e0:04 23        tsb isn2
17e2:a5 22        lda isn1
17e4:0a           asl
17e5:0a           asl
17e6:0a           asl
17e7:0a           asl
17e8:0a           asl
17e9:85 22        sta isn1
17eb:bd 02 20     lda lineBuf+2,x
17ee:38           sec
17ef:e9 41        sbc #'a
17f1:04 22        tsb isn1
17f3:         
17f3:             ; incr=1 element (2 bytes per entry)
17f3:a0 02        ldy #2
17f5:84 24        sty incr
17f7:         
17f7:         :loop
17f7:a5 23        lda isn2        ; hi cmp
17f9:d9 65 18     cmp isns+1,y
17fc:d0 07        bne :cmp        ; if =, continue with lo cmp
17fe:         
17fe:a5 22        lda isn1        ; lo cmp
1800:d9 64 18     cmp isns,y
1803:f0 11        beq :found      ; if =, found
1805:         
1805:         :cmp
1805:90 05        bcc :lo         ; needle < haystack location?
1807:20 1a 18     jsr :next       ; no: extra advance to do it twice
180a:b0 09        bcs :not
180c:         
180c:         :lo
180c:20 1a 18     jsr :next       ; advance
180f:b0 04        bcs :not
1811:         
1811:06 24        asl incr        ; double incr for next advance
1813:90 e2        bcc :loop
1815:         :not
1815:60           rts             ; invariant: C=1
1816:         
1816:         :found
1816:18           clc             ; C=0 to indicate found
1817:84 33        sty isnOp
1819:60           rts
181a:         
181a:         :next
181a:98           tya             ; y += incr
181b:18           clc
181c:65 24        adc incr        ; C=1 if over
181e:a8           tay
181f:60           rts
1820:         
1820:         ;
1820:         ; resolve deduced address mode and instruction
1820:         opResolve:
1820:a6 33        ldx isnOp
1822:bd 65 19     lda ops+1,x
1825:f0 2e        beq :imp
1827:85 28        sta ptr+1
1829:bd 64 19     lda ops,x
182c:85 27        sta ptr
182e:         
182e:             ; can we zp this?
182e:a5 36        lda arg+1       ; no, it is a 16 bit arg
1830:d0 15        bne :try
1832:         
1832:a5 34        lda isnMode     ; does this have a potential zp version?
1834:c9 05        cmp #5
1836:b0 0f        bcs :try        ; no
1838:         
1838:69 0a        adc #10         ; try the zp form
183a:85 34        sta isnMode
183c:20 47 18     jsr :try
183f:90 20        bcc :out        ; we win (or it was relative)
1841:         
1841:a5 34        lda isnMode
1843:e9 0a        sbc #10
1845:85 34        sta isnMode     ; continue with original absolute
1847:         
1847:         :try
1847:a4 34        ldy isnMode
1849:b1 27        lda (ptr),y
184b:d0 11        bne :found      ; found it
184d:         
184d:a0 08        ldy #modeRel
184f:b1 27        lda (ptr),y
1851:d0 0b        bne :found
1853:         
1853:80 0d        bra :err
1855:             
1855:         :imp
1855:a4 34        ldy isnMode     ; has to be modeImp
1857:c0 07        cpy #modeImp
1859:d0 07        bne :err
185b:bd 64 19     lda ops,x
185e:             ; fall thru
185e:         
185e:         :found
185e:84 34        sty isnMode
1860:18           clc
1861:         :out
1861:60           rts
1862:         
1862:         :err
1862:38           sec
1863:60           rts
1864:         
1864:             .in 'isns-table.asm'
1864:         *=*%100
1864:         isns:
1864:00 00        .dw $0000
1866:51 2e        .dw $2e51 ; 02 lsr
1868:32 04        .dw $0432 ; 04 bbs
186a:f2 4e        .dw $4ef2 ; 06 txs
186c:00 00        .dw $0000
186e:22 48        .dw $4822 ; 0a sbc
1870:75 09        .dw $0975 ; 0c clv
1872:ff 7f        .dw $7fff
1874:00 00        .dw $0000
1876:6f 3d        .dw $3d6f ; 12 plp
1878:eb 05        .dw $05eb ; 14 bpl
187a:ff 7f        .dw $7fff
187c:00 00        .dw $0000
187e:78 4a        .dw $4a78 ; 1a sty
1880:a2 21        .dw $21a2 ; 1c inc
1882:ff 7f        .dw $7fff
1884:00 00        .dw $0000
1886:ef 3c        .dw $3cef ; 22 php
1888:90 04        .dw $0490 ; 24 beq
188a:ff 7f        .dw $7fff
188c:00 00        .dw $0000
188e:81 49        .dw $4981 ; 2a smb
1890:82 0c        .dw $0c82 ; 2c dec
1892:ff 7f        .dw $7fff
1894:00 00        .dw $0000
1896:cb 45        .dw $45cb ; 32 rol
1898:b2 06        .dw $06b2 ; 34 bvs
189a:ff 7f        .dw $7fff
189c:62 00        .dw $0062 ; 38 adc
189e:21 4e        .dw $4e21 ; 3a trb
18a0:51 26        .dw $2651 ; 3c jsr
18a2:ff 7f        .dw $7fff
18a4:00 00        .dw $0000
18a6:20 3a        .dw $3a20 ; 42 ora
18a8:42 04        .dw $0442 ; 44 bcc
18aa:08 58        .dw $5808 ; 46 wai
18ac:00 00        .dw $0000
18ae:83 48        .dw $4883 ; 4a sed
18b0:f7 09        .dw $09f7 ; 4c cpx
18b2:ff 7f        .dw $7fff
18b4:00 00        .dw $0000
18b6:78 3d        .dw $3d78 ; 52 ply
18b8:2a 06        .dw $062a ; 54 brk
18ba:ff 7f        .dw $7fff
18bc:00 00        .dw $0000
18be:17 4c        .dw $4c17 ; 5a tax
18c0:b8 21        .dw $21b8 ; 5c iny
18c2:ff 7f        .dw $7fff
18c4:00 00        .dw $0000
18c6:f8 3c        .dw $3cf8 ; 62 phy
18c8:88 05        .dw $0588 ; 64 bmi
18ca:ff 7f        .dw $7fff
18cc:00 00        .dw $0000
18ce:6f 4a        .dw $4a6f ; 6a stp
18d0:98 0c        .dw $0c98 ; 6c dey
18d2:ff 7f        .dw $7fff
18d4:00 00        .dw $0000
18d6:68 46        .dw $4668 ; 72 rti
18d8:63 09        .dw $0963 ; 74 cld
18da:ff 7f        .dw $7fff
18dc:4b 02        .dw $024b ; 78 asl
18de:57 4e        .dw $4e57 ; 7a tsx
18e0:77 2c        .dw $2c77 ; 7c ldx
18e2:ff 7f        .dw $7fff
18e4:00 00        .dw $0000
18e6:cf 35        .dw $35cf ; 82 nop
18e8:42 04        .dw $0442 ; 84 bcc
18ea:00 4f        .dw $4f00 ; 86 tya
18ec:00 00        .dw $0000
18ee:82 48        .dw $4882 ; 8a sec
18f0:8f 09        .dw $098f ; 8c cmp
18f2:ff 7f        .dw $7fff
18f4:00 00        .dw $0000
18f6:77 3d        .dw $3d77 ; 92 plx
18f8:20 06        .dw $0620 ; 94 bra
18fa:ff 7f        .dw $7fff
18fc:00 00        .dw $0000
18fe:79 4a        .dw $4a79 ; 9a stz
1900:b7 21        .dw $21b7 ; 9c inx
1902:ff 7f        .dw $7fff
1904:00 00        .dw $0000
1906:f7 3c        .dw $3cf7 ; a2 phx
1908:13 05        .dw $0513 ; a4 bit
190a:ff 7f        .dw $7fff
190c:00 00        .dw $0000
190e:60 4a        .dw $4a60 ; aa sta
1910:97 0c        .dw $0c97 ; ac dex
1912:ff 7f        .dw $7fff
1914:00 00        .dw $0000
1916:d1 45        .dw $45d1 ; b2 ror
1918:62 09        .dw $0962 ; b4 clc
191a:ff 7f        .dw $7fff
191c:a3 01        .dw $01a3 ; b8 and
191e:41 4e        .dw $4e41 ; ba tsb
1920:60 2c        .dw $2c60 ; bc lda
1922:ff 7f        .dw $7fff
1924:00 00        .dw $0000
1926:e0 3c        .dw $3ce0 ; c2 pha
1928:52 04        .dw $0452 ; c4 bcs
192a:ff 7f        .dw $7fff
192c:00 00        .dw $0000
192e:88 48        .dw $4888 ; ca sei
1930:f8 09        .dw $09f8 ; cc cpy
1932:ff 7f        .dw $7fff
1934:00 00        .dw $0000
1936:81 45        .dw $4581 ; d2 rmb
1938:a2 06        .dw $06a2 ; d4 bvc
193a:ff 7f        .dw $7fff
193c:00 00        .dw $0000
193e:18 4c        .dw $4c18 ; da tay
1940:8f 25        .dw $258f ; dc jmp
1942:ff 7f        .dw $7fff
1944:00 00        .dw $0000
1946:60 3d        .dw $3d60 ; e2 pla
1948:a4 05        .dw $05a4 ; e4 bne
194a:ff 7f        .dw $7fff
194c:00 00        .dw $0000
194e:77 4a        .dw $4a77 ; ea stx
1950:d1 11        .dw $11d1 ; ec eor
1952:ff 7f        .dw $7fff
1954:00 00        .dw $0000
1956:72 46        .dw $4672 ; f2 rts
1958:68 09        .dw $0968 ; f4 cli
195a:ff 7f        .dw $7fff
195c:31 04        .dw $0431 ; f8 bbr
195e:e0 4e        .dw $4ee0 ; fa txa
1960:78 2c        .dw $2c78 ; fc ldy
1962:ff 7f        .dw $7fff
1964:         
1964:         ops:
1964:00 00     .dw 0
1966:04 1c     .dw :lsr
1968:a4 1a     .dw :bbs
196a:9a 00     .dw $9a ; txs
196c:00 00     .dw 0
196e:54 1c     .dw :sbc
1970:b8 00     .dw $b8 ; clv
1972:00 00     .dw 0
1974:00 00     .dw 0
1976:28 00     .dw $28 ; plp
1978:14 1b     .dw :bpl
197a:00 00     .dw 0
197c:00 00     .dw 0
197e:94 1c     .dw :sty
1980:a4 1b     .dw :inc
1982:00 00     .dw 0
1984:00 00     .dw 0
1986:08 00     .dw $08 ; php
1988:d4 1a     .dw :beq
198a:00 00     .dw 0
198c:00 00     .dw 0
198e:64 1c     .dw :smb
1990:84 1b     .dw :dec
1992:00 00     .dw 0
1994:00 00     .dw 0
1996:34 1c     .dw :rol
1998:44 1b     .dw :bvs
199a:00 00     .dw 0
199c:64 1a     .dw :adc
199e:b4 1c     .dw :trb
19a0:c4 1b     .dw :jsr
19a2:00 00     .dw 0
19a4:00 00     .dw 0
19a6:14 1c     .dw :ora
19a8:b4 1a     .dw :bcc
19aa:cb 00     .dw $cb ; wai
19ac:00 00     .dw 0
19ae:f8 00     .dw $f8 ; sed
19b0:64 1b     .dw :cpx
19b2:00 00     .dw 0
19b4:00 00     .dw 0
19b6:7a 00     .dw $7a ; ply
19b8:00 00     .dw $00 ; brk
19ba:00 00     .dw 0
19bc:00 00     .dw 0
19be:aa 00     .dw $aa ; tax
19c0:c8 00     .dw $c8 ; iny
19c2:00 00     .dw 0
19c4:00 00     .dw 0
19c6:5a 00     .dw $5a ; phy
19c8:f4 1a     .dw :bmi
19ca:00 00     .dw 0
19cc:00 00     .dw 0
19ce:db 00     .dw $db ; stp
19d0:88 00     .dw $88 ; dey
19d2:00 00     .dw 0
19d4:00 00     .dw 0
19d6:40 00     .dw $40 ; rti
19d8:d8 00     .dw $d8 ; cld
19da:00 00     .dw 0
19dc:84 1a     .dw :asl
19de:ba 00     .dw $ba ; tsx
19e0:e4 1b     .dw :ldx
19e2:00 00     .dw 0
19e4:00 00     .dw 0
19e6:ea 00     .dw $ea ; nop
19e8:b4 1a     .dw :bcc
19ea:98 00     .dw $98 ; tya
19ec:00 00     .dw 0
19ee:38 00     .dw $38 ; sec
19f0:54 1b     .dw :cmp
19f2:00 00     .dw 0
19f4:00 00     .dw 0
19f6:fa 00     .dw $fa ; plx
19f8:24 1b     .dw :bra
19fa:00 00     .dw 0
19fc:00 00     .dw 0
19fe:a4 1c     .dw :stz
1a00:e8 00     .dw $e8 ; inx
1a02:00 00     .dw 0
1a04:00 00     .dw 0
1a06:da 00     .dw $da ; phx
1a08:e4 1a     .dw :bit
1a0a:00 00     .dw 0
1a0c:00 00     .dw 0
1a0e:74 1c     .dw :sta
1a10:ca 00     .dw $ca ; dex
1a12:00 00     .dw 0
1a14:00 00     .dw 0
1a16:44 1c     .dw :ror
1a18:18 00     .dw $18 ; clc
1a1a:00 00     .dw 0
1a1c:74 1a     .dw :and
1a1e:c4 1c     .dw :tsb
1a20:d4 1b     .dw :lda
1a22:00 00     .dw 0
1a24:00 00     .dw 0
1a26:48 00     .dw $48 ; pha
1a28:c4 1a     .dw :bcs
1a2a:00 00     .dw 0
1a2c:00 00     .dw 0
1a2e:78 00     .dw $78 ; sei
1a30:74 1b     .dw :cpy
1a32:00 00     .dw 0
1a34:00 00     .dw 0
1a36:24 1c     .dw :rmb
1a38:34 1b     .dw :bvc
1a3a:00 00     .dw 0
1a3c:00 00     .dw 0
1a3e:a8 00     .dw $a8 ; tay
1a40:b4 1b     .dw :jmp
1a42:00 00     .dw 0
1a44:00 00     .dw 0
1a46:68 00     .dw $68 ; pla
1a48:04 1b     .dw :bne
1a4a:00 00     .dw 0
1a4c:00 00     .dw 0
1a4e:84 1c     .dw :stx
1a50:94 1b     .dw :eor
1a52:00 00     .dw 0
1a54:00 00     .dw 0
1a56:60 00     .dw $60 ; rts
1a58:58 00     .dw $58 ; cli
1a5a:00 00     .dw 0
1a5c:94 1a     .dw :bbr
1a5e:8a 00     .dw $8a ; txa
1a60:f4 1b     .dw :ldy
1a62:00 00     .dw 0
1a64:         :adc
1a64:6d 00 7d 79 00 00 69 00 
1a6c:00 00 65 61 75 00 72 71 
1a74:          .db $6d,$00,$7d,$79,$00,$00,$69,$00,$00,$00,$65,$61,$75,$00,$72,$71
1a74:         :and
1a74:2d 00 3d 39 00 00 29 00 
1a7c:00 00 25 21 35 00 32 31 
1a84:          .db $2d,$00,$3d,$39,$00,$00,$29,$00,$00,$00,$25,$21,$35,$00,$32,$31
1a84:         :asl
1a84:0e 00 1e 00 00 00 00 0a 
1a8c:00 00 06 00 16 00 00 00 
1a94:          .db $0e,$00,$1e,$00,$00,$00,$00,$0a,$00,$00,$06,$00,$16,$00,$00,$00
1a94:         :bbr
1a94:00 00 00 00 00 00 00 00 
1a9c:00 0f 00 00 00 00 00 00 
1aa4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$0f,$00,$00,$00,$00,$00,$00
1aa4:         :bbs
1aa4:00 00 00 00 00 00 00 00 
1aac:00 8f 00 00 00 00 00 00 
1ab4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$00,$8f,$00,$00,$00,$00,$00,$00
1ab4:         :bcc
1ab4:00 00 00 00 00 00 00 00 
1abc:90 00 00 00 00 00 00 00 
1ac4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$90,$00,$00,$00,$00,$00,$00,$00
1ac4:         :bcs
1ac4:00 00 00 00 00 00 00 00 
1acc:b0 00 00 00 00 00 00 00 
1ad4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$b0,$00,$00,$00,$00,$00,$00,$00
1ad4:         :beq
1ad4:00 00 00 00 00 00 00 00 
1adc:f0 00 00 00 00 00 00 00 
1ae4:          .db $00,$00,$00,$00,$00,$00,$00,$00,$f0,$00,$00,$00,$00,$00,$00,$00
1ae4:         :bit
1ae4:2c 00 3c 00 00 00 89 00 
1aec:00 00 24 00 34 00 00 00 
1af4:          .db $2c,$00,$3c,$00,$00,$00,$89,$00,$00,$00,$24,$00,$34,$00,$00,$00
1af4:         :bmi
1af4:00 00 00 00 00 00 00 00 
1afc:30 00 00 00 00 00 00 00 
1b04:          .db $00,$00,$00,$00,$00,$00,$00,$00,$30,$00,$00,$00,$00,$00,$00,$00
1b04:         :bne
1b04:00 00 00 00 00 00 00 00 
1b0c:d0 00 00 00 00 00 00 00 
1b14:          .db $00,$00,$00,$00,$00,$00,$00,$00,$d0,$00,$00,$00,$00,$00,$00,$00
1b14:         :bpl
1b14:00 00 00 00 00 00 00 00 
1b1c:10 00 00 00 00 00 00 00 
1b24:          .db $00,$00,$00,$00,$00,$00,$00,$00,$10,$00,$00,$00,$00,$00,$00,$00
1b24:         :bra
1b24:00 00 00 00 00 00 00 00 
1b2c:80 00 00 00 00 00 00 00 
1b34:          .db $00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00
1b34:         :bvc
1b34:00 00 00 00 00 00 00 00 
1b3c:50 00 00 00 00 00 00 00 
1b44:          .db $00,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00,$00,$00,$00,$00,$00
1b44:         :bvs
1b44:00 00 00 00 00 00 00 00 
1b4c:70 00 00 00 00 00 00 00 
1b54:          .db $00,$00,$00,$00,$00,$00,$00,$00,$70,$00,$00,$00,$00,$00,$00,$00
1b54:         :cmp
1b54:cd 00 dd d9 00 00 c9 00 
1b5c:00 00 c5 c1 d5 00 d2 d1 
1b64:          .db $cd,$00,$dd,$d9,$00,$00,$c9,$00,$00,$00,$c5,$c1,$d5,$00,$d2,$d1
1b64:         :cpx
1b64:ec 00 00 00 00 00 e0 00 
1b6c:00 00 e4 00 00 00 00 00 
1b74:          .db $ec,$00,$00,$00,$00,$00,$e0,$00,$00,$00,$e4,$00,$00,$00,$00,$00
1b74:         :cpy
1b74:cc 00 00 00 00 00 c0 00 
1b7c:00 00 c4 00 00 00 00 00 
1b84:          .db $cc,$00,$00,$00,$00,$00,$c0,$00,$00,$00,$c4,$00,$00,$00,$00,$00
1b84:         :dec
1b84:ce 00 de 00 00 00 00 3a 
1b8c:00 00 c6 00 d6 00 00 00 
1b94:          .db $ce,$00,$de,$00,$00,$00,$00,$3a,$00,$00,$c6,$00,$d6,$00,$00,$00
1b94:         :eor
1b94:4d 00 5d 59 00 00 49 00 
1b9c:00 00 45 41 55 00 52 51 
1ba4:          .db $4d,$00,$5d,$59,$00,$00,$49,$00,$00,$00,$45,$41,$55,$00,$52,$51
1ba4:         :inc
1ba4:ee 00 fe 00 00 00 00 1a 
1bac:00 00 e6 00 f6 00 00 00 
1bb4:          .db $ee,$00,$fe,$00,$00,$00,$00,$1a,$00,$00,$e6,$00,$f6,$00,$00,$00
1bb4:         :jmp
1bb4:4c 7c 00 00 6c 00 00 00 
1bbc:00 00 00 00 00 00 00 00 
1bc4:          .db $4c,$7c,$00,$00,$6c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1bc4:         :jsr
1bc4:20 00 00 00 00 00 00 00 
1bcc:00 00 00 00 00 00 00 00 
1bd4:          .db $20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1bd4:         :lda
1bd4:ad 00 bd b9 00 00 a9 00 
1bdc:00 00 a5 a1 b5 00 b2 b1 
1be4:          .db $ad,$00,$bd,$b9,$00,$00,$a9,$00,$00,$00,$a5,$a1,$b5,$00,$b2,$b1
1be4:         :ldx
1be4:ae 00 00 be 00 00 a2 00 
1bec:00 00 a6 00 00 b6 00 00 
1bf4:          .db $ae,$00,$00,$be,$00,$00,$a2,$00,$00,$00,$a6,$00,$00,$b6,$00,$00
1bf4:         :ldy
1bf4:ac 00 bc 00 00 00 a0 00 
1bfc:00 00 a4 00 b4 00 00 00 
1c04:          .db $ac,$00,$bc,$00,$00,$00,$a0,$00,$00,$00,$a4,$00,$b4,$00,$00,$00
1c04:         :lsr
1c04:4e 00 5e 00 00 00 00 4a 
1c0c:00 00 46 00 56 00 00 00 
1c14:          .db $4e,$00,$5e,$00,$00,$00,$00,$4a,$00,$00,$46,$00,$56,$00,$00,$00
1c14:         :ora
1c14:0d 00 1d 19 00 00 09 00 
1c1c:00 00 05 01 15 00 12 11 
1c24:          .db $0d,$00,$1d,$19,$00,$00,$09,$00,$00,$00,$05,$01,$15,$00,$12,$11
1c24:         :rmb
1c24:00 00 00 00 00 07 00 00 
1c2c:00 00 00 00 00 00 00 00 
1c34:          .db $00,$00,$00,$00,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1c34:         :rol
1c34:2e 00 3e 00 00 00 00 2a 
1c3c:00 00 26 00 36 00 00 00 
1c44:          .db $2e,$00,$3e,$00,$00,$00,$00,$2a,$00,$00,$26,$00,$36,$00,$00,$00
1c44:         :ror
1c44:6e 00 7e 00 00 00 00 6a 
1c4c:00 00 66 00 76 00 00 00 
1c54:          .db $6e,$00,$7e,$00,$00,$00,$00,$6a,$00,$00,$66,$00,$76,$00,$00,$00
1c54:         :sbc
1c54:ed 00 fd f9 00 00 e9 00 
1c5c:00 00 e5 e1 f5 00 f2 f1 
1c64:          .db $ed,$00,$fd,$f9,$00,$00,$e9,$00,$00,$00,$e5,$e1,$f5,$00,$f2,$f1
1c64:         :smb
1c64:00 00 00 00 00 87 00 00 
1c6c:00 00 00 00 00 00 00 00 
1c74:          .db $00,$00,$00,$00,$00,$87,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
1c74:         :sta
1c74:8d 00 9d 99 00 00 00 00 
1c7c:00 00 85 81 95 00 92 91 
1c84:          .db $8d,$00,$9d,$99,$00,$00,$00,$00,$00,$00,$85,$81,$95,$00,$92,$91
1c84:         :stx
1c84:8e 00 00 00 00 00 00 00 
1c8c:00 00 86 00 00 96 00 00 
1c94:          .db $8e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$86,$00,$00,$96,$00,$00
1c94:         :sty
1c94:8c 00 00 00 00 00 00 00 
1c9c:00 00 84 00 94 00 00 00 
1ca4:          .db $8c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$84,$00,$94,$00,$00,$00
1ca4:         :stz
1ca4:9c 00 9e 00 00 00 00 00 
1cac:00 00 64 00 74 00 00 00 
1cb4:          .db $9c,$00,$9e,$00,$00,$00,$00,$00,$00,$00,$64,$00,$74,$00,$00,$00
1cb4:         :trb
1cb4:1c 00 00 00 00 00 00 00 
1cbc:00 00 14 00 00 00 00 00 
1cc4:          .db $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$14,$00,$00,$00,$00,$00
1cc4:         :tsb
1cc4:0c 00 00 00 00 00 00 00 
1ccc:00 00 04 00 00 00 00 00 
1cd4:          .db $0c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$00,$00,$00,$00,$00
1cd4:         ; size=$0470
1cd4:         
1cd4:         
1cd4:             .in 'memory.asm'
1cd4:         ;
1cd4:         ; runtime data
1cd4:         ; include LAST
1cd4:         
1cd4:             .or *%$100
1d00:         ioBuf:          ; binary output buffer
1d00:             .or *+$100
1e00:         ioStack:        ; source file stack
1e00:             .or *+$100
1f00:         eStack:         ; numeric evaluation stack
1f00:             .or *+$100
2000:         lineBuf:        ; line to parse
2000:             .or *+$100
2100:         hashTable:      ; symbol hash table page
2100:             .or *+$100
2200:         fpack:          ; 5 bytes of space for packed floating point number
2200:             .or *+5
2205:         emit:           ; emit vector
2205:             .or *+2
2207:         ioDev:          ; current disk device
2207:             .or *+1
2208:         ioLine:         ; current line
2208:             .or *+2
220a:         ioFDS:          ; allocation bitmap of channels
220a:             .or *+1
220b:         ioLFN:          ; current logical file number
220b:             .or *+1
220c:         ioStatus:       ; input status
220c:             .or *+1
220d:         asmSP:          ; stack frame we started with
220d:             .or *+1
220e:         lineSP:         ; stack frame for calls into per line assembly for error return
220e:             .or *+1
220f:         argZ:           ; first zp of zp,arg
220f:             .or *+1
2210:         ioColumn:       ; listing output column
2210:             .or *+1
2211:         pc:             ; pc
2211:             .or *+2
2213:         inputOpt:       ; input filename length
2213:             .or *+1
2214:         listOpt:        ; listing filename length
2214:             .or *+1
2215:         outOpt:         ; output filename length
2215:             .or *+1
2216:         tScope:         ; save scope
2216:             .or *+2
2218:         symbols:        ; start of symbol table
2218:         
2218:         
2218: